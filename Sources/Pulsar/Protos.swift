// Copyright 2025 Felix Ruppert
//
// Licensed under the Apache License, Version 2.0 (the License );
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an AS IS BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pulsar.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// *
/// Licensed to the Apache Software Foundation (ASF) under one
/// or more contributor license agreements.  See the NOTICE file
/// distributed with this work for additional information
/// regarding copyright ownership.  The ASF licenses this file
/// to you under the Apache License, Version 2.0 (the
/// "License"); you may not use this file except in compliance
/// with the License.  You may obtain a copy of the License at
///
///   http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing,
/// software distributed under the License is distributed on an
/// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
/// KIND, either express or implied.  See the License for the
/// specific language governing permissions and limitations
/// under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
	struct _2: SwiftProtobuf.ProtobufAPIVersion_2 { }
	typealias Version = _2
}

enum Pulsar_Proto_CompressionType: SwiftProtobuf.Enum, Swift.CaseIterable {
	typealias RawValue = Int
	case none // = 0
	case lz4 // = 1
	case zlib // = 2
	case zstd // = 3
	case snappy // = 4

	init() {
		self = .none
	}

	init?(rawValue: Int) {
		switch rawValue {
			case 0: self = .none
			case 1: self = .lz4
			case 2: self = .zlib
			case 3: self = .zstd
			case 4: self = .snappy
			default: return nil
		}
	}

	var rawValue: Int {
		switch self {
			case .none: 0
			case .lz4: 1
			case .zlib: 2
			case .zstd: 3
			case .snappy: 4
		}
	}
}

enum Pulsar_Proto_ProducerAccessMode: SwiftProtobuf.Enum, Swift.CaseIterable {
	typealias RawValue = Int

	/// By default multiple producers can publish on a topic
	case shared // = 0

	/// Require exclusive access for producer. Fail immediately if there's already a producer connected.
	case exclusive // = 1

	/// Producer creation is pending until it can acquire exclusive access
	case waitForExclusive // = 2

	/// Require exclusive access for producer. Fence out old producer.
	case exclusiveWithFencing // = 3

	init() {
		self = .shared
	}

	init?(rawValue: Int) {
		switch rawValue {
			case 0: self = .shared
			case 1: self = .exclusive
			case 2: self = .waitForExclusive
			case 3: self = .exclusiveWithFencing
			default: return nil
		}
	}

	var rawValue: Int {
		switch self {
			case .shared: 0
			case .exclusive: 1
			case .waitForExclusive: 2
			case .exclusiveWithFencing: 3
		}
	}
}

enum Pulsar_Proto_ServerError: SwiftProtobuf.Enum, Swift.CaseIterable {
	typealias RawValue = Int
	case unknownError // = 0

	/// Error with ZK/metadata
	case metadataError // = 1

	/// Error writing reading from BK
	case persistenceError // = 2

	/// Non valid authentication
	case authenticationError // = 3

	/// Not authorized to use resource
	case authorizationError // = 4

	/// Unable to subscribe/unsubscribe because
	case consumerBusy // = 5

	/// other consumers are connected
	case serviceNotReady // = 6

	/// Unable to create producer because backlog quota exceeded
	case producerBlockedQuotaExceededError // = 7

	/// Exception while creating producer because quota exceeded
	case producerBlockedQuotaExceededException // = 8

	/// Error while verifying message checksum
	case checksumError // = 9

	/// Error when an older client/version doesn't support a required feature
	case unsupportedVersionError // = 10

	/// Topic not found
	case topicNotFound // = 11

	/// Subscription not found
	case subscriptionNotFound // = 12

	/// Consumer not found
	case consumerNotFound // = 13

	/// Error with too many simultaneously request
	case tooManyRequests // = 14

	/// The topic has been terminated
	case topicTerminatedError // = 15

	/// Producer with same name is already connected
	case producerBusy // = 16

	/// The topic name is not valid
	case invalidTopicName // = 17

	/// Specified schema was incompatible with topic schema
	case incompatibleSchema // = 18

	/// Dispatcher assign consumer error
	case consumerAssignError // = 19

	/// Transaction coordinator not found error
	case transactionCoordinatorNotFound // = 20

	/// Invalid txn status error
	case invalidTxnStatus // = 21

	/// Not allowed error
	case notAllowedError // = 22

	/// Ack with transaction conflict
	case transactionConflict // = 23

	/// Transaction not found
	case transactionNotFound // = 24

	/// When a producer asks and fail to get exclusive producer access,
	case producerFenced // = 25

	init() {
		self = .unknownError
	}

	init?(rawValue: Int) {
		switch rawValue {
			case 0: self = .unknownError
			case 1: self = .metadataError
			case 2: self = .persistenceError
			case 3: self = .authenticationError
			case 4: self = .authorizationError
			case 5: self = .consumerBusy
			case 6: self = .serviceNotReady
			case 7: self = .producerBlockedQuotaExceededError
			case 8: self = .producerBlockedQuotaExceededException
			case 9: self = .checksumError
			case 10: self = .unsupportedVersionError
			case 11: self = .topicNotFound
			case 12: self = .subscriptionNotFound
			case 13: self = .consumerNotFound
			case 14: self = .tooManyRequests
			case 15: self = .topicTerminatedError
			case 16: self = .producerBusy
			case 17: self = .invalidTopicName
			case 18: self = .incompatibleSchema
			case 19: self = .consumerAssignError
			case 20: self = .transactionCoordinatorNotFound
			case 21: self = .invalidTxnStatus
			case 22: self = .notAllowedError
			case 23: self = .transactionConflict
			case 24: self = .transactionNotFound
			case 25: self = .producerFenced
			default: return nil
		}
	}

	var rawValue: Int {
		switch self {
			case .unknownError: 0
			case .metadataError: 1
			case .persistenceError: 2
			case .authenticationError: 3
			case .authorizationError: 4
			case .consumerBusy: 5
			case .serviceNotReady: 6
			case .producerBlockedQuotaExceededError: 7
			case .producerBlockedQuotaExceededException: 8
			case .checksumError: 9
			case .unsupportedVersionError: 10
			case .topicNotFound: 11
			case .subscriptionNotFound: 12
			case .consumerNotFound: 13
			case .tooManyRequests: 14
			case .topicTerminatedError: 15
			case .producerBusy: 16
			case .invalidTopicName: 17
			case .incompatibleSchema: 18
			case .consumerAssignError: 19
			case .transactionCoordinatorNotFound: 20
			case .invalidTxnStatus: 21
			case .notAllowedError: 22
			case .transactionConflict: 23
			case .transactionNotFound: 24
			case .producerFenced: 25
		}
	}
}

enum Pulsar_Proto_AuthMethod: SwiftProtobuf.Enum, Swift.CaseIterable {
	typealias RawValue = Int
	case none // = 0
	case ycaV1 // = 1
	case athens // = 2

	init() {
		self = .none
	}

	init?(rawValue: Int) {
		switch rawValue {
			case 0: self = .none
			case 1: self = .ycaV1
			case 2: self = .athens
			default: return nil
		}
	}

	var rawValue: Int {
		switch self {
			case .none: 0
			case .ycaV1: 1
			case .athens: 2
		}
	}
}

/// Each protocol version identify new features that are
/// incrementally added to the protocol
enum Pulsar_Proto_ProtocolVersion: SwiftProtobuf.Enum, Swift.CaseIterable {
	typealias RawValue = Int

	/// Initial versioning
	case v0 // = 0

	/// Added application keep-alive
	case v1 // = 1

	/// Added RedeliverUnacknowledgedMessages Command
	case v2 // = 2

	/// Added compression with LZ4 and ZLib
	case v3 // = 3

	/// Added batch message support
	case v4 // = 4

	/// Added disconnect client w/o closing connection
	case v5 // = 5

	/// Added checksum computation for metadata + payload
	case v6 // = 6

	/// Added CommandLookupTopic - Binary Lookup
	case v7 // = 7

	/// Added CommandConsumerStats - Client fetches broker side consumer stats
	case v8 // = 8

	/// Added end of topic notification
	case v9 // = 9

	/// Added proxy to broker
	case v10 // = 10

	/// C++ consumers before this version are not correctly handling the checksum field
	case v11 // = 11

	/// Added get topic's last messageID from broker
	case v12 // = 12

	/// Added CommandActiveConsumerChange
	/// Added CommandGetTopicsOfNamespace
	case v13 // = 13

	/// Add CommandAuthChallenge and CommandAuthResponse for mutual auth
	case v14 // = 14

	/// Added Key_Shared subscription
	case v15 // = 15

	/// Add support for broker entry metadata
	case v16 // = 16

	/// Added support ack receipt
	case v17 // = 17

	/// Add client support for broker entry metadata
	case v18 // = 18

	/// Add CommandTcClientConnectRequest and CommandTcClientConnectResponse
	case v19 // = 19

	/// Add client support for topic migration redirection CommandTopicMigrated
	case v20 // = 20

	/// Carry the AUTO_CONSUME schema to the Broker after this version
	case v21 // = 21

	init() {
		self = .v0
	}

	init?(rawValue: Int) {
		switch rawValue {
			case 0: self = .v0
			case 1: self = .v1
			case 2: self = .v2
			case 3: self = .v3
			case 4: self = .v4
			case 5: self = .v5
			case 6: self = .v6
			case 7: self = .v7
			case 8: self = .v8
			case 9: self = .v9
			case 10: self = .v10
			case 11: self = .v11
			case 12: self = .v12
			case 13: self = .v13
			case 14: self = .v14
			case 15: self = .v15
			case 16: self = .v16
			case 17: self = .v17
			case 18: self = .v18
			case 19: self = .v19
			case 20: self = .v20
			case 21: self = .v21
			default: return nil
		}
	}

	var rawValue: Int {
		switch self {
			case .v0: 0
			case .v1: 1
			case .v2: 2
			case .v3: 3
			case .v4: 4
			case .v5: 5
			case .v6: 6
			case .v7: 7
			case .v8: 8
			case .v9: 9
			case .v10: 10
			case .v11: 11
			case .v12: 12
			case .v13: 13
			case .v14: 14
			case .v15: 15
			case .v16: 16
			case .v17: 17
			case .v18: 18
			case .v19: 19
			case .v20: 20
			case .v21: 21
		}
	}
}

enum Pulsar_Proto_KeySharedMode: SwiftProtobuf.Enum, Swift.CaseIterable {
	typealias RawValue = Int
	case autoSplit // = 0
	case sticky // = 1

	init() {
		self = .autoSplit
	}

	init?(rawValue: Int) {
		switch rawValue {
			case 0: self = .autoSplit
			case 1: self = .sticky
			default: return nil
		}
	}

	var rawValue: Int {
		switch self {
			case .autoSplit: 0
			case .sticky: 1
		}
	}
}

enum Pulsar_Proto_TxnAction: SwiftProtobuf.Enum, Swift.CaseIterable {
	typealias RawValue = Int
	case commit // = 0
	case abort // = 1

	init() {
		self = .commit
	}

	init?(rawValue: Int) {
		switch rawValue {
			case 0: self = .commit
			case 1: self = .abort
			default: return nil
		}
	}

	var rawValue: Int {
		switch self {
			case .commit: 0
			case .abort: 1
		}
	}
}

struct Pulsar_Proto_Schema: @unchecked Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var name: String {
		get { _name ?? String() }
		set { _name = newValue }
	}

	/// Returns true if `name` has been explicitly set.
	var hasName: Bool { _name != nil }
	/// Clears the value of `name`. Subsequent reads from it will return its default value.
	mutating func clearName() { _name = nil }

	var schemaData: Data {
		get { _schemaData ?? Data() }
		set { _schemaData = newValue }
	}

	/// Returns true if `schemaData` has been explicitly set.
	var hasSchemaData: Bool { _schemaData != nil }
	/// Clears the value of `schemaData`. Subsequent reads from it will return its default value.
	mutating func clearSchemaData() { _schemaData = nil }

	var type: Pulsar_Proto_Schema.TypeEnum {
		get { _type ?? .none }
		set { _type = newValue }
	}

	/// Returns true if `type` has been explicitly set.
	var hasType: Bool { _type != nil }
	/// Clears the value of `type`. Subsequent reads from it will return its default value.
	mutating func clearType() { _type = nil }

	var properties: [Pulsar_Proto_KeyValue] = []

	var unknownFields = SwiftProtobuf.UnknownStorage()

	enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
		typealias RawValue = Int
		case none // = 0
		case string // = 1
		case json // = 2
		case protobuf // = 3
		case avro // = 4
		case bool // = 5
		case int8 // = 6
		case int16 // = 7
		case int32 // = 8
		case int64 // = 9
		case float // = 10
		case double // = 11
		case date // = 12
		case time // = 13
		case timestamp // = 14
		case keyValue // = 15
		case instant // = 16
		case localDate // = 17
		case localTime // = 18
		case localDateTime // = 19
		case protobufNative // = 20
		case autoConsume // = 21

		init() {
			self = .none
		}

		init?(rawValue: Int) {
			switch rawValue {
				case 0: self = .none
				case 1: self = .string
				case 2: self = .json
				case 3: self = .protobuf
				case 4: self = .avro
				case 5: self = .bool
				case 6: self = .int8
				case 7: self = .int16
				case 8: self = .int32
				case 9: self = .int64
				case 10: self = .float
				case 11: self = .double
				case 12: self = .date
				case 13: self = .time
				case 14: self = .timestamp
				case 15: self = .keyValue
				case 16: self = .instant
				case 17: self = .localDate
				case 18: self = .localTime
				case 19: self = .localDateTime
				case 20: self = .protobufNative
				case 21: self = .autoConsume
				default: return nil
			}
		}

		var rawValue: Int {
			switch self {
				case .none: 0
				case .string: 1
				case .json: 2
				case .protobuf: 3
				case .avro: 4
				case .bool: 5
				case .int8: 6
				case .int16: 7
				case .int32: 8
				case .int64: 9
				case .float: 10
				case .double: 11
				case .date: 12
				case .time: 13
				case .timestamp: 14
				case .keyValue: 15
				case .instant: 16
				case .localDate: 17
				case .localTime: 18
				case .localDateTime: 19
				case .protobufNative: 20
				case .autoConsume: 21
			}
		}
	}

	init() { }

	fileprivate var _name: String?
	fileprivate var _schemaData: Data?
	fileprivate var _type: Pulsar_Proto_Schema.TypeEnum?
}

struct Pulsar_Proto_MessageIDData: @unchecked Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var ledgerID: UInt64 {
		get { _storage._ledgerID ?? 0 }
		set { _uniqueStorage()._ledgerID = newValue }
	}

	/// Returns true if `ledgerID` has been explicitly set.
	var hasLedgerID: Bool { _storage._ledgerID != nil }
	/// Clears the value of `ledgerID`. Subsequent reads from it will return its default value.
	mutating func clearLedgerID() { _uniqueStorage()._ledgerID = nil }

	var entryID: UInt64 {
		get { _storage._entryID ?? 0 }
		set { _uniqueStorage()._entryID = newValue }
	}

	/// Returns true if `entryID` has been explicitly set.
	var hasEntryID: Bool { _storage._entryID != nil }
	/// Clears the value of `entryID`. Subsequent reads from it will return its default value.
	mutating func clearEntryID() { _uniqueStorage()._entryID = nil }

	var partition: Int32 {
		get { _storage._partition ?? -1 }
		set { _uniqueStorage()._partition = newValue }
	}

	/// Returns true if `partition` has been explicitly set.
	var hasPartition: Bool { _storage._partition != nil }
	/// Clears the value of `partition`. Subsequent reads from it will return its default value.
	mutating func clearPartition() { _uniqueStorage()._partition = nil }

	var batchIndex: Int32 {
		get { _storage._batchIndex ?? -1 }
		set { _uniqueStorage()._batchIndex = newValue }
	}

	/// Returns true if `batchIndex` has been explicitly set.
	var hasBatchIndex: Bool { _storage._batchIndex != nil }
	/// Clears the value of `batchIndex`. Subsequent reads from it will return its default value.
	mutating func clearBatchIndex() { _uniqueStorage()._batchIndex = nil }

	var ackSet: [Int64] {
		get { _storage._ackSet }
		set { _uniqueStorage()._ackSet = newValue }
	}

	var batchSize: Int32 {
		get { _storage._batchSize ?? 0 }
		set { _uniqueStorage()._batchSize = newValue }
	}

	/// Returns true if `batchSize` has been explicitly set.
	var hasBatchSize: Bool { _storage._batchSize != nil }
	/// Clears the value of `batchSize`. Subsequent reads from it will return its default value.
	mutating func clearBatchSize() { _uniqueStorage()._batchSize = nil }

	/// For the chunk message id, we need to specify the first chunk message id.
	var firstChunkMessageID: Pulsar_Proto_MessageIDData {
		get { _storage._firstChunkMessageID ?? Pulsar_Proto_MessageIDData() }
		set { _uniqueStorage()._firstChunkMessageID = newValue }
	}

	/// Returns true if `firstChunkMessageID` has been explicitly set.
	var hasFirstChunkMessageID: Bool { _storage._firstChunkMessageID != nil }
	/// Clears the value of `firstChunkMessageID`. Subsequent reads from it will return its default value.
	mutating func clearFirstChunkMessageID() { _uniqueStorage()._firstChunkMessageID = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _storage = _StorageClass.defaultInstance
}

struct Pulsar_Proto_KeyValue: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var key: String {
		get { _key ?? String() }
		set { _key = newValue }
	}

	/// Returns true if `key` has been explicitly set.
	var hasKey: Bool { _key != nil }
	/// Clears the value of `key`. Subsequent reads from it will return its default value.
	mutating func clearKey() { _key = nil }

	var value: String {
		get { _value ?? String() }
		set { _value = newValue }
	}

	/// Returns true if `value` has been explicitly set.
	var hasValue: Bool { _value != nil }
	/// Clears the value of `value`. Subsequent reads from it will return its default value.
	mutating func clearValue() { _value = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _key: String? = nil
	fileprivate var _value: String? = nil
}

struct Pulsar_Proto_KeyLongValue: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var key: String {
		get { _key ?? String() }
		set { _key = newValue }
	}

	/// Returns true if `key` has been explicitly set.
	var hasKey: Bool { _key != nil }
	/// Clears the value of `key`. Subsequent reads from it will return its default value.
	mutating func clearKey() { _key = nil }

	var value: UInt64 {
		get { _value ?? 0 }
		set { _value = newValue }
	}

	/// Returns true if `value` has been explicitly set.
	var hasValue: Bool { _value != nil }
	/// Clears the value of `value`. Subsequent reads from it will return its default value.
	mutating func clearValue() { _value = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _key: String? = nil
	fileprivate var _value: UInt64? = nil
}

struct Pulsar_Proto_IntRange: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var start: Int32 {
		get { _start ?? 0 }
		set { _start = newValue }
	}

	/// Returns true if `start` has been explicitly set.
	var hasStart: Bool { _start != nil }
	/// Clears the value of `start`. Subsequent reads from it will return its default value.
	mutating func clearStart() { _start = nil }

	var end: Int32 {
		get { _end ?? 0 }
		set { _end = newValue }
	}

	/// Returns true if `end` has been explicitly set.
	var hasEnd: Bool { _end != nil }
	/// Clears the value of `end`. Subsequent reads from it will return its default value.
	mutating func clearEnd() { _end = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _start: Int32? = nil
	fileprivate var _end: Int32? = nil
}

struct Pulsar_Proto_EncryptionKeys: @unchecked Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var key: String {
		get { _key ?? String() }
		set { _key = newValue }
	}

	/// Returns true if `key` has been explicitly set.
	var hasKey: Bool { _key != nil }
	/// Clears the value of `key`. Subsequent reads from it will return its default value.
	mutating func clearKey() { _key = nil }

	var value: Data {
		get { _value ?? Data() }
		set { _value = newValue }
	}

	/// Returns true if `value` has been explicitly set.
	var hasValue: Bool { _value != nil }
	/// Clears the value of `value`. Subsequent reads from it will return its default value.
	mutating func clearValue() { _value = nil }

	var metadata: [Pulsar_Proto_KeyValue] = []

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _key: String?
	fileprivate var _value: Data?
}

struct Pulsar_Proto_MessageMetadata: @unchecked Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var producerName: String {
		get { _storage._producerName ?? String() }
		set { _uniqueStorage()._producerName = newValue }
	}

	/// Returns true if `producerName` has been explicitly set.
	var hasProducerName: Bool { _storage._producerName != nil }
	/// Clears the value of `producerName`. Subsequent reads from it will return its default value.
	mutating func clearProducerName() { _uniqueStorage()._producerName = nil }

	var sequenceID: UInt64 {
		get { _storage._sequenceID ?? 0 }
		set { _uniqueStorage()._sequenceID = newValue }
	}

	/// Returns true if `sequenceID` has been explicitly set.
	var hasSequenceID: Bool { _storage._sequenceID != nil }
	/// Clears the value of `sequenceID`. Subsequent reads from it will return its default value.
	mutating func clearSequenceID() { _uniqueStorage()._sequenceID = nil }

	var publishTime: UInt64 {
		get { _storage._publishTime ?? 0 }
		set { _uniqueStorage()._publishTime = newValue }
	}

	/// Returns true if `publishTime` has been explicitly set.
	var hasPublishTime: Bool { _storage._publishTime != nil }
	/// Clears the value of `publishTime`. Subsequent reads from it will return its default value.
	mutating func clearPublishTime() { _uniqueStorage()._publishTime = nil }

	var properties: [Pulsar_Proto_KeyValue] {
		get { _storage._properties }
		set { _uniqueStorage()._properties = newValue }
	}

	/// Property set on replicated message,
	/// includes the source cluster name
	var replicatedFrom: String {
		get { _storage._replicatedFrom ?? String() }
		set { _uniqueStorage()._replicatedFrom = newValue }
	}

	/// Returns true if `replicatedFrom` has been explicitly set.
	var hasReplicatedFrom: Bool { _storage._replicatedFrom != nil }
	/// Clears the value of `replicatedFrom`. Subsequent reads from it will return its default value.
	mutating func clearReplicatedFrom() { _uniqueStorage()._replicatedFrom = nil }

	/// key to decide partition for the msg
	var partitionKey: String {
		get { _storage._partitionKey ?? String() }
		set { _uniqueStorage()._partitionKey = newValue }
	}

	/// Returns true if `partitionKey` has been explicitly set.
	var hasPartitionKey: Bool { _storage._partitionKey != nil }
	/// Clears the value of `partitionKey`. Subsequent reads from it will return its default value.
	mutating func clearPartitionKey() { _uniqueStorage()._partitionKey = nil }

	/// Override namespace's replication
	var replicateTo: [String] {
		get { _storage._replicateTo }
		set { _uniqueStorage()._replicateTo = newValue }
	}

	var compression: Pulsar_Proto_CompressionType {
		get { _storage._compression ?? .none }
		set { _uniqueStorage()._compression = newValue }
	}

	/// Returns true if `compression` has been explicitly set.
	var hasCompression: Bool { _storage._compression != nil }
	/// Clears the value of `compression`. Subsequent reads from it will return its default value.
	mutating func clearCompression() { _uniqueStorage()._compression = nil }

	var uncompressedSize: UInt32 {
		get { _storage._uncompressedSize ?? 0 }
		set { _uniqueStorage()._uncompressedSize = newValue }
	}

	/// Returns true if `uncompressedSize` has been explicitly set.
	var hasUncompressedSize: Bool { _storage._uncompressedSize != nil }
	/// Clears the value of `uncompressedSize`. Subsequent reads from it will return its default value.
	mutating func clearUncompressedSize() { _uniqueStorage()._uncompressedSize = nil }

	/// Removed below checksum field from Metadata as
	/// it should be part of send-command which keeps checksum of header + payload
	/// optional sfixed64 checksum = 10;
	/// differentiate single and batch message metadata
	var numMessagesInBatch: Int32 {
		get { _storage._numMessagesInBatch ?? 1 }
		set { _uniqueStorage()._numMessagesInBatch = newValue }
	}

	/// Returns true if `numMessagesInBatch` has been explicitly set.
	var hasNumMessagesInBatch: Bool { _storage._numMessagesInBatch != nil }
	/// Clears the value of `numMessagesInBatch`. Subsequent reads from it will return its default value.
	mutating func clearNumMessagesInBatch() { _uniqueStorage()._numMessagesInBatch = nil }

	/// the timestamp that this event occurs. it is typically set by applications.
	/// if this field is omitted, `publish_time` can be used for the purpose of `event_time`.
	var eventTime: UInt64 {
		get { _storage._eventTime ?? 0 }
		set { _uniqueStorage()._eventTime = newValue }
	}

	/// Returns true if `eventTime` has been explicitly set.
	var hasEventTime: Bool { _storage._eventTime != nil }
	/// Clears the value of `eventTime`. Subsequent reads from it will return its default value.
	mutating func clearEventTime() { _uniqueStorage()._eventTime = nil }

	/// Contains encryption key name, encrypted key and metadata to describe the key
	var encryptionKeys: [Pulsar_Proto_EncryptionKeys] {
		get { _storage._encryptionKeys }
		set { _uniqueStorage()._encryptionKeys = newValue }
	}

	/// Algorithm used to encrypt data key
	var encryptionAlgo: String {
		get { _storage._encryptionAlgo ?? String() }
		set { _uniqueStorage()._encryptionAlgo = newValue }
	}

	/// Returns true if `encryptionAlgo` has been explicitly set.
	var hasEncryptionAlgo: Bool { _storage._encryptionAlgo != nil }
	/// Clears the value of `encryptionAlgo`. Subsequent reads from it will return its default value.
	mutating func clearEncryptionAlgo() { _uniqueStorage()._encryptionAlgo = nil }

	/// Additional parameters required by encryption
	var encryptionParam: Data {
		get { _storage._encryptionParam ?? Data() }
		set { _uniqueStorage()._encryptionParam = newValue }
	}

	/// Returns true if `encryptionParam` has been explicitly set.
	var hasEncryptionParam: Bool { _storage._encryptionParam != nil }
	/// Clears the value of `encryptionParam`. Subsequent reads from it will return its default value.
	mutating func clearEncryptionParam() { _uniqueStorage()._encryptionParam = nil }

	var schemaVersion: Data {
		get { _storage._schemaVersion ?? Data() }
		set { _uniqueStorage()._schemaVersion = newValue }
	}

	/// Returns true if `schemaVersion` has been explicitly set.
	var hasSchemaVersion: Bool { _storage._schemaVersion != nil }
	/// Clears the value of `schemaVersion`. Subsequent reads from it will return its default value.
	mutating func clearSchemaVersion() { _uniqueStorage()._schemaVersion = nil }

	var partitionKeyB64Encoded: Bool {
		get { _storage._partitionKeyB64Encoded ?? false }
		set { _uniqueStorage()._partitionKeyB64Encoded = newValue }
	}

	/// Returns true if `partitionKeyB64Encoded` has been explicitly set.
	var hasPartitionKeyB64Encoded: Bool { _storage._partitionKeyB64Encoded != nil }
	/// Clears the value of `partitionKeyB64Encoded`. Subsequent reads from it will return its default value.
	mutating func clearPartitionKeyB64Encoded() { _uniqueStorage()._partitionKeyB64Encoded = nil }

	/// Specific a key to overwrite the message key which used for ordering dispatch in Key_Shared mode.
	var orderingKey: Data {
		get { _storage._orderingKey ?? Data() }
		set { _uniqueStorage()._orderingKey = newValue }
	}

	/// Returns true if `orderingKey` has been explicitly set.
	var hasOrderingKey: Bool { _storage._orderingKey != nil }
	/// Clears the value of `orderingKey`. Subsequent reads from it will return its default value.
	mutating func clearOrderingKey() { _uniqueStorage()._orderingKey = nil }

	/// Mark the message to be delivered at or after the specified timestamp
	var deliverAtTime: Int64 {
		get { _storage._deliverAtTime ?? 0 }
		set { _uniqueStorage()._deliverAtTime = newValue }
	}

	/// Returns true if `deliverAtTime` has been explicitly set.
	var hasDeliverAtTime: Bool { _storage._deliverAtTime != nil }
	/// Clears the value of `deliverAtTime`. Subsequent reads from it will return its default value.
	mutating func clearDeliverAtTime() { _uniqueStorage()._deliverAtTime = nil }

	/// Identify whether a message is a "marker" message used for
	/// internal metadata instead of application published data.
	/// Markers will generally not be propagated back to clients
	var markerType: Int32 {
		get { _storage._markerType ?? 0 }
		set { _uniqueStorage()._markerType = newValue }
	}

	/// Returns true if `markerType` has been explicitly set.
	var hasMarkerType: Bool { _storage._markerType != nil }
	/// Clears the value of `markerType`. Subsequent reads from it will return its default value.
	mutating func clearMarkerType() { _uniqueStorage()._markerType = nil }

	/// transaction related message info
	var txnidLeastBits: UInt64 {
		get { _storage._txnidLeastBits ?? 0 }
		set { _uniqueStorage()._txnidLeastBits = newValue }
	}

	/// Returns true if `txnidLeastBits` has been explicitly set.
	var hasTxnidLeastBits: Bool { _storage._txnidLeastBits != nil }
	/// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidLeastBits() { _uniqueStorage()._txnidLeastBits = nil }

	var txnidMostBits: UInt64 {
		get { _storage._txnidMostBits ?? 0 }
		set { _uniqueStorage()._txnidMostBits = newValue }
	}

	/// Returns true if `txnidMostBits` has been explicitly set.
	var hasTxnidMostBits: Bool { _storage._txnidMostBits != nil }
	/// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidMostBits() { _uniqueStorage()._txnidMostBits = nil }

	//// Add highest sequence id to support batch message with external sequence id
	var highestSequenceID: UInt64 {
		get { _storage._highestSequenceID ?? 0 }
		set { _uniqueStorage()._highestSequenceID = newValue }
	}

	/// Returns true if `highestSequenceID` has been explicitly set.
	var hasHighestSequenceID: Bool { _storage._highestSequenceID != nil }
	/// Clears the value of `highestSequenceID`. Subsequent reads from it will return its default value.
	mutating func clearHighestSequenceID() { _uniqueStorage()._highestSequenceID = nil }

	/// Indicate if the message payload value is set
	var nullValue: Bool {
		get { _storage._nullValue ?? false }
		set { _uniqueStorage()._nullValue = newValue }
	}

	/// Returns true if `nullValue` has been explicitly set.
	var hasNullValue: Bool { _storage._nullValue != nil }
	/// Clears the value of `nullValue`. Subsequent reads from it will return its default value.
	mutating func clearNullValue() { _uniqueStorage()._nullValue = nil }

	var uuid: String {
		get { _storage._uuid ?? String() }
		set { _uniqueStorage()._uuid = newValue }
	}

	/// Returns true if `uuid` has been explicitly set.
	var hasUUID: Bool { _storage._uuid != nil }
	/// Clears the value of `uuid`. Subsequent reads from it will return its default value.
	mutating func clearUUID() { _uniqueStorage()._uuid = nil }

	var numChunksFromMsg: Int32 {
		get { _storage._numChunksFromMsg ?? 0 }
		set { _uniqueStorage()._numChunksFromMsg = newValue }
	}

	/// Returns true if `numChunksFromMsg` has been explicitly set.
	var hasNumChunksFromMsg: Bool { _storage._numChunksFromMsg != nil }
	/// Clears the value of `numChunksFromMsg`. Subsequent reads from it will return its default value.
	mutating func clearNumChunksFromMsg() { _uniqueStorage()._numChunksFromMsg = nil }

	var totalChunkMsgSize: Int32 {
		get { _storage._totalChunkMsgSize ?? 0 }
		set { _uniqueStorage()._totalChunkMsgSize = newValue }
	}

	/// Returns true if `totalChunkMsgSize` has been explicitly set.
	var hasTotalChunkMsgSize: Bool { _storage._totalChunkMsgSize != nil }
	/// Clears the value of `totalChunkMsgSize`. Subsequent reads from it will return its default value.
	mutating func clearTotalChunkMsgSize() { _uniqueStorage()._totalChunkMsgSize = nil }

	var chunkID: Int32 {
		get { _storage._chunkID ?? 0 }
		set { _uniqueStorage()._chunkID = newValue }
	}

	/// Returns true if `chunkID` has been explicitly set.
	var hasChunkID: Bool { _storage._chunkID != nil }
	/// Clears the value of `chunkID`. Subsequent reads from it will return its default value.
	mutating func clearChunkID() { _uniqueStorage()._chunkID = nil }

	/// Indicate if the message partition key is set
	var nullPartitionKey: Bool {
		get { _storage._nullPartitionKey ?? false }
		set { _uniqueStorage()._nullPartitionKey = newValue }
	}

	/// Returns true if `nullPartitionKey` has been explicitly set.
	var hasNullPartitionKey: Bool { _storage._nullPartitionKey != nil }
	/// Clears the value of `nullPartitionKey`. Subsequent reads from it will return its default value.
	mutating func clearNullPartitionKey() { _uniqueStorage()._nullPartitionKey = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _storage = _StorageClass.defaultInstance
}

struct Pulsar_Proto_SingleMessageMetadata: @unchecked Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var properties: [Pulsar_Proto_KeyValue] = []

	var partitionKey: String {
		get { _partitionKey ?? String() }
		set { _partitionKey = newValue }
	}

	/// Returns true if `partitionKey` has been explicitly set.
	var hasPartitionKey: Bool { _partitionKey != nil }
	/// Clears the value of `partitionKey`. Subsequent reads from it will return its default value.
	mutating func clearPartitionKey() { _partitionKey = nil }

	var payloadSize: Int32 {
		get { _payloadSize ?? 0 }
		set { _payloadSize = newValue }
	}

	/// Returns true if `payloadSize` has been explicitly set.
	var hasPayloadSize: Bool { _payloadSize != nil }
	/// Clears the value of `payloadSize`. Subsequent reads from it will return its default value.
	mutating func clearPayloadSize() { _payloadSize = nil }

	var compactedOut: Bool {
		get { _compactedOut ?? false }
		set { _compactedOut = newValue }
	}

	/// Returns true if `compactedOut` has been explicitly set.
	var hasCompactedOut: Bool { _compactedOut != nil }
	/// Clears the value of `compactedOut`. Subsequent reads from it will return its default value.
	mutating func clearCompactedOut() { _compactedOut = nil }

	/// the timestamp that this event occurs. it is typically set by applications.
	/// if this field is omitted, `publish_time` can be used for the purpose of `event_time`.
	var eventTime: UInt64 {
		get { _eventTime ?? 0 }
		set { _eventTime = newValue }
	}

	/// Returns true if `eventTime` has been explicitly set.
	var hasEventTime: Bool { _eventTime != nil }
	/// Clears the value of `eventTime`. Subsequent reads from it will return its default value.
	mutating func clearEventTime() { _eventTime = nil }

	var partitionKeyB64Encoded: Bool {
		get { _partitionKeyB64Encoded ?? false }
		set { _partitionKeyB64Encoded = newValue }
	}

	/// Returns true if `partitionKeyB64Encoded` has been explicitly set.
	var hasPartitionKeyB64Encoded: Bool { _partitionKeyB64Encoded != nil }
	/// Clears the value of `partitionKeyB64Encoded`. Subsequent reads from it will return its default value.
	mutating func clearPartitionKeyB64Encoded() { _partitionKeyB64Encoded = nil }

	/// Specific a key to overwrite the message key which used for ordering dispatch in Key_Shared mode.
	var orderingKey: Data {
		get { _orderingKey ?? Data() }
		set { _orderingKey = newValue }
	}

	/// Returns true if `orderingKey` has been explicitly set.
	var hasOrderingKey: Bool { _orderingKey != nil }
	/// Clears the value of `orderingKey`. Subsequent reads from it will return its default value.
	mutating func clearOrderingKey() { _orderingKey = nil }

	/// Allows consumer retrieve the sequence id that the producer set.
	var sequenceID: UInt64 {
		get { _sequenceID ?? 0 }
		set { _sequenceID = newValue }
	}

	/// Returns true if `sequenceID` has been explicitly set.
	var hasSequenceID: Bool { _sequenceID != nil }
	/// Clears the value of `sequenceID`. Subsequent reads from it will return its default value.
	mutating func clearSequenceID() { _sequenceID = nil }

	/// Indicate if the message payload value is set
	var nullValue: Bool {
		get { _nullValue ?? false }
		set { _nullValue = newValue }
	}

	/// Returns true if `nullValue` has been explicitly set.
	var hasNullValue: Bool { _nullValue != nil }
	/// Clears the value of `nullValue`. Subsequent reads from it will return its default value.
	mutating func clearNullValue() { _nullValue = nil }

	/// Indicate if the message partition key is set
	var nullPartitionKey: Bool {
		get { _nullPartitionKey ?? false }
		set { _nullPartitionKey = newValue }
	}

	/// Returns true if `nullPartitionKey` has been explicitly set.
	var hasNullPartitionKey: Bool { _nullPartitionKey != nil }
	/// Clears the value of `nullPartitionKey`. Subsequent reads from it will return its default value.
	mutating func clearNullPartitionKey() { _nullPartitionKey = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _partitionKey: String?
	fileprivate var _payloadSize: Int32?
	fileprivate var _compactedOut: Bool?
	fileprivate var _eventTime: UInt64?
	fileprivate var _partitionKeyB64Encoded: Bool?
	fileprivate var _orderingKey: Data?
	fileprivate var _sequenceID: UInt64?
	fileprivate var _nullValue: Bool?
	fileprivate var _nullPartitionKey: Bool?
}

/// metadata added for entry from broker
struct Pulsar_Proto_BrokerEntryMetadata: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var brokerTimestamp: UInt64 {
		get { _brokerTimestamp ?? 0 }
		set { _brokerTimestamp = newValue }
	}

	/// Returns true if `brokerTimestamp` has been explicitly set.
	var hasBrokerTimestamp: Bool { _brokerTimestamp != nil }
	/// Clears the value of `brokerTimestamp`. Subsequent reads from it will return its default value.
	mutating func clearBrokerTimestamp() { _brokerTimestamp = nil }

	var index: UInt64 {
		get { _index ?? 0 }
		set { _index = newValue }
	}

	/// Returns true if `index` has been explicitly set.
	var hasIndex: Bool { _index != nil }
	/// Clears the value of `index`. Subsequent reads from it will return its default value.
	mutating func clearIndex() { _index = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _brokerTimestamp: UInt64? = nil
	fileprivate var _index: UInt64? = nil
}

struct Pulsar_Proto_CommandConnect: @unchecked Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	/// The version of the client. Proxy should forward client's client_version.
	var clientVersion: String {
		get { _clientVersion ?? String() }
		set { _clientVersion = newValue }
	}

	/// Returns true if `clientVersion` has been explicitly set.
	var hasClientVersion: Bool { _clientVersion != nil }
	/// Clears the value of `clientVersion`. Subsequent reads from it will return its default value.
	mutating func clearClientVersion() { _clientVersion = nil }

	/// Deprecated. Use "auth_method_name" instead.
	var authMethod: Pulsar_Proto_AuthMethod {
		get { _authMethod ?? .none }
		set { _authMethod = newValue }
	}

	/// Returns true if `authMethod` has been explicitly set.
	var hasAuthMethod: Bool { _authMethod != nil }
	/// Clears the value of `authMethod`. Subsequent reads from it will return its default value.
	mutating func clearAuthMethod() { _authMethod = nil }

	var authMethodName: String {
		get { _authMethodName ?? String() }
		set { _authMethodName = newValue }
	}

	/// Returns true if `authMethodName` has been explicitly set.
	var hasAuthMethodName: Bool { _authMethodName != nil }
	/// Clears the value of `authMethodName`. Subsequent reads from it will return its default value.
	mutating func clearAuthMethodName() { _authMethodName = nil }

	var authData: Data {
		get { _authData ?? Data() }
		set { _authData = newValue }
	}

	/// Returns true if `authData` has been explicitly set.
	var hasAuthData: Bool { _authData != nil }
	/// Clears the value of `authData`. Subsequent reads from it will return its default value.
	mutating func clearAuthData() { _authData = nil }

	var protocolVersion: Int32 {
		get { _protocolVersion ?? 0 }
		set { _protocolVersion = newValue }
	}

	/// Returns true if `protocolVersion` has been explicitly set.
	var hasProtocolVersion: Bool { _protocolVersion != nil }
	/// Clears the value of `protocolVersion`. Subsequent reads from it will return its default value.
	mutating func clearProtocolVersion() { _protocolVersion = nil }

	/// Client can ask to be proxyied to a specific broker
	/// This is only honored by a Pulsar proxy
	var proxyToBrokerURL: String {
		get { _proxyToBrokerURL ?? String() }
		set { _proxyToBrokerURL = newValue }
	}

	/// Returns true if `proxyToBrokerURL` has been explicitly set.
	var hasProxyToBrokerURL: Bool { _proxyToBrokerURL != nil }
	/// Clears the value of `proxyToBrokerURL`. Subsequent reads from it will return its default value.
	mutating func clearProxyToBrokerURL() { _proxyToBrokerURL = nil }

	/// Original principal that was verified by
	/// a Pulsar proxy. In this case the auth info above
	/// will be the auth of the proxy itself
	var originalPrincipal: String {
		get { _originalPrincipal ?? String() }
		set { _originalPrincipal = newValue }
	}

	/// Returns true if `originalPrincipal` has been explicitly set.
	var hasOriginalPrincipal: Bool { _originalPrincipal != nil }
	/// Clears the value of `originalPrincipal`. Subsequent reads from it will return its default value.
	mutating func clearOriginalPrincipal() { _originalPrincipal = nil }

	/// Original auth role and auth Method that was passed
	/// to the proxy. In this case the auth info above
	/// will be the auth of the proxy itself
	var originalAuthData: String {
		get { _originalAuthData ?? String() }
		set { _originalAuthData = newValue }
	}

	/// Returns true if `originalAuthData` has been explicitly set.
	var hasOriginalAuthData: Bool { _originalAuthData != nil }
	/// Clears the value of `originalAuthData`. Subsequent reads from it will return its default value.
	mutating func clearOriginalAuthData() { _originalAuthData = nil }

	var originalAuthMethod: String {
		get { _originalAuthMethod ?? String() }
		set { _originalAuthMethod = newValue }
	}

	/// Returns true if `originalAuthMethod` has been explicitly set.
	var hasOriginalAuthMethod: Bool { _originalAuthMethod != nil }
	/// Clears the value of `originalAuthMethod`. Subsequent reads from it will return its default value.
	mutating func clearOriginalAuthMethod() { _originalAuthMethod = nil }

	/// Feature flags
	var featureFlags: Pulsar_Proto_FeatureFlags {
		get { _featureFlags ?? Pulsar_Proto_FeatureFlags() }
		set { _featureFlags = newValue }
	}

	/// Returns true if `featureFlags` has been explicitly set.
	var hasFeatureFlags: Bool { _featureFlags != nil }
	/// Clears the value of `featureFlags`. Subsequent reads from it will return its default value.
	mutating func clearFeatureFlags() { _featureFlags = nil }

	/// Version of the proxy. Should only be forwarded by a proxy.
	var proxyVersion: String {
		get { _proxyVersion ?? String() }
		set { _proxyVersion = newValue }
	}

	/// Returns true if `proxyVersion` has been explicitly set.
	var hasProxyVersion: Bool { _proxyVersion != nil }
	/// Clears the value of `proxyVersion`. Subsequent reads from it will return its default value.
	mutating func clearProxyVersion() { _proxyVersion = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _clientVersion: String?
	fileprivate var _authMethod: Pulsar_Proto_AuthMethod?
	fileprivate var _authMethodName: String?
	fileprivate var _authData: Data?
	fileprivate var _protocolVersion: Int32?
	fileprivate var _proxyToBrokerURL: String?
	fileprivate var _originalPrincipal: String?
	fileprivate var _originalAuthData: String?
	fileprivate var _originalAuthMethod: String?
	fileprivate var _featureFlags: Pulsar_Proto_FeatureFlags?
	fileprivate var _proxyVersion: String?
}

/// Please also add a new enum for the class "PulsarClientException.FailedFeatureCheck" when adding a new feature flag.
struct Pulsar_Proto_FeatureFlags: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var supportsAuthRefresh: Bool {
		get { _supportsAuthRefresh ?? false }
		set { _supportsAuthRefresh = newValue }
	}

	/// Returns true if `supportsAuthRefresh` has been explicitly set.
	var hasSupportsAuthRefresh: Bool { _supportsAuthRefresh != nil }
	/// Clears the value of `supportsAuthRefresh`. Subsequent reads from it will return its default value.
	mutating func clearSupportsAuthRefresh() { _supportsAuthRefresh = nil }

	var supportsBrokerEntryMetadata: Bool {
		get { _supportsBrokerEntryMetadata ?? false }
		set { _supportsBrokerEntryMetadata = newValue }
	}

	/// Returns true if `supportsBrokerEntryMetadata` has been explicitly set.
	var hasSupportsBrokerEntryMetadata: Bool { _supportsBrokerEntryMetadata != nil }
	/// Clears the value of `supportsBrokerEntryMetadata`. Subsequent reads from it will return its default value.
	mutating func clearSupportsBrokerEntryMetadata() { _supportsBrokerEntryMetadata = nil }

	var supportsPartialProducer: Bool {
		get { _supportsPartialProducer ?? false }
		set { _supportsPartialProducer = newValue }
	}

	/// Returns true if `supportsPartialProducer` has been explicitly set.
	var hasSupportsPartialProducer: Bool { _supportsPartialProducer != nil }
	/// Clears the value of `supportsPartialProducer`. Subsequent reads from it will return its default value.
	mutating func clearSupportsPartialProducer() { _supportsPartialProducer = nil }

	var supportsTopicWatchers: Bool {
		get { _supportsTopicWatchers ?? false }
		set { _supportsTopicWatchers = newValue }
	}

	/// Returns true if `supportsTopicWatchers` has been explicitly set.
	var hasSupportsTopicWatchers: Bool { _supportsTopicWatchers != nil }
	/// Clears the value of `supportsTopicWatchers`. Subsequent reads from it will return its default value.
	mutating func clearSupportsTopicWatchers() { _supportsTopicWatchers = nil }

	var supportsGetPartitionedMetadataWithoutAutoCreation: Bool {
		get { _supportsGetPartitionedMetadataWithoutAutoCreation ?? false }
		set { _supportsGetPartitionedMetadataWithoutAutoCreation = newValue }
	}

	/// Returns true if `supportsGetPartitionedMetadataWithoutAutoCreation` has been explicitly set.
	var hasSupportsGetPartitionedMetadataWithoutAutoCreation: Bool { _supportsGetPartitionedMetadataWithoutAutoCreation != nil }
	/// Clears the value of `supportsGetPartitionedMetadataWithoutAutoCreation`. Subsequent reads from it will return its default value.
	mutating func clearSupportsGetPartitionedMetadataWithoutAutoCreation() { _supportsGetPartitionedMetadataWithoutAutoCreation = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _supportsAuthRefresh: Bool? = nil
	fileprivate var _supportsBrokerEntryMetadata: Bool? = nil
	fileprivate var _supportsPartialProducer: Bool? = nil
	fileprivate var _supportsTopicWatchers: Bool? = nil
	fileprivate var _supportsGetPartitionedMetadataWithoutAutoCreation: Bool? = nil
}

struct Pulsar_Proto_CommandConnected: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var serverVersion: String {
		get { _serverVersion ?? String() }
		set { _serverVersion = newValue }
	}

	/// Returns true if `serverVersion` has been explicitly set.
	var hasServerVersion: Bool { _serverVersion != nil }
	/// Clears the value of `serverVersion`. Subsequent reads from it will return its default value.
	mutating func clearServerVersion() { _serverVersion = nil }

	var protocolVersion: Int32 {
		get { _protocolVersion ?? 0 }
		set { _protocolVersion = newValue }
	}

	/// Returns true if `protocolVersion` has been explicitly set.
	var hasProtocolVersion: Bool { _protocolVersion != nil }
	/// Clears the value of `protocolVersion`. Subsequent reads from it will return its default value.
	mutating func clearProtocolVersion() { _protocolVersion = nil }

	var maxMessageSize: Int32 {
		get { _maxMessageSize ?? 0 }
		set { _maxMessageSize = newValue }
	}

	/// Returns true if `maxMessageSize` has been explicitly set.
	var hasMaxMessageSize: Bool { _maxMessageSize != nil }
	/// Clears the value of `maxMessageSize`. Subsequent reads from it will return its default value.
	mutating func clearMaxMessageSize() { _maxMessageSize = nil }

	var featureFlags: Pulsar_Proto_FeatureFlags {
		get { _featureFlags ?? Pulsar_Proto_FeatureFlags() }
		set { _featureFlags = newValue }
	}

	/// Returns true if `featureFlags` has been explicitly set.
	var hasFeatureFlags: Bool { _featureFlags != nil }
	/// Clears the value of `featureFlags`. Subsequent reads from it will return its default value.
	mutating func clearFeatureFlags() { _featureFlags = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _serverVersion: String? = nil
	fileprivate var _protocolVersion: Int32? = nil
	fileprivate var _maxMessageSize: Int32? = nil
	fileprivate var _featureFlags: Pulsar_Proto_FeatureFlags? = nil
}

struct Pulsar_Proto_CommandAuthResponse: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	/// The version of the client. Proxy should forward client's client_version.
	var clientVersion: String {
		get { _clientVersion ?? String() }
		set { _clientVersion = newValue }
	}

	/// Returns true if `clientVersion` has been explicitly set.
	var hasClientVersion: Bool { _clientVersion != nil }
	/// Clears the value of `clientVersion`. Subsequent reads from it will return its default value.
	mutating func clearClientVersion() { _clientVersion = nil }

	var response: Pulsar_Proto_AuthData {
		get { _response ?? Pulsar_Proto_AuthData() }
		set { _response = newValue }
	}

	/// Returns true if `response` has been explicitly set.
	var hasResponse: Bool { _response != nil }
	/// Clears the value of `response`. Subsequent reads from it will return its default value.
	mutating func clearResponse() { _response = nil }

	var protocolVersion: Int32 {
		get { _protocolVersion ?? 0 }
		set { _protocolVersion = newValue }
	}

	/// Returns true if `protocolVersion` has been explicitly set.
	var hasProtocolVersion: Bool { _protocolVersion != nil }
	/// Clears the value of `protocolVersion`. Subsequent reads from it will return its default value.
	mutating func clearProtocolVersion() { _protocolVersion = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _clientVersion: String? = nil
	fileprivate var _response: Pulsar_Proto_AuthData? = nil
	fileprivate var _protocolVersion: Int32? = nil
}

struct Pulsar_Proto_CommandAuthChallenge: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var serverVersion: String {
		get { _serverVersion ?? String() }
		set { _serverVersion = newValue }
	}

	/// Returns true if `serverVersion` has been explicitly set.
	var hasServerVersion: Bool { _serverVersion != nil }
	/// Clears the value of `serverVersion`. Subsequent reads from it will return its default value.
	mutating func clearServerVersion() { _serverVersion = nil }

	var challenge: Pulsar_Proto_AuthData {
		get { _challenge ?? Pulsar_Proto_AuthData() }
		set { _challenge = newValue }
	}

	/// Returns true if `challenge` has been explicitly set.
	var hasChallenge: Bool { _challenge != nil }
	/// Clears the value of `challenge`. Subsequent reads from it will return its default value.
	mutating func clearChallenge() { _challenge = nil }

	var protocolVersion: Int32 {
		get { _protocolVersion ?? 0 }
		set { _protocolVersion = newValue }
	}

	/// Returns true if `protocolVersion` has been explicitly set.
	var hasProtocolVersion: Bool { _protocolVersion != nil }
	/// Clears the value of `protocolVersion`. Subsequent reads from it will return its default value.
	mutating func clearProtocolVersion() { _protocolVersion = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _serverVersion: String? = nil
	fileprivate var _challenge: Pulsar_Proto_AuthData? = nil
	fileprivate var _protocolVersion: Int32? = nil
}

/// To support mutual authentication type, such as Sasl, reuse this command to mutual auth.
struct Pulsar_Proto_AuthData: @unchecked Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var authMethodName: String {
		get { _authMethodName ?? String() }
		set { _authMethodName = newValue }
	}

	/// Returns true if `authMethodName` has been explicitly set.
	var hasAuthMethodName: Bool { _authMethodName != nil }
	/// Clears the value of `authMethodName`. Subsequent reads from it will return its default value.
	mutating func clearAuthMethodName() { _authMethodName = nil }

	var authData: Data {
		get { _authData ?? Data() }
		set { _authData = newValue }
	}

	/// Returns true if `authData` has been explicitly set.
	var hasAuthData: Bool { _authData != nil }
	/// Clears the value of `authData`. Subsequent reads from it will return its default value.
	mutating func clearAuthData() { _authData = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _authMethodName: String?
	fileprivate var _authData: Data?
}

struct Pulsar_Proto_KeySharedMeta: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var keySharedMode: Pulsar_Proto_KeySharedMode {
		get { _keySharedMode ?? .autoSplit }
		set { _keySharedMode = newValue }
	}

	/// Returns true if `keySharedMode` has been explicitly set.
	var hasKeySharedMode: Bool { _keySharedMode != nil }
	/// Clears the value of `keySharedMode`. Subsequent reads from it will return its default value.
	mutating func clearKeySharedMode() { _keySharedMode = nil }

	var hashRanges: [Pulsar_Proto_IntRange] = []

	var allowOutOfOrderDelivery: Bool {
		get { _allowOutOfOrderDelivery ?? false }
		set { _allowOutOfOrderDelivery = newValue }
	}

	/// Returns true if `allowOutOfOrderDelivery` has been explicitly set.
	var hasAllowOutOfOrderDelivery: Bool { _allowOutOfOrderDelivery != nil }
	/// Clears the value of `allowOutOfOrderDelivery`. Subsequent reads from it will return its default value.
	mutating func clearAllowOutOfOrderDelivery() { _allowOutOfOrderDelivery = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _keySharedMode: Pulsar_Proto_KeySharedMode? = nil
	fileprivate var _allowOutOfOrderDelivery: Bool? = nil
}

struct Pulsar_Proto_CommandSubscribe: @unchecked Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var topic: String {
		get { _storage._topic ?? String() }
		set { _uniqueStorage()._topic = newValue }
	}

	/// Returns true if `topic` has been explicitly set.
	var hasTopic: Bool { _storage._topic != nil }
	/// Clears the value of `topic`. Subsequent reads from it will return its default value.
	mutating func clearTopic() { _uniqueStorage()._topic = nil }

	var subscription: String {
		get { _storage._subscription ?? String() }
		set { _uniqueStorage()._subscription = newValue }
	}

	/// Returns true if `subscription` has been explicitly set.
	var hasSubscription: Bool { _storage._subscription != nil }
	/// Clears the value of `subscription`. Subsequent reads from it will return its default value.
	mutating func clearSubscription() { _uniqueStorage()._subscription = nil }

	var subType: Pulsar_Proto_CommandSubscribe.SubType {
		get { _storage._subType ?? .exclusive }
		set { _uniqueStorage()._subType = newValue }
	}

	/// Returns true if `subType` has been explicitly set.
	var hasSubType: Bool { _storage._subType != nil }
	/// Clears the value of `subType`. Subsequent reads from it will return its default value.
	mutating func clearSubType() { _uniqueStorage()._subType = nil }

	var consumerID: UInt64 {
		get { _storage._consumerID ?? 0 }
		set { _uniqueStorage()._consumerID = newValue }
	}

	/// Returns true if `consumerID` has been explicitly set.
	var hasConsumerID: Bool { _storage._consumerID != nil }
	/// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
	mutating func clearConsumerID() { _uniqueStorage()._consumerID = nil }

	var requestID: UInt64 {
		get { _storage._requestID ?? 0 }
		set { _uniqueStorage()._requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _storage._requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _uniqueStorage()._requestID = nil }

	var consumerName: String {
		get { _storage._consumerName ?? String() }
		set { _uniqueStorage()._consumerName = newValue }
	}

	/// Returns true if `consumerName` has been explicitly set.
	var hasConsumerName: Bool { _storage._consumerName != nil }
	/// Clears the value of `consumerName`. Subsequent reads from it will return its default value.
	mutating func clearConsumerName() { _uniqueStorage()._consumerName = nil }

	var priorityLevel: Int32 {
		get { _storage._priorityLevel ?? 0 }
		set { _uniqueStorage()._priorityLevel = newValue }
	}

	/// Returns true if `priorityLevel` has been explicitly set.
	var hasPriorityLevel: Bool { _storage._priorityLevel != nil }
	/// Clears the value of `priorityLevel`. Subsequent reads from it will return its default value.
	mutating func clearPriorityLevel() { _uniqueStorage()._priorityLevel = nil }

	/// Signal wether the subscription should be backed by a
	/// durable cursor or not
	var durable: Bool {
		get { _storage._durable ?? true }
		set { _uniqueStorage()._durable = newValue }
	}

	/// Returns true if `durable` has been explicitly set.
	var hasDurable: Bool { _storage._durable != nil }
	/// Clears the value of `durable`. Subsequent reads from it will return its default value.
	mutating func clearDurable() { _uniqueStorage()._durable = nil }

	/// If specified, the subscription will position the cursor
	/// markd-delete position  on the particular message id and
	/// will send messages from that point
	var startMessageID: Pulsar_Proto_MessageIDData {
		get { _storage._startMessageID ?? Pulsar_Proto_MessageIDData() }
		set { _uniqueStorage()._startMessageID = newValue }
	}

	/// Returns true if `startMessageID` has been explicitly set.
	var hasStartMessageID: Bool { _storage._startMessageID != nil }
	/// Clears the value of `startMessageID`. Subsequent reads from it will return its default value.
	mutating func clearStartMessageID() { _uniqueStorage()._startMessageID = nil }

	//// Add optional metadata key=value to this consumer
	var metadata: [Pulsar_Proto_KeyValue] {
		get { _storage._metadata }
		set { _uniqueStorage()._metadata = newValue }
	}

	var readCompacted: Bool {
		get { _storage._readCompacted ?? false }
		set { _uniqueStorage()._readCompacted = newValue }
	}

	/// Returns true if `readCompacted` has been explicitly set.
	var hasReadCompacted: Bool { _storage._readCompacted != nil }
	/// Clears the value of `readCompacted`. Subsequent reads from it will return its default value.
	mutating func clearReadCompacted() { _uniqueStorage()._readCompacted = nil }

	var schema: Pulsar_Proto_Schema {
		get { _storage._schema ?? Pulsar_Proto_Schema() }
		set { _uniqueStorage()._schema = newValue }
	}

	/// Returns true if `schema` has been explicitly set.
	var hasSchema: Bool { _storage._schema != nil }
	/// Clears the value of `schema`. Subsequent reads from it will return its default value.
	mutating func clearSchema() { _uniqueStorage()._schema = nil }

	/// Signal whether the subscription will initialize on latest
	/// or not -- earliest
	var initialPosition: Pulsar_Proto_CommandSubscribe.InitialPosition {
		get { _storage._initialPosition ?? .latest }
		set { _uniqueStorage()._initialPosition = newValue }
	}

	/// Returns true if `initialPosition` has been explicitly set.
	var hasInitialPosition: Bool { _storage._initialPosition != nil }
	/// Clears the value of `initialPosition`. Subsequent reads from it will return its default value.
	mutating func clearInitialPosition() { _uniqueStorage()._initialPosition = nil }

	/// Mark the subscription as "replicated". Pulsar will make sure
	/// to periodically sync the state of replicated subscriptions
	/// across different clusters (when using geo-replication).
	var replicateSubscriptionState: Bool {
		get { _storage._replicateSubscriptionState ?? false }
		set { _uniqueStorage()._replicateSubscriptionState = newValue }
	}

	/// Returns true if `replicateSubscriptionState` has been explicitly set.
	var hasReplicateSubscriptionState: Bool { _storage._replicateSubscriptionState != nil }
	/// Clears the value of `replicateSubscriptionState`. Subsequent reads from it will return its default value.
	mutating func clearReplicateSubscriptionState() { _uniqueStorage()._replicateSubscriptionState = nil }

	/// If true, the subscribe operation will cause a topic to be
	/// created if it does not exist already (and if topic auto-creation
	/// is allowed by broker.
	/// If false, the subscribe operation will fail if the topic
	/// does not exist.
	var forceTopicCreation: Bool {
		get { _storage._forceTopicCreation ?? true }
		set { _uniqueStorage()._forceTopicCreation = newValue }
	}

	/// Returns true if `forceTopicCreation` has been explicitly set.
	var hasForceTopicCreation: Bool { _storage._forceTopicCreation != nil }
	/// Clears the value of `forceTopicCreation`. Subsequent reads from it will return its default value.
	mutating func clearForceTopicCreation() { _uniqueStorage()._forceTopicCreation = nil }

	/// If specified, the subscription will reset cursor's position back
	/// to specified seconds and  will send messages from that point
	var startMessageRollbackDurationSec: UInt64 {
		get { _storage._startMessageRollbackDurationSec ?? 0 }
		set { _uniqueStorage()._startMessageRollbackDurationSec = newValue }
	}

	/// Returns true if `startMessageRollbackDurationSec` has been explicitly set.
	var hasStartMessageRollbackDurationSec: Bool { _storage._startMessageRollbackDurationSec != nil }
	/// Clears the value of `startMessageRollbackDurationSec`. Subsequent reads from it will return its default value.
	mutating func clearStartMessageRollbackDurationSec() { _uniqueStorage()._startMessageRollbackDurationSec = nil }

	var keySharedMeta: Pulsar_Proto_KeySharedMeta {
		get { _storage._keySharedMeta ?? Pulsar_Proto_KeySharedMeta() }
		set { _uniqueStorage()._keySharedMeta = newValue }
	}

	/// Returns true if `keySharedMeta` has been explicitly set.
	var hasKeySharedMeta: Bool { _storage._keySharedMeta != nil }
	/// Clears the value of `keySharedMeta`. Subsequent reads from it will return its default value.
	mutating func clearKeySharedMeta() { _uniqueStorage()._keySharedMeta = nil }

	var subscriptionProperties: [Pulsar_Proto_KeyValue] {
		get { _storage._subscriptionProperties }
		set { _uniqueStorage()._subscriptionProperties = newValue }
	}

	/// The consumer epoch, when exclusive and failover consumer redeliver unack message will increase the epoch
	var consumerEpoch: UInt64 {
		get { _storage._consumerEpoch ?? 0 }
		set { _uniqueStorage()._consumerEpoch = newValue }
	}

	/// Returns true if `consumerEpoch` has been explicitly set.
	var hasConsumerEpoch: Bool { _storage._consumerEpoch != nil }
	/// Clears the value of `consumerEpoch`. Subsequent reads from it will return its default value.
	mutating func clearConsumerEpoch() { _uniqueStorage()._consumerEpoch = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	enum SubType: SwiftProtobuf.Enum, Swift.CaseIterable {
		typealias RawValue = Int
		case exclusive // = 0
		case shared // = 1
		case failover // = 2
		case keyShared // = 3

		init() {
			self = .exclusive
		}

		init?(rawValue: Int) {
			switch rawValue {
				case 0: self = .exclusive
				case 1: self = .shared
				case 2: self = .failover
				case 3: self = .keyShared
				default: return nil
			}
		}

		var rawValue: Int {
			switch self {
				case .exclusive: 0
				case .shared: 1
				case .failover: 2
				case .keyShared: 3
			}
		}
	}

	enum InitialPosition: SwiftProtobuf.Enum, Swift.CaseIterable {
		typealias RawValue = Int
		case latest // = 0
		case earliest // = 1

		init() {
			self = .latest
		}

		init?(rawValue: Int) {
			switch rawValue {
				case 0: self = .latest
				case 1: self = .earliest
				default: return nil
			}
		}

		var rawValue: Int {
			switch self {
				case .latest: 0
				case .earliest: 1
			}
		}
	}

	init() { }

	fileprivate var _storage = _StorageClass.defaultInstance
}

struct Pulsar_Proto_CommandPartitionedTopicMetadata: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var topic: String {
		get { _topic ?? String() }
		set { _topic = newValue }
	}

	/// Returns true if `topic` has been explicitly set.
	var hasTopic: Bool { _topic != nil }
	/// Clears the value of `topic`. Subsequent reads from it will return its default value.
	mutating func clearTopic() { _topic = nil }

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	/// TODO - Remove original_principal, original_auth_data, original_auth_method
	/// Original principal that was verified by
	/// a Pulsar proxy.
	var originalPrincipal: String {
		get { _originalPrincipal ?? String() }
		set { _originalPrincipal = newValue }
	}

	/// Returns true if `originalPrincipal` has been explicitly set.
	var hasOriginalPrincipal: Bool { _originalPrincipal != nil }
	/// Clears the value of `originalPrincipal`. Subsequent reads from it will return its default value.
	mutating func clearOriginalPrincipal() { _originalPrincipal = nil }

	/// Original auth role and auth Method that was passed
	/// to the proxy.
	var originalAuthData: String {
		get { _originalAuthData ?? String() }
		set { _originalAuthData = newValue }
	}

	/// Returns true if `originalAuthData` has been explicitly set.
	var hasOriginalAuthData: Bool { _originalAuthData != nil }
	/// Clears the value of `originalAuthData`. Subsequent reads from it will return its default value.
	mutating func clearOriginalAuthData() { _originalAuthData = nil }

	var originalAuthMethod: String {
		get { _originalAuthMethod ?? String() }
		set { _originalAuthMethod = newValue }
	}

	/// Returns true if `originalAuthMethod` has been explicitly set.
	var hasOriginalAuthMethod: Bool { _originalAuthMethod != nil }
	/// Clears the value of `originalAuthMethod`. Subsequent reads from it will return its default value.
	mutating func clearOriginalAuthMethod() { _originalAuthMethod = nil }

	var metadataAutoCreationEnabled: Bool {
		get { _metadataAutoCreationEnabled ?? true }
		set { _metadataAutoCreationEnabled = newValue }
	}

	/// Returns true if `metadataAutoCreationEnabled` has been explicitly set.
	var hasMetadataAutoCreationEnabled: Bool { _metadataAutoCreationEnabled != nil }
	/// Clears the value of `metadataAutoCreationEnabled`. Subsequent reads from it will return its default value.
	mutating func clearMetadataAutoCreationEnabled() { _metadataAutoCreationEnabled = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _topic: String? = nil
	fileprivate var _requestID: UInt64? = nil
	fileprivate var _originalPrincipal: String? = nil
	fileprivate var _originalAuthData: String? = nil
	fileprivate var _originalAuthMethod: String? = nil
	fileprivate var _metadataAutoCreationEnabled: Bool? = nil
}

struct Pulsar_Proto_CommandPartitionedTopicMetadataResponse: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	/// Optional in case of error
	var partitions: UInt32 {
		get { _partitions ?? 0 }
		set { _partitions = newValue }
	}

	/// Returns true if `partitions` has been explicitly set.
	var hasPartitions: Bool { _partitions != nil }
	/// Clears the value of `partitions`. Subsequent reads from it will return its default value.
	mutating func clearPartitions() { _partitions = nil }

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var response: Pulsar_Proto_CommandPartitionedTopicMetadataResponse.LookupType {
		get { _response ?? .success }
		set { _response = newValue }
	}

	/// Returns true if `response` has been explicitly set.
	var hasResponse: Bool { _response != nil }
	/// Clears the value of `response`. Subsequent reads from it will return its default value.
	mutating func clearResponse() { _response = nil }

	var error: Pulsar_Proto_ServerError {
		get { _error ?? .unknownError }
		set { _error = newValue }
	}

	/// Returns true if `error` has been explicitly set.
	var hasError: Bool { _error != nil }
	/// Clears the value of `error`. Subsequent reads from it will return its default value.
	mutating func clearError() { _error = nil }

	var message: String {
		get { _message ?? String() }
		set { _message = newValue }
	}

	/// Returns true if `message` has been explicitly set.
	var hasMessage: Bool { _message != nil }
	/// Clears the value of `message`. Subsequent reads from it will return its default value.
	mutating func clearMessage() { _message = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	enum LookupType: SwiftProtobuf.Enum, Swift.CaseIterable {
		typealias RawValue = Int
		case success // = 0
		case failed // = 1

		init() {
			self = .success
		}

		init?(rawValue: Int) {
			switch rawValue {
				case 0: self = .success
				case 1: self = .failed
				default: return nil
			}
		}

		var rawValue: Int {
			switch self {
				case .success: 0
				case .failed: 1
			}
		}
	}

	init() { }

	fileprivate var _partitions: UInt32? = nil
	fileprivate var _requestID: UInt64? = nil
	fileprivate var _response: Pulsar_Proto_CommandPartitionedTopicMetadataResponse.LookupType? = nil
	fileprivate var _error: Pulsar_Proto_ServerError? = nil
	fileprivate var _message: String? = nil
}

struct Pulsar_Proto_CommandLookupTopic: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var topic: String {
		get { _topic ?? String() }
		set { _topic = newValue }
	}

	/// Returns true if `topic` has been explicitly set.
	var hasTopic: Bool { _topic != nil }
	/// Clears the value of `topic`. Subsequent reads from it will return its default value.
	mutating func clearTopic() { _topic = nil }

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var authoritative: Bool {
		get { _authoritative ?? false }
		set { _authoritative = newValue }
	}

	/// Returns true if `authoritative` has been explicitly set.
	var hasAuthoritative: Bool { _authoritative != nil }
	/// Clears the value of `authoritative`. Subsequent reads from it will return its default value.
	mutating func clearAuthoritative() { _authoritative = nil }

	/// TODO - Remove original_principal, original_auth_data, original_auth_method
	/// Original principal that was verified by
	/// a Pulsar proxy.
	var originalPrincipal: String {
		get { _originalPrincipal ?? String() }
		set { _originalPrincipal = newValue }
	}

	/// Returns true if `originalPrincipal` has been explicitly set.
	var hasOriginalPrincipal: Bool { _originalPrincipal != nil }
	/// Clears the value of `originalPrincipal`. Subsequent reads from it will return its default value.
	mutating func clearOriginalPrincipal() { _originalPrincipal = nil }

	/// Original auth role and auth Method that was passed
	/// to the proxy.
	var originalAuthData: String {
		get { _originalAuthData ?? String() }
		set { _originalAuthData = newValue }
	}

	/// Returns true if `originalAuthData` has been explicitly set.
	var hasOriginalAuthData: Bool { _originalAuthData != nil }
	/// Clears the value of `originalAuthData`. Subsequent reads from it will return its default value.
	mutating func clearOriginalAuthData() { _originalAuthData = nil }

	var originalAuthMethod: String {
		get { _originalAuthMethod ?? String() }
		set { _originalAuthMethod = newValue }
	}

	/// Returns true if `originalAuthMethod` has been explicitly set.
	var hasOriginalAuthMethod: Bool { _originalAuthMethod != nil }
	/// Clears the value of `originalAuthMethod`. Subsequent reads from it will return its default value.
	mutating func clearOriginalAuthMethod() { _originalAuthMethod = nil }

	var advertisedListenerName: String {
		get { _advertisedListenerName ?? String() }
		set { _advertisedListenerName = newValue }
	}

	/// Returns true if `advertisedListenerName` has been explicitly set.
	var hasAdvertisedListenerName: Bool { _advertisedListenerName != nil }
	/// Clears the value of `advertisedListenerName`. Subsequent reads from it will return its default value.
	mutating func clearAdvertisedListenerName() { _advertisedListenerName = nil }

	/// The properties used for topic lookup
	var properties: [Pulsar_Proto_KeyValue] = []

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _topic: String? = nil
	fileprivate var _requestID: UInt64? = nil
	fileprivate var _authoritative: Bool? = nil
	fileprivate var _originalPrincipal: String? = nil
	fileprivate var _originalAuthData: String? = nil
	fileprivate var _originalAuthMethod: String? = nil
	fileprivate var _advertisedListenerName: String? = nil
}

struct Pulsar_Proto_CommandLookupTopicResponse: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	/// Optional in case of error
	var brokerServiceURL: String {
		get { _brokerServiceURL ?? String() }
		set { _brokerServiceURL = newValue }
	}

	/// Returns true if `brokerServiceURL` has been explicitly set.
	var hasBrokerServiceURL: Bool { _brokerServiceURL != nil }
	/// Clears the value of `brokerServiceURL`. Subsequent reads from it will return its default value.
	mutating func clearBrokerServiceURL() { _brokerServiceURL = nil }

	var brokerServiceURLTls: String {
		get { _brokerServiceURLTls ?? String() }
		set { _brokerServiceURLTls = newValue }
	}

	/// Returns true if `brokerServiceURLTls` has been explicitly set.
	var hasBrokerServiceURLTls: Bool { _brokerServiceURLTls != nil }
	/// Clears the value of `brokerServiceURLTls`. Subsequent reads from it will return its default value.
	mutating func clearBrokerServiceURLTls() { _brokerServiceURLTls = nil }

	var response: Pulsar_Proto_CommandLookupTopicResponse.LookupType {
		get { _response ?? .redirect }
		set { _response = newValue }
	}

	/// Returns true if `response` has been explicitly set.
	var hasResponse: Bool { _response != nil }
	/// Clears the value of `response`. Subsequent reads from it will return its default value.
	mutating func clearResponse() { _response = nil }

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var authoritative: Bool {
		get { _authoritative ?? false }
		set { _authoritative = newValue }
	}

	/// Returns true if `authoritative` has been explicitly set.
	var hasAuthoritative: Bool { _authoritative != nil }
	/// Clears the value of `authoritative`. Subsequent reads from it will return its default value.
	mutating func clearAuthoritative() { _authoritative = nil }

	var error: Pulsar_Proto_ServerError {
		get { _error ?? .unknownError }
		set { _error = newValue }
	}

	/// Returns true if `error` has been explicitly set.
	var hasError: Bool { _error != nil }
	/// Clears the value of `error`. Subsequent reads from it will return its default value.
	mutating func clearError() { _error = nil }

	var message: String {
		get { _message ?? String() }
		set { _message = newValue }
	}

	/// Returns true if `message` has been explicitly set.
	var hasMessage: Bool { _message != nil }
	/// Clears the value of `message`. Subsequent reads from it will return its default value.
	mutating func clearMessage() { _message = nil }

	/// If it's true, indicates to the client that it must
	/// always connect through the service url after the
	/// lookup has been completed.
	var proxyThroughServiceURL: Bool {
		get { _proxyThroughServiceURL ?? false }
		set { _proxyThroughServiceURL = newValue }
	}

	/// Returns true if `proxyThroughServiceURL` has been explicitly set.
	var hasProxyThroughServiceURL: Bool { _proxyThroughServiceURL != nil }
	/// Clears the value of `proxyThroughServiceURL`. Subsequent reads from it will return its default value.
	mutating func clearProxyThroughServiceURL() { _proxyThroughServiceURL = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	enum LookupType: SwiftProtobuf.Enum, Swift.CaseIterable {
		typealias RawValue = Int
		case redirect // = 0
		case connect // = 1
		case failed // = 2

		init() {
			self = .redirect
		}

		init?(rawValue: Int) {
			switch rawValue {
				case 0: self = .redirect
				case 1: self = .connect
				case 2: self = .failed
				default: return nil
			}
		}

		var rawValue: Int {
			switch self {
				case .redirect: 0
				case .connect: 1
				case .failed: 2
			}
		}
	}

	init() { }

	fileprivate var _brokerServiceURL: String? = nil
	fileprivate var _brokerServiceURLTls: String? = nil
	fileprivate var _response: Pulsar_Proto_CommandLookupTopicResponse.LookupType? = nil
	fileprivate var _requestID: UInt64? = nil
	fileprivate var _authoritative: Bool? = nil
	fileprivate var _error: Pulsar_Proto_ServerError? = nil
	fileprivate var _message: String? = nil
	fileprivate var _proxyThroughServiceURL: Bool? = nil
}

//// Create a new Producer on a topic, assigning the given producer_id,
//// all messages sent with this producer_id will be persisted on the topic
struct Pulsar_Proto_CommandProducer: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var topic: String {
		get { _topic ?? String() }
		set { _topic = newValue }
	}

	/// Returns true if `topic` has been explicitly set.
	var hasTopic: Bool { _topic != nil }
	/// Clears the value of `topic`. Subsequent reads from it will return its default value.
	mutating func clearTopic() { _topic = nil }

	var producerID: UInt64 {
		get { _producerID ?? 0 }
		set { _producerID = newValue }
	}

	/// Returns true if `producerID` has been explicitly set.
	var hasProducerID: Bool { _producerID != nil }
	/// Clears the value of `producerID`. Subsequent reads from it will return its default value.
	mutating func clearProducerID() { _producerID = nil }

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	//// If a producer name is specified, the name will be used,
	//// otherwise the broker will generate a unique name
	var producerName: String {
		get { _producerName ?? String() }
		set { _producerName = newValue }
	}

	/// Returns true if `producerName` has been explicitly set.
	var hasProducerName: Bool { _producerName != nil }
	/// Clears the value of `producerName`. Subsequent reads from it will return its default value.
	mutating func clearProducerName() { _producerName = nil }

	var encrypted: Bool {
		get { _encrypted ?? false }
		set { _encrypted = newValue }
	}

	/// Returns true if `encrypted` has been explicitly set.
	var hasEncrypted: Bool { _encrypted != nil }
	/// Clears the value of `encrypted`. Subsequent reads from it will return its default value.
	mutating func clearEncrypted() { _encrypted = nil }

	//// Add optional metadata key=value to this producer
	var metadata: [Pulsar_Proto_KeyValue] = []

	var schema: Pulsar_Proto_Schema {
		get { _schema ?? Pulsar_Proto_Schema() }
		set { _schema = newValue }
	}

	/// Returns true if `schema` has been explicitly set.
	var hasSchema: Bool { _schema != nil }
	/// Clears the value of `schema`. Subsequent reads from it will return its default value.
	mutating func clearSchema() { _schema = nil }

	/// If producer reconnect to broker, the epoch of this producer will +1
	var epoch: UInt64 {
		get { _epoch ?? 0 }
		set { _epoch = newValue }
	}

	/// Returns true if `epoch` has been explicitly set.
	var hasEpoch: Bool { _epoch != nil }
	/// Clears the value of `epoch`. Subsequent reads from it will return its default value.
	mutating func clearEpoch() { _epoch = nil }

	/// Indicate the name of the producer is generated or user provided
	/// Use default true here is in order to be forward compatible with the client
	var userProvidedProducerName: Bool {
		get { _userProvidedProducerName ?? true }
		set { _userProvidedProducerName = newValue }
	}

	/// Returns true if `userProvidedProducerName` has been explicitly set.
	var hasUserProvidedProducerName: Bool { _userProvidedProducerName != nil }
	/// Clears the value of `userProvidedProducerName`. Subsequent reads from it will return its default value.
	mutating func clearUserProvidedProducerName() { _userProvidedProducerName = nil }

	/// Require that this producers will be the only producer allowed on the topic
	var producerAccessMode: Pulsar_Proto_ProducerAccessMode {
		get { _producerAccessMode ?? .shared }
		set { _producerAccessMode = newValue }
	}

	/// Returns true if `producerAccessMode` has been explicitly set.
	var hasProducerAccessMode: Bool { _producerAccessMode != nil }
	/// Clears the value of `producerAccessMode`. Subsequent reads from it will return its default value.
	mutating func clearProducerAccessMode() { _producerAccessMode = nil }

	/// Topic epoch is used to fence off producers that reconnects after a new
	/// exclusive producer has already taken over. This id is assigned by the
	/// broker on the CommandProducerSuccess. The first time, the client will
	/// leave it empty and then it will always carry the same epoch number on
	/// the subsequent reconnections.
	var topicEpoch: UInt64 {
		get { _topicEpoch ?? 0 }
		set { _topicEpoch = newValue }
	}

	/// Returns true if `topicEpoch` has been explicitly set.
	var hasTopicEpoch: Bool { _topicEpoch != nil }
	/// Clears the value of `topicEpoch`. Subsequent reads from it will return its default value.
	mutating func clearTopicEpoch() { _topicEpoch = nil }

	var txnEnabled: Bool {
		get { _txnEnabled ?? false }
		set { _txnEnabled = newValue }
	}

	/// Returns true if `txnEnabled` has been explicitly set.
	var hasTxnEnabled: Bool { _txnEnabled != nil }
	/// Clears the value of `txnEnabled`. Subsequent reads from it will return its default value.
	mutating func clearTxnEnabled() { _txnEnabled = nil }

	/// Name of the initial subscription of the topic.
	/// If this field is not set, the initial subscription will not be created.
	/// If this field is set but the broker's `allowAutoSubscriptionCreation`
	/// is disabled, the producer will fail to be created.
	var initialSubscriptionName: String {
		get { _initialSubscriptionName ?? String() }
		set { _initialSubscriptionName = newValue }
	}

	/// Returns true if `initialSubscriptionName` has been explicitly set.
	var hasInitialSubscriptionName: Bool { _initialSubscriptionName != nil }
	/// Clears the value of `initialSubscriptionName`. Subsequent reads from it will return its default value.
	mutating func clearInitialSubscriptionName() { _initialSubscriptionName = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _topic: String? = nil
	fileprivate var _producerID: UInt64? = nil
	fileprivate var _requestID: UInt64? = nil
	fileprivate var _producerName: String? = nil
	fileprivate var _encrypted: Bool? = nil
	fileprivate var _schema: Pulsar_Proto_Schema? = nil
	fileprivate var _epoch: UInt64? = nil
	fileprivate var _userProvidedProducerName: Bool? = nil
	fileprivate var _producerAccessMode: Pulsar_Proto_ProducerAccessMode? = nil
	fileprivate var _topicEpoch: UInt64? = nil
	fileprivate var _txnEnabled: Bool? = nil
	fileprivate var _initialSubscriptionName: String? = nil
}

struct Pulsar_Proto_CommandSend: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var producerID: UInt64 {
		get { _producerID ?? 0 }
		set { _producerID = newValue }
	}

	/// Returns true if `producerID` has been explicitly set.
	var hasProducerID: Bool { _producerID != nil }
	/// Clears the value of `producerID`. Subsequent reads from it will return its default value.
	mutating func clearProducerID() { _producerID = nil }

	var sequenceID: UInt64 {
		get { _sequenceID ?? 0 }
		set { _sequenceID = newValue }
	}

	/// Returns true if `sequenceID` has been explicitly set.
	var hasSequenceID: Bool { _sequenceID != nil }
	/// Clears the value of `sequenceID`. Subsequent reads from it will return its default value.
	mutating func clearSequenceID() { _sequenceID = nil }

	var numMessages: Int32 {
		get { _numMessages ?? 1 }
		set { _numMessages = newValue }
	}

	/// Returns true if `numMessages` has been explicitly set.
	var hasNumMessages: Bool { _numMessages != nil }
	/// Clears the value of `numMessages`. Subsequent reads from it will return its default value.
	mutating func clearNumMessages() { _numMessages = nil }

	var txnidLeastBits: UInt64 {
		get { _txnidLeastBits ?? 0 }
		set { _txnidLeastBits = newValue }
	}

	/// Returns true if `txnidLeastBits` has been explicitly set.
	var hasTxnidLeastBits: Bool { _txnidLeastBits != nil }
	/// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidLeastBits() { _txnidLeastBits = nil }

	var txnidMostBits: UInt64 {
		get { _txnidMostBits ?? 0 }
		set { _txnidMostBits = newValue }
	}

	/// Returns true if `txnidMostBits` has been explicitly set.
	var hasTxnidMostBits: Bool { _txnidMostBits != nil }
	/// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidMostBits() { _txnidMostBits = nil }

	//// Add highest sequence id to support batch message with external sequence id
	var highestSequenceID: UInt64 {
		get { _highestSequenceID ?? 0 }
		set { _highestSequenceID = newValue }
	}

	/// Returns true if `highestSequenceID` has been explicitly set.
	var hasHighestSequenceID: Bool { _highestSequenceID != nil }
	/// Clears the value of `highestSequenceID`. Subsequent reads from it will return its default value.
	mutating func clearHighestSequenceID() { _highestSequenceID = nil }

	var isChunk: Bool {
		get { _isChunk ?? false }
		set { _isChunk = newValue }
	}

	/// Returns true if `isChunk` has been explicitly set.
	var hasIsChunk: Bool { _isChunk != nil }
	/// Clears the value of `isChunk`. Subsequent reads from it will return its default value.
	mutating func clearIsChunk() { _isChunk = nil }

	/// Specify if the message being published is a Pulsar marker or not
	var marker: Bool {
		get { _marker ?? false }
		set { _marker = newValue }
	}

	/// Returns true if `marker` has been explicitly set.
	var hasMarker: Bool { _marker != nil }
	/// Clears the value of `marker`. Subsequent reads from it will return its default value.
	mutating func clearMarker() { _marker = nil }

	/// Message id of this message, currently is used in replicator for shadow topic.
	var messageID: Pulsar_Proto_MessageIDData {
		get { _messageID ?? Pulsar_Proto_MessageIDData() }
		set { _messageID = newValue }
	}

	/// Returns true if `messageID` has been explicitly set.
	var hasMessageID: Bool { _messageID != nil }
	/// Clears the value of `messageID`. Subsequent reads from it will return its default value.
	mutating func clearMessageID() { _messageID = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _producerID: UInt64? = nil
	fileprivate var _sequenceID: UInt64? = nil
	fileprivate var _numMessages: Int32? = nil
	fileprivate var _txnidLeastBits: UInt64? = nil
	fileprivate var _txnidMostBits: UInt64? = nil
	fileprivate var _highestSequenceID: UInt64? = nil
	fileprivate var _isChunk: Bool? = nil
	fileprivate var _marker: Bool? = nil
	fileprivate var _messageID: Pulsar_Proto_MessageIDData? = nil
}

struct Pulsar_Proto_CommandSendReceipt: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var producerID: UInt64 {
		get { _producerID ?? 0 }
		set { _producerID = newValue }
	}

	/// Returns true if `producerID` has been explicitly set.
	var hasProducerID: Bool { _producerID != nil }
	/// Clears the value of `producerID`. Subsequent reads from it will return its default value.
	mutating func clearProducerID() { _producerID = nil }

	var sequenceID: UInt64 {
		get { _sequenceID ?? 0 }
		set { _sequenceID = newValue }
	}

	/// Returns true if `sequenceID` has been explicitly set.
	var hasSequenceID: Bool { _sequenceID != nil }
	/// Clears the value of `sequenceID`. Subsequent reads from it will return its default value.
	mutating func clearSequenceID() { _sequenceID = nil }

	var messageID: Pulsar_Proto_MessageIDData {
		get { _messageID ?? Pulsar_Proto_MessageIDData() }
		set { _messageID = newValue }
	}

	/// Returns true if `messageID` has been explicitly set.
	var hasMessageID: Bool { _messageID != nil }
	/// Clears the value of `messageID`. Subsequent reads from it will return its default value.
	mutating func clearMessageID() { _messageID = nil }

	var highestSequenceID: UInt64 {
		get { _highestSequenceID ?? 0 }
		set { _highestSequenceID = newValue }
	}

	/// Returns true if `highestSequenceID` has been explicitly set.
	var hasHighestSequenceID: Bool { _highestSequenceID != nil }
	/// Clears the value of `highestSequenceID`. Subsequent reads from it will return its default value.
	mutating func clearHighestSequenceID() { _highestSequenceID = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _producerID: UInt64? = nil
	fileprivate var _sequenceID: UInt64? = nil
	fileprivate var _messageID: Pulsar_Proto_MessageIDData? = nil
	fileprivate var _highestSequenceID: UInt64? = nil
}

struct Pulsar_Proto_CommandSendError: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var producerID: UInt64 {
		get { _producerID ?? 0 }
		set { _producerID = newValue }
	}

	/// Returns true if `producerID` has been explicitly set.
	var hasProducerID: Bool { _producerID != nil }
	/// Clears the value of `producerID`. Subsequent reads from it will return its default value.
	mutating func clearProducerID() { _producerID = nil }

	var sequenceID: UInt64 {
		get { _sequenceID ?? 0 }
		set { _sequenceID = newValue }
	}

	/// Returns true if `sequenceID` has been explicitly set.
	var hasSequenceID: Bool { _sequenceID != nil }
	/// Clears the value of `sequenceID`. Subsequent reads from it will return its default value.
	mutating func clearSequenceID() { _sequenceID = nil }

	var error: Pulsar_Proto_ServerError {
		get { _error ?? .unknownError }
		set { _error = newValue }
	}

	/// Returns true if `error` has been explicitly set.
	var hasError: Bool { _error != nil }
	/// Clears the value of `error`. Subsequent reads from it will return its default value.
	mutating func clearError() { _error = nil }

	var message: String {
		get { _message ?? String() }
		set { _message = newValue }
	}

	/// Returns true if `message` has been explicitly set.
	var hasMessage: Bool { _message != nil }
	/// Clears the value of `message`. Subsequent reads from it will return its default value.
	mutating func clearMessage() { _message = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _producerID: UInt64? = nil
	fileprivate var _sequenceID: UInt64? = nil
	fileprivate var _error: Pulsar_Proto_ServerError? = nil
	fileprivate var _message: String? = nil
}

struct Pulsar_Proto_CommandMessage: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var consumerID: UInt64 {
		get { _consumerID ?? 0 }
		set { _consumerID = newValue }
	}

	/// Returns true if `consumerID` has been explicitly set.
	var hasConsumerID: Bool { _consumerID != nil }
	/// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
	mutating func clearConsumerID() { _consumerID = nil }

	var messageID: Pulsar_Proto_MessageIDData {
		get { _messageID ?? Pulsar_Proto_MessageIDData() }
		set { _messageID = newValue }
	}

	/// Returns true if `messageID` has been explicitly set.
	var hasMessageID: Bool { _messageID != nil }
	/// Clears the value of `messageID`. Subsequent reads from it will return its default value.
	mutating func clearMessageID() { _messageID = nil }

	var redeliveryCount: UInt32 {
		get { _redeliveryCount ?? 0 }
		set { _redeliveryCount = newValue }
	}

	/// Returns true if `redeliveryCount` has been explicitly set.
	var hasRedeliveryCount: Bool { _redeliveryCount != nil }
	/// Clears the value of `redeliveryCount`. Subsequent reads from it will return its default value.
	mutating func clearRedeliveryCount() { _redeliveryCount = nil }

	var ackSet: [Int64] = []

	var consumerEpoch: UInt64 {
		get { _consumerEpoch ?? 0 }
		set { _consumerEpoch = newValue }
	}

	/// Returns true if `consumerEpoch` has been explicitly set.
	var hasConsumerEpoch: Bool { _consumerEpoch != nil }
	/// Clears the value of `consumerEpoch`. Subsequent reads from it will return its default value.
	mutating func clearConsumerEpoch() { _consumerEpoch = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _consumerID: UInt64? = nil
	fileprivate var _messageID: Pulsar_Proto_MessageIDData? = nil
	fileprivate var _redeliveryCount: UInt32? = nil
	fileprivate var _consumerEpoch: UInt64? = nil
}

struct Pulsar_Proto_CommandAck: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var consumerID: UInt64 {
		get { _consumerID ?? 0 }
		set { _consumerID = newValue }
	}

	/// Returns true if `consumerID` has been explicitly set.
	var hasConsumerID: Bool { _consumerID != nil }
	/// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
	mutating func clearConsumerID() { _consumerID = nil }

	var ackType: Pulsar_Proto_CommandAck.AckType {
		get { _ackType ?? .individual }
		set { _ackType = newValue }
	}

	/// Returns true if `ackType` has been explicitly set.
	var hasAckType: Bool { _ackType != nil }
	/// Clears the value of `ackType`. Subsequent reads from it will return its default value.
	mutating func clearAckType() { _ackType = nil }

	/// In case of individual acks, the client can pass a list of message ids
	var messageID: [Pulsar_Proto_MessageIDData] = []

	var validationError: Pulsar_Proto_CommandAck.ValidationError {
		get { _validationError ?? .uncompressedSizeCorruption }
		set { _validationError = newValue }
	}

	/// Returns true if `validationError` has been explicitly set.
	var hasValidationError: Bool { _validationError != nil }
	/// Clears the value of `validationError`. Subsequent reads from it will return its default value.
	mutating func clearValidationError() { _validationError = nil }

	var properties: [Pulsar_Proto_KeyLongValue] = []

	var txnidLeastBits: UInt64 {
		get { _txnidLeastBits ?? 0 }
		set { _txnidLeastBits = newValue }
	}

	/// Returns true if `txnidLeastBits` has been explicitly set.
	var hasTxnidLeastBits: Bool { _txnidLeastBits != nil }
	/// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidLeastBits() { _txnidLeastBits = nil }

	var txnidMostBits: UInt64 {
		get { _txnidMostBits ?? 0 }
		set { _txnidMostBits = newValue }
	}

	/// Returns true if `txnidMostBits` has been explicitly set.
	var hasTxnidMostBits: Bool { _txnidMostBits != nil }
	/// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidMostBits() { _txnidMostBits = nil }

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	enum AckType: SwiftProtobuf.Enum, Swift.CaseIterable {
		typealias RawValue = Int
		case individual // = 0
		case cumulative // = 1

		init() {
			self = .individual
		}

		init?(rawValue: Int) {
			switch rawValue {
				case 0: self = .individual
				case 1: self = .cumulative
				default: return nil
			}
		}

		var rawValue: Int {
			switch self {
				case .individual: 0
				case .cumulative: 1
			}
		}
	}

	/// Acks can contain a flag to indicate the consumer
	/// received an invalid message that got discarded
	/// before being passed on to the application.
	enum ValidationError: SwiftProtobuf.Enum, Swift.CaseIterable {
		typealias RawValue = Int
		case uncompressedSizeCorruption // = 0
		case decompressionError // = 1
		case checksumMismatch // = 2
		case batchDeSerializeError // = 3
		case decryptionError // = 4

		init() {
			self = .uncompressedSizeCorruption
		}

		init?(rawValue: Int) {
			switch rawValue {
				case 0: self = .uncompressedSizeCorruption
				case 1: self = .decompressionError
				case 2: self = .checksumMismatch
				case 3: self = .batchDeSerializeError
				case 4: self = .decryptionError
				default: return nil
			}
		}

		var rawValue: Int {
			switch self {
				case .uncompressedSizeCorruption: 0
				case .decompressionError: 1
				case .checksumMismatch: 2
				case .batchDeSerializeError: 3
				case .decryptionError: 4
			}
		}
	}

	init() { }

	fileprivate var _consumerID: UInt64? = nil
	fileprivate var _ackType: Pulsar_Proto_CommandAck.AckType? = nil
	fileprivate var _validationError: Pulsar_Proto_CommandAck.ValidationError? = nil
	fileprivate var _txnidLeastBits: UInt64? = nil
	fileprivate var _txnidMostBits: UInt64? = nil
	fileprivate var _requestID: UInt64? = nil
}

struct Pulsar_Proto_CommandAckResponse: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var consumerID: UInt64 {
		get { _consumerID ?? 0 }
		set { _consumerID = newValue }
	}

	/// Returns true if `consumerID` has been explicitly set.
	var hasConsumerID: Bool { _consumerID != nil }
	/// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
	mutating func clearConsumerID() { _consumerID = nil }

	var txnidLeastBits: UInt64 {
		get { _txnidLeastBits ?? 0 }
		set { _txnidLeastBits = newValue }
	}

	/// Returns true if `txnidLeastBits` has been explicitly set.
	var hasTxnidLeastBits: Bool { _txnidLeastBits != nil }
	/// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidLeastBits() { _txnidLeastBits = nil }

	var txnidMostBits: UInt64 {
		get { _txnidMostBits ?? 0 }
		set { _txnidMostBits = newValue }
	}

	/// Returns true if `txnidMostBits` has been explicitly set.
	var hasTxnidMostBits: Bool { _txnidMostBits != nil }
	/// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidMostBits() { _txnidMostBits = nil }

	var error: Pulsar_Proto_ServerError {
		get { _error ?? .unknownError }
		set { _error = newValue }
	}

	/// Returns true if `error` has been explicitly set.
	var hasError: Bool { _error != nil }
	/// Clears the value of `error`. Subsequent reads from it will return its default value.
	mutating func clearError() { _error = nil }

	var message: String {
		get { _message ?? String() }
		set { _message = newValue }
	}

	/// Returns true if `message` has been explicitly set.
	var hasMessage: Bool { _message != nil }
	/// Clears the value of `message`. Subsequent reads from it will return its default value.
	mutating func clearMessage() { _message = nil }

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _consumerID: UInt64? = nil
	fileprivate var _txnidLeastBits: UInt64? = nil
	fileprivate var _txnidMostBits: UInt64? = nil
	fileprivate var _error: Pulsar_Proto_ServerError? = nil
	fileprivate var _message: String? = nil
	fileprivate var _requestID: UInt64? = nil
}

/// changes on active consumer
struct Pulsar_Proto_CommandActiveConsumerChange: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var consumerID: UInt64 {
		get { _consumerID ?? 0 }
		set { _consumerID = newValue }
	}

	/// Returns true if `consumerID` has been explicitly set.
	var hasConsumerID: Bool { _consumerID != nil }
	/// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
	mutating func clearConsumerID() { _consumerID = nil }

	var isActive: Bool {
		get { _isActive ?? false }
		set { _isActive = newValue }
	}

	/// Returns true if `isActive` has been explicitly set.
	var hasIsActive: Bool { _isActive != nil }
	/// Clears the value of `isActive`. Subsequent reads from it will return its default value.
	mutating func clearIsActive() { _isActive = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _consumerID: UInt64? = nil
	fileprivate var _isActive: Bool? = nil
}

struct Pulsar_Proto_CommandFlow: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var consumerID: UInt64 {
		get { _consumerID ?? 0 }
		set { _consumerID = newValue }
	}

	/// Returns true if `consumerID` has been explicitly set.
	var hasConsumerID: Bool { _consumerID != nil }
	/// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
	mutating func clearConsumerID() { _consumerID = nil }

	/// Max number of messages to prefetch, in addition
	/// of any number previously specified
	var messagePermits: UInt32 {
		get { _messagePermits ?? 0 }
		set { _messagePermits = newValue }
	}

	/// Returns true if `messagePermits` has been explicitly set.
	var hasMessagePermits: Bool { _messagePermits != nil }
	/// Clears the value of `messagePermits`. Subsequent reads from it will return its default value.
	mutating func clearMessagePermits() { _messagePermits = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _consumerID: UInt64? = nil
	fileprivate var _messagePermits: UInt32? = nil
}

struct Pulsar_Proto_CommandUnsubscribe: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var consumerID: UInt64 {
		get { _consumerID ?? 0 }
		set { _consumerID = newValue }
	}

	/// Returns true if `consumerID` has been explicitly set.
	var hasConsumerID: Bool { _consumerID != nil }
	/// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
	mutating func clearConsumerID() { _consumerID = nil }

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var force: Bool {
		get { _force ?? false }
		set { _force = newValue }
	}

	/// Returns true if `force` has been explicitly set.
	var hasForce: Bool { _force != nil }
	/// Clears the value of `force`. Subsequent reads from it will return its default value.
	mutating func clearForce() { _force = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _consumerID: UInt64? = nil
	fileprivate var _requestID: UInt64? = nil
	fileprivate var _force: Bool? = nil
}

/// Reset an existing consumer to a particular message id
struct Pulsar_Proto_CommandSeek: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var consumerID: UInt64 {
		get { _consumerID ?? 0 }
		set { _consumerID = newValue }
	}

	/// Returns true if `consumerID` has been explicitly set.
	var hasConsumerID: Bool { _consumerID != nil }
	/// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
	mutating func clearConsumerID() { _consumerID = nil }

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var messageID: Pulsar_Proto_MessageIDData {
		get { _messageID ?? Pulsar_Proto_MessageIDData() }
		set { _messageID = newValue }
	}

	/// Returns true if `messageID` has been explicitly set.
	var hasMessageID: Bool { _messageID != nil }
	/// Clears the value of `messageID`. Subsequent reads from it will return its default value.
	mutating func clearMessageID() { _messageID = nil }

	var messagePublishTime: UInt64 {
		get { _messagePublishTime ?? 0 }
		set { _messagePublishTime = newValue }
	}

	/// Returns true if `messagePublishTime` has been explicitly set.
	var hasMessagePublishTime: Bool { _messagePublishTime != nil }
	/// Clears the value of `messagePublishTime`. Subsequent reads from it will return its default value.
	mutating func clearMessagePublishTime() { _messagePublishTime = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _consumerID: UInt64? = nil
	fileprivate var _requestID: UInt64? = nil
	fileprivate var _messageID: Pulsar_Proto_MessageIDData? = nil
	fileprivate var _messagePublishTime: UInt64? = nil
}

/// Message sent by broker to client when a topic
/// has been forcefully terminated and there are no more
/// messages left to consume
struct Pulsar_Proto_CommandReachedEndOfTopic: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var consumerID: UInt64 {
		get { _consumerID ?? 0 }
		set { _consumerID = newValue }
	}

	/// Returns true if `consumerID` has been explicitly set.
	var hasConsumerID: Bool { _consumerID != nil }
	/// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
	mutating func clearConsumerID() { _consumerID = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _consumerID: UInt64? = nil
}

struct Pulsar_Proto_CommandTopicMigrated: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var resourceID: UInt64 {
		get { _resourceID ?? 0 }
		set { _resourceID = newValue }
	}

	/// Returns true if `resourceID` has been explicitly set.
	var hasResourceID: Bool { _resourceID != nil }
	/// Clears the value of `resourceID`. Subsequent reads from it will return its default value.
	mutating func clearResourceID() { _resourceID = nil }

	var resourceType: Pulsar_Proto_CommandTopicMigrated.ResourceType {
		get { _resourceType ?? .producer }
		set { _resourceType = newValue }
	}

	/// Returns true if `resourceType` has been explicitly set.
	var hasResourceType: Bool { _resourceType != nil }
	/// Clears the value of `resourceType`. Subsequent reads from it will return its default value.
	mutating func clearResourceType() { _resourceType = nil }

	var brokerServiceURL: String {
		get { _brokerServiceURL ?? String() }
		set { _brokerServiceURL = newValue }
	}

	/// Returns true if `brokerServiceURL` has been explicitly set.
	var hasBrokerServiceURL: Bool { _brokerServiceURL != nil }
	/// Clears the value of `brokerServiceURL`. Subsequent reads from it will return its default value.
	mutating func clearBrokerServiceURL() { _brokerServiceURL = nil }

	var brokerServiceURLTls: String {
		get { _brokerServiceURLTls ?? String() }
		set { _brokerServiceURLTls = newValue }
	}

	/// Returns true if `brokerServiceURLTls` has been explicitly set.
	var hasBrokerServiceURLTls: Bool { _brokerServiceURLTls != nil }
	/// Clears the value of `brokerServiceURLTls`. Subsequent reads from it will return its default value.
	mutating func clearBrokerServiceURLTls() { _brokerServiceURLTls = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	enum ResourceType: SwiftProtobuf.Enum, Swift.CaseIterable {
		typealias RawValue = Int
		case producer // = 0
		case consumer // = 1

		init() {
			self = .producer
		}

		init?(rawValue: Int) {
			switch rawValue {
				case 0: self = .producer
				case 1: self = .consumer
				default: return nil
			}
		}

		var rawValue: Int {
			switch self {
				case .producer: 0
				case .consumer: 1
			}
		}
	}

	init() { }

	fileprivate var _resourceID: UInt64? = nil
	fileprivate var _resourceType: Pulsar_Proto_CommandTopicMigrated.ResourceType? = nil
	fileprivate var _brokerServiceURL: String? = nil
	fileprivate var _brokerServiceURLTls: String? = nil
}

struct Pulsar_Proto_CommandCloseProducer: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var producerID: UInt64 {
		get { _producerID ?? 0 }
		set { _producerID = newValue }
	}

	/// Returns true if `producerID` has been explicitly set.
	var hasProducerID: Bool { _producerID != nil }
	/// Clears the value of `producerID`. Subsequent reads from it will return its default value.
	mutating func clearProducerID() { _producerID = nil }

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var assignedBrokerServiceURL: String {
		get { _assignedBrokerServiceURL ?? String() }
		set { _assignedBrokerServiceURL = newValue }
	}

	/// Returns true if `assignedBrokerServiceURL` has been explicitly set.
	var hasAssignedBrokerServiceURL: Bool { _assignedBrokerServiceURL != nil }
	/// Clears the value of `assignedBrokerServiceURL`. Subsequent reads from it will return its default value.
	mutating func clearAssignedBrokerServiceURL() { _assignedBrokerServiceURL = nil }

	var assignedBrokerServiceURLTls: String {
		get { _assignedBrokerServiceURLTls ?? String() }
		set { _assignedBrokerServiceURLTls = newValue }
	}

	/// Returns true if `assignedBrokerServiceURLTls` has been explicitly set.
	var hasAssignedBrokerServiceURLTls: Bool { _assignedBrokerServiceURLTls != nil }
	/// Clears the value of `assignedBrokerServiceURLTls`. Subsequent reads from it will return its default value.
	mutating func clearAssignedBrokerServiceURLTls() { _assignedBrokerServiceURLTls = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _producerID: UInt64? = nil
	fileprivate var _requestID: UInt64? = nil
	fileprivate var _assignedBrokerServiceURL: String? = nil
	fileprivate var _assignedBrokerServiceURLTls: String? = nil
}

struct Pulsar_Proto_CommandCloseConsumer: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var consumerID: UInt64 {
		get { _consumerID ?? 0 }
		set { _consumerID = newValue }
	}

	/// Returns true if `consumerID` has been explicitly set.
	var hasConsumerID: Bool { _consumerID != nil }
	/// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
	mutating func clearConsumerID() { _consumerID = nil }

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var assignedBrokerServiceURL: String {
		get { _assignedBrokerServiceURL ?? String() }
		set { _assignedBrokerServiceURL = newValue }
	}

	/// Returns true if `assignedBrokerServiceURL` has been explicitly set.
	var hasAssignedBrokerServiceURL: Bool { _assignedBrokerServiceURL != nil }
	/// Clears the value of `assignedBrokerServiceURL`. Subsequent reads from it will return its default value.
	mutating func clearAssignedBrokerServiceURL() { _assignedBrokerServiceURL = nil }

	var assignedBrokerServiceURLTls: String {
		get { _assignedBrokerServiceURLTls ?? String() }
		set { _assignedBrokerServiceURLTls = newValue }
	}

	/// Returns true if `assignedBrokerServiceURLTls` has been explicitly set.
	var hasAssignedBrokerServiceURLTls: Bool { _assignedBrokerServiceURLTls != nil }
	/// Clears the value of `assignedBrokerServiceURLTls`. Subsequent reads from it will return its default value.
	mutating func clearAssignedBrokerServiceURLTls() { _assignedBrokerServiceURLTls = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _consumerID: UInt64? = nil
	fileprivate var _requestID: UInt64? = nil
	fileprivate var _assignedBrokerServiceURL: String? = nil
	fileprivate var _assignedBrokerServiceURLTls: String? = nil
}

struct Pulsar_Proto_CommandRedeliverUnacknowledgedMessages: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var consumerID: UInt64 {
		get { _consumerID ?? 0 }
		set { _consumerID = newValue }
	}

	/// Returns true if `consumerID` has been explicitly set.
	var hasConsumerID: Bool { _consumerID != nil }
	/// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
	mutating func clearConsumerID() { _consumerID = nil }

	var messageIDs: [Pulsar_Proto_MessageIDData] = []

	var consumerEpoch: UInt64 {
		get { _consumerEpoch ?? 0 }
		set { _consumerEpoch = newValue }
	}

	/// Returns true if `consumerEpoch` has been explicitly set.
	var hasConsumerEpoch: Bool { _consumerEpoch != nil }
	/// Clears the value of `consumerEpoch`. Subsequent reads from it will return its default value.
	mutating func clearConsumerEpoch() { _consumerEpoch = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _consumerID: UInt64? = nil
	fileprivate var _consumerEpoch: UInt64? = nil
}

struct Pulsar_Proto_CommandSuccess: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var schema: Pulsar_Proto_Schema {
		get { _schema ?? Pulsar_Proto_Schema() }
		set { _schema = newValue }
	}

	/// Returns true if `schema` has been explicitly set.
	var hasSchema: Bool { _schema != nil }
	/// Clears the value of `schema`. Subsequent reads from it will return its default value.
	mutating func clearSchema() { _schema = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _schema: Pulsar_Proto_Schema? = nil
}

//// Response from CommandProducer
struct Pulsar_Proto_CommandProducerSuccess: @unchecked Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var producerName: String {
		get { _producerName ?? String() }
		set { _producerName = newValue }
	}

	/// Returns true if `producerName` has been explicitly set.
	var hasProducerName: Bool { _producerName != nil }
	/// Clears the value of `producerName`. Subsequent reads from it will return its default value.
	mutating func clearProducerName() { _producerName = nil }

	/// The last sequence id that was stored by this producer in the previous session
	/// This will only be meaningful if deduplication has been enabled.
	var lastSequenceID: Int64 {
		get { _lastSequenceID ?? -1 }
		set { _lastSequenceID = newValue }
	}

	/// Returns true if `lastSequenceID` has been explicitly set.
	var hasLastSequenceID: Bool { _lastSequenceID != nil }
	/// Clears the value of `lastSequenceID`. Subsequent reads from it will return its default value.
	mutating func clearLastSequenceID() { _lastSequenceID = nil }

	var schemaVersion: Data {
		get { _schemaVersion ?? Data() }
		set { _schemaVersion = newValue }
	}

	/// Returns true if `schemaVersion` has been explicitly set.
	var hasSchemaVersion: Bool { _schemaVersion != nil }
	/// Clears the value of `schemaVersion`. Subsequent reads from it will return its default value.
	mutating func clearSchemaVersion() { _schemaVersion = nil }

	/// The topic epoch assigned by the broker. This field will only be set if we
	/// were requiring exclusive access when creating the producer.
	var topicEpoch: UInt64 {
		get { _topicEpoch ?? 0 }
		set { _topicEpoch = newValue }
	}

	/// Returns true if `topicEpoch` has been explicitly set.
	var hasTopicEpoch: Bool { _topicEpoch != nil }
	/// Clears the value of `topicEpoch`. Subsequent reads from it will return its default value.
	mutating func clearTopicEpoch() { _topicEpoch = nil }

	/// If producer is not "ready", the client will avoid to timeout the request
	/// for creating the producer. Instead it will wait indefinitely until it gets
	/// a subsequent  `CommandProducerSuccess` with `producer_ready==true`.
	var producerReady: Bool {
		get { _producerReady ?? true }
		set { _producerReady = newValue }
	}

	/// Returns true if `producerReady` has been explicitly set.
	var hasProducerReady: Bool { _producerReady != nil }
	/// Clears the value of `producerReady`. Subsequent reads from it will return its default value.
	mutating func clearProducerReady() { _producerReady = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64?
	fileprivate var _producerName: String?
	fileprivate var _lastSequenceID: Int64?
	fileprivate var _schemaVersion: Data?
	fileprivate var _topicEpoch: UInt64?
	fileprivate var _producerReady: Bool?
}

struct Pulsar_Proto_CommandError: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var error: Pulsar_Proto_ServerError {
		get { _error ?? .unknownError }
		set { _error = newValue }
	}

	/// Returns true if `error` has been explicitly set.
	var hasError: Bool { _error != nil }
	/// Clears the value of `error`. Subsequent reads from it will return its default value.
	mutating func clearError() { _error = nil }

	var message: String {
		get { _message ?? String() }
		set { _message = newValue }
	}

	/// Returns true if `message` has been explicitly set.
	var hasMessage: Bool { _message != nil }
	/// Clears the value of `message`. Subsequent reads from it will return its default value.
	mutating func clearMessage() { _message = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _error: Pulsar_Proto_ServerError? = nil
	fileprivate var _message: String? = nil
}

/// Commands to probe the state of connection.
/// When either client or broker doesn't receive commands for certain
/// amount of time, they will send a Ping probe.
struct Pulsar_Proto_CommandPing: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }
}

struct Pulsar_Proto_CommandPong: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }
}

struct Pulsar_Proto_CommandConsumerStats: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	/// required string topic_name         = 2;
	/// required string subscription_name  = 3;
	var consumerID: UInt64 {
		get { _consumerID ?? 0 }
		set { _consumerID = newValue }
	}

	/// Returns true if `consumerID` has been explicitly set.
	var hasConsumerID: Bool { _consumerID != nil }
	/// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
	mutating func clearConsumerID() { _consumerID = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _consumerID: UInt64? = nil
}

struct Pulsar_Proto_CommandConsumerStatsResponse: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var errorCode: Pulsar_Proto_ServerError {
		get { _errorCode ?? .unknownError }
		set { _errorCode = newValue }
	}

	/// Returns true if `errorCode` has been explicitly set.
	var hasErrorCode: Bool { _errorCode != nil }
	/// Clears the value of `errorCode`. Subsequent reads from it will return its default value.
	mutating func clearErrorCode() { _errorCode = nil }

	var errorMessage: String {
		get { _errorMessage ?? String() }
		set { _errorMessage = newValue }
	}

	/// Returns true if `errorMessage` has been explicitly set.
	var hasErrorMessage: Bool { _errorMessage != nil }
	/// Clears the value of `errorMessage`. Subsequent reads from it will return its default value.
	mutating func clearErrorMessage() { _errorMessage = nil }

	//// Total rate of messages delivered to the consumer. msg/s
	var msgRateOut: Double {
		get { _msgRateOut ?? 0 }
		set { _msgRateOut = newValue }
	}

	/// Returns true if `msgRateOut` has been explicitly set.
	var hasMsgRateOut: Bool { _msgRateOut != nil }
	/// Clears the value of `msgRateOut`. Subsequent reads from it will return its default value.
	mutating func clearMsgRateOut() { _msgRateOut = nil }

	//// Total throughput delivered to the consumer. bytes/s
	var msgThroughputOut: Double {
		get { _msgThroughputOut ?? 0 }
		set { _msgThroughputOut = newValue }
	}

	/// Returns true if `msgThroughputOut` has been explicitly set.
	var hasMsgThroughputOut: Bool { _msgThroughputOut != nil }
	/// Clears the value of `msgThroughputOut`. Subsequent reads from it will return its default value.
	mutating func clearMsgThroughputOut() { _msgThroughputOut = nil }

	//// Total rate of messages redelivered by this consumer. msg/s
	var msgRateRedeliver: Double {
		get { _msgRateRedeliver ?? 0 }
		set { _msgRateRedeliver = newValue }
	}

	/// Returns true if `msgRateRedeliver` has been explicitly set.
	var hasMsgRateRedeliver: Bool { _msgRateRedeliver != nil }
	/// Clears the value of `msgRateRedeliver`. Subsequent reads from it will return its default value.
	mutating func clearMsgRateRedeliver() { _msgRateRedeliver = nil }

	//// Name of the consumer
	var consumerName: String {
		get { _consumerName ?? String() }
		set { _consumerName = newValue }
	}

	/// Returns true if `consumerName` has been explicitly set.
	var hasConsumerName: Bool { _consumerName != nil }
	/// Clears the value of `consumerName`. Subsequent reads from it will return its default value.
	mutating func clearConsumerName() { _consumerName = nil }

	//// Number of available message permits for the consumer
	var availablePermits: UInt64 {
		get { _availablePermits ?? 0 }
		set { _availablePermits = newValue }
	}

	/// Returns true if `availablePermits` has been explicitly set.
	var hasAvailablePermits: Bool { _availablePermits != nil }
	/// Clears the value of `availablePermits`. Subsequent reads from it will return its default value.
	mutating func clearAvailablePermits() { _availablePermits = nil }

	//// Number of unacknowledged messages for the consumer
	var unackedMessages: UInt64 {
		get { _unackedMessages ?? 0 }
		set { _unackedMessages = newValue }
	}

	/// Returns true if `unackedMessages` has been explicitly set.
	var hasUnackedMessages: Bool { _unackedMessages != nil }
	/// Clears the value of `unackedMessages`. Subsequent reads from it will return its default value.
	mutating func clearUnackedMessages() { _unackedMessages = nil }

	//// Flag to verify if consumer is blocked due to reaching threshold of unacked messages
	var blockedConsumerOnUnackedMsgs: Bool {
		get { _blockedConsumerOnUnackedMsgs ?? false }
		set { _blockedConsumerOnUnackedMsgs = newValue }
	}

	/// Returns true if `blockedConsumerOnUnackedMsgs` has been explicitly set.
	var hasBlockedConsumerOnUnackedMsgs: Bool { _blockedConsumerOnUnackedMsgs != nil }
	/// Clears the value of `blockedConsumerOnUnackedMsgs`. Subsequent reads from it will return its default value.
	mutating func clearBlockedConsumerOnUnackedMsgs() { _blockedConsumerOnUnackedMsgs = nil }

	//// Address of this consumer
	var address: String {
		get { _address ?? String() }
		set { _address = newValue }
	}

	/// Returns true if `address` has been explicitly set.
	var hasAddress: Bool { _address != nil }
	/// Clears the value of `address`. Subsequent reads from it will return its default value.
	mutating func clearAddress() { _address = nil }

	//// Timestamp of connection
	var connectedSince: String {
		get { _connectedSince ?? String() }
		set { _connectedSince = newValue }
	}

	/// Returns true if `connectedSince` has been explicitly set.
	var hasConnectedSince: Bool { _connectedSince != nil }
	/// Clears the value of `connectedSince`. Subsequent reads from it will return its default value.
	mutating func clearConnectedSince() { _connectedSince = nil }

	//// Whether this subscription is Exclusive or Shared or Failover
	var type: String {
		get { _type ?? String() }
		set { _type = newValue }
	}

	/// Returns true if `type` has been explicitly set.
	var hasType: Bool { _type != nil }
	/// Clears the value of `type`. Subsequent reads from it will return its default value.
	mutating func clearType() { _type = nil }

	//// Total rate of messages expired on this subscription. msg/s
	var msgRateExpired: Double {
		get { _msgRateExpired ?? 0 }
		set { _msgRateExpired = newValue }
	}

	/// Returns true if `msgRateExpired` has been explicitly set.
	var hasMsgRateExpired: Bool { _msgRateExpired != nil }
	/// Clears the value of `msgRateExpired`. Subsequent reads from it will return its default value.
	mutating func clearMsgRateExpired() { _msgRateExpired = nil }

	//// Number of messages in the subscription backlog
	var msgBacklog: UInt64 {
		get { _msgBacklog ?? 0 }
		set { _msgBacklog = newValue }
	}

	/// Returns true if `msgBacklog` has been explicitly set.
	var hasMsgBacklog: Bool { _msgBacklog != nil }
	/// Clears the value of `msgBacklog`. Subsequent reads from it will return its default value.
	mutating func clearMsgBacklog() { _msgBacklog = nil }

	//// Total rate of messages ack. msg/s
	var messageAckRate: Double {
		get { _messageAckRate ?? 0 }
		set { _messageAckRate = newValue }
	}

	/// Returns true if `messageAckRate` has been explicitly set.
	var hasMessageAckRate: Bool { _messageAckRate != nil }
	/// Clears the value of `messageAckRate`. Subsequent reads from it will return its default value.
	mutating func clearMessageAckRate() { _messageAckRate = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _errorCode: Pulsar_Proto_ServerError? = nil
	fileprivate var _errorMessage: String? = nil
	fileprivate var _msgRateOut: Double? = nil
	fileprivate var _msgThroughputOut: Double? = nil
	fileprivate var _msgRateRedeliver: Double? = nil
	fileprivate var _consumerName: String? = nil
	fileprivate var _availablePermits: UInt64? = nil
	fileprivate var _unackedMessages: UInt64? = nil
	fileprivate var _blockedConsumerOnUnackedMsgs: Bool? = nil
	fileprivate var _address: String? = nil
	fileprivate var _connectedSince: String? = nil
	fileprivate var _type: String? = nil
	fileprivate var _msgRateExpired: Double? = nil
	fileprivate var _msgBacklog: UInt64? = nil
	fileprivate var _messageAckRate: Double? = nil
}

struct Pulsar_Proto_CommandGetLastMessageID: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var consumerID: UInt64 {
		get { _consumerID ?? 0 }
		set { _consumerID = newValue }
	}

	/// Returns true if `consumerID` has been explicitly set.
	var hasConsumerID: Bool { _consumerID != nil }
	/// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
	mutating func clearConsumerID() { _consumerID = nil }

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _consumerID: UInt64? = nil
	fileprivate var _requestID: UInt64? = nil
}

struct Pulsar_Proto_CommandGetLastMessageIDResponse: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var lastMessageID: Pulsar_Proto_MessageIDData {
		get { _lastMessageID ?? Pulsar_Proto_MessageIDData() }
		set { _lastMessageID = newValue }
	}

	/// Returns true if `lastMessageID` has been explicitly set.
	var hasLastMessageID: Bool { _lastMessageID != nil }
	/// Clears the value of `lastMessageID`. Subsequent reads from it will return its default value.
	mutating func clearLastMessageID() { _lastMessageID = nil }

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var consumerMarkDeletePosition: Pulsar_Proto_MessageIDData {
		get { _consumerMarkDeletePosition ?? Pulsar_Proto_MessageIDData() }
		set { _consumerMarkDeletePosition = newValue }
	}

	/// Returns true if `consumerMarkDeletePosition` has been explicitly set.
	var hasConsumerMarkDeletePosition: Bool { _consumerMarkDeletePosition != nil }
	/// Clears the value of `consumerMarkDeletePosition`. Subsequent reads from it will return its default value.
	mutating func clearConsumerMarkDeletePosition() { _consumerMarkDeletePosition = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _lastMessageID: Pulsar_Proto_MessageIDData? = nil
	fileprivate var _requestID: UInt64? = nil
	fileprivate var _consumerMarkDeletePosition: Pulsar_Proto_MessageIDData? = nil
}

struct Pulsar_Proto_CommandGetTopicsOfNamespace: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var namespace: String {
		get { _namespace ?? String() }
		set { _namespace = newValue }
	}

	/// Returns true if `namespace` has been explicitly set.
	var hasNamespace: Bool { _namespace != nil }
	/// Clears the value of `namespace`. Subsequent reads from it will return its default value.
	mutating func clearNamespace() { _namespace = nil }

	var mode: Pulsar_Proto_CommandGetTopicsOfNamespace.Mode {
		get { _mode ?? .persistent }
		set { _mode = newValue }
	}

	/// Returns true if `mode` has been explicitly set.
	var hasMode: Bool { _mode != nil }
	/// Clears the value of `mode`. Subsequent reads from it will return its default value.
	mutating func clearMode() { _mode = nil }

	var topicsPattern: String {
		get { _topicsPattern ?? String() }
		set { _topicsPattern = newValue }
	}

	/// Returns true if `topicsPattern` has been explicitly set.
	var hasTopicsPattern: Bool { _topicsPattern != nil }
	/// Clears the value of `topicsPattern`. Subsequent reads from it will return its default value.
	mutating func clearTopicsPattern() { _topicsPattern = nil }

	var topicsHash: String {
		get { _topicsHash ?? String() }
		set { _topicsHash = newValue }
	}

	/// Returns true if `topicsHash` has been explicitly set.
	var hasTopicsHash: Bool { _topicsHash != nil }
	/// Clears the value of `topicsHash`. Subsequent reads from it will return its default value.
	mutating func clearTopicsHash() { _topicsHash = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	enum Mode: SwiftProtobuf.Enum, Swift.CaseIterable {
		typealias RawValue = Int
		case persistent // = 0
		case nonPersistent // = 1
		case all // = 2

		init() {
			self = .persistent
		}

		init?(rawValue: Int) {
			switch rawValue {
				case 0: self = .persistent
				case 1: self = .nonPersistent
				case 2: self = .all
				default: return nil
			}
		}

		var rawValue: Int {
			switch self {
				case .persistent: 0
				case .nonPersistent: 1
				case .all: 2
			}
		}
	}

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _namespace: String? = nil
	fileprivate var _mode: Pulsar_Proto_CommandGetTopicsOfNamespace.Mode? = nil
	fileprivate var _topicsPattern: String? = nil
	fileprivate var _topicsHash: String? = nil
}

struct Pulsar_Proto_CommandGetTopicsOfNamespaceResponse: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var topics: [String] = []

	/// true iff the topic list was filtered by the pattern supplied by the client
	var filtered: Bool {
		get { _filtered ?? false }
		set { _filtered = newValue }
	}

	/// Returns true if `filtered` has been explicitly set.
	var hasFiltered: Bool { _filtered != nil }
	/// Clears the value of `filtered`. Subsequent reads from it will return its default value.
	mutating func clearFiltered() { _filtered = nil }

	/// hash computed from the names of matching topics
	var topicsHash: String {
		get { _topicsHash ?? String() }
		set { _topicsHash = newValue }
	}

	/// Returns true if `topicsHash` has been explicitly set.
	var hasTopicsHash: Bool { _topicsHash != nil }
	/// Clears the value of `topicsHash`. Subsequent reads from it will return its default value.
	mutating func clearTopicsHash() { _topicsHash = nil }

	/// if false, topics is empty and the list of matching topics has not changed
	var changed: Bool {
		get { _changed ?? true }
		set { _changed = newValue }
	}

	/// Returns true if `changed` has been explicitly set.
	var hasChanged: Bool { _changed != nil }
	/// Clears the value of `changed`. Subsequent reads from it will return its default value.
	mutating func clearChanged() { _changed = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _filtered: Bool? = nil
	fileprivate var _topicsHash: String? = nil
	fileprivate var _changed: Bool? = nil
}

struct Pulsar_Proto_CommandWatchTopicList: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var watcherID: UInt64 {
		get { _watcherID ?? 0 }
		set { _watcherID = newValue }
	}

	/// Returns true if `watcherID` has been explicitly set.
	var hasWatcherID: Bool { _watcherID != nil }
	/// Clears the value of `watcherID`. Subsequent reads from it will return its default value.
	mutating func clearWatcherID() { _watcherID = nil }

	var namespace: String {
		get { _namespace ?? String() }
		set { _namespace = newValue }
	}

	/// Returns true if `namespace` has been explicitly set.
	var hasNamespace: Bool { _namespace != nil }
	/// Clears the value of `namespace`. Subsequent reads from it will return its default value.
	mutating func clearNamespace() { _namespace = nil }

	var topicsPattern: String {
		get { _topicsPattern ?? String() }
		set { _topicsPattern = newValue }
	}

	/// Returns true if `topicsPattern` has been explicitly set.
	var hasTopicsPattern: Bool { _topicsPattern != nil }
	/// Clears the value of `topicsPattern`. Subsequent reads from it will return its default value.
	mutating func clearTopicsPattern() { _topicsPattern = nil }

	/// Only present when the client reconnects:
	var topicsHash: String {
		get { _topicsHash ?? String() }
		set { _topicsHash = newValue }
	}

	/// Returns true if `topicsHash` has been explicitly set.
	var hasTopicsHash: Bool { _topicsHash != nil }
	/// Clears the value of `topicsHash`. Subsequent reads from it will return its default value.
	mutating func clearTopicsHash() { _topicsHash = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _watcherID: UInt64? = nil
	fileprivate var _namespace: String? = nil
	fileprivate var _topicsPattern: String? = nil
	fileprivate var _topicsHash: String? = nil
}

struct Pulsar_Proto_CommandWatchTopicListSuccess: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var watcherID: UInt64 {
		get { _watcherID ?? 0 }
		set { _watcherID = newValue }
	}

	/// Returns true if `watcherID` has been explicitly set.
	var hasWatcherID: Bool { _watcherID != nil }
	/// Clears the value of `watcherID`. Subsequent reads from it will return its default value.
	mutating func clearWatcherID() { _watcherID = nil }

	var topic: [String] = []

	var topicsHash: String {
		get { _topicsHash ?? String() }
		set { _topicsHash = newValue }
	}

	/// Returns true if `topicsHash` has been explicitly set.
	var hasTopicsHash: Bool { _topicsHash != nil }
	/// Clears the value of `topicsHash`. Subsequent reads from it will return its default value.
	mutating func clearTopicsHash() { _topicsHash = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _watcherID: UInt64? = nil
	fileprivate var _topicsHash: String? = nil
}

struct Pulsar_Proto_CommandWatchTopicUpdate: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var watcherID: UInt64 {
		get { _watcherID ?? 0 }
		set { _watcherID = newValue }
	}

	/// Returns true if `watcherID` has been explicitly set.
	var hasWatcherID: Bool { _watcherID != nil }
	/// Clears the value of `watcherID`. Subsequent reads from it will return its default value.
	mutating func clearWatcherID() { _watcherID = nil }

	var newTopics: [String] = []

	var deletedTopics: [String] = []

	var topicsHash: String {
		get { _topicsHash ?? String() }
		set { _topicsHash = newValue }
	}

	/// Returns true if `topicsHash` has been explicitly set.
	var hasTopicsHash: Bool { _topicsHash != nil }
	/// Clears the value of `topicsHash`. Subsequent reads from it will return its default value.
	mutating func clearTopicsHash() { _topicsHash = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _watcherID: UInt64? = nil
	fileprivate var _topicsHash: String? = nil
}

struct Pulsar_Proto_CommandWatchTopicListClose: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var watcherID: UInt64 {
		get { _watcherID ?? 0 }
		set { _watcherID = newValue }
	}

	/// Returns true if `watcherID` has been explicitly set.
	var hasWatcherID: Bool { _watcherID != nil }
	/// Clears the value of `watcherID`. Subsequent reads from it will return its default value.
	mutating func clearWatcherID() { _watcherID = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _watcherID: UInt64? = nil
}

struct Pulsar_Proto_CommandGetSchema: @unchecked Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var topic: String {
		get { _topic ?? String() }
		set { _topic = newValue }
	}

	/// Returns true if `topic` has been explicitly set.
	var hasTopic: Bool { _topic != nil }
	/// Clears the value of `topic`. Subsequent reads from it will return its default value.
	mutating func clearTopic() { _topic = nil }

	var schemaVersion: Data {
		get { _schemaVersion ?? Data() }
		set { _schemaVersion = newValue }
	}

	/// Returns true if `schemaVersion` has been explicitly set.
	var hasSchemaVersion: Bool { _schemaVersion != nil }
	/// Clears the value of `schemaVersion`. Subsequent reads from it will return its default value.
	mutating func clearSchemaVersion() { _schemaVersion = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64?
	fileprivate var _topic: String?
	fileprivate var _schemaVersion: Data?
}

struct Pulsar_Proto_CommandGetSchemaResponse: @unchecked Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var errorCode: Pulsar_Proto_ServerError {
		get { _errorCode ?? .unknownError }
		set { _errorCode = newValue }
	}

	/// Returns true if `errorCode` has been explicitly set.
	var hasErrorCode: Bool { _errorCode != nil }
	/// Clears the value of `errorCode`. Subsequent reads from it will return its default value.
	mutating func clearErrorCode() { _errorCode = nil }

	var errorMessage: String {
		get { _errorMessage ?? String() }
		set { _errorMessage = newValue }
	}

	/// Returns true if `errorMessage` has been explicitly set.
	var hasErrorMessage: Bool { _errorMessage != nil }
	/// Clears the value of `errorMessage`. Subsequent reads from it will return its default value.
	mutating func clearErrorMessage() { _errorMessage = nil }

	var schema: Pulsar_Proto_Schema {
		get { _schema ?? Pulsar_Proto_Schema() }
		set { _schema = newValue }
	}

	/// Returns true if `schema` has been explicitly set.
	var hasSchema: Bool { _schema != nil }
	/// Clears the value of `schema`. Subsequent reads from it will return its default value.
	mutating func clearSchema() { _schema = nil }

	var schemaVersion: Data {
		get { _schemaVersion ?? Data() }
		set { _schemaVersion = newValue }
	}

	/// Returns true if `schemaVersion` has been explicitly set.
	var hasSchemaVersion: Bool { _schemaVersion != nil }
	/// Clears the value of `schemaVersion`. Subsequent reads from it will return its default value.
	mutating func clearSchemaVersion() { _schemaVersion = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64?
	fileprivate var _errorCode: Pulsar_Proto_ServerError?
	fileprivate var _errorMessage: String?
	fileprivate var _schema: Pulsar_Proto_Schema?
	fileprivate var _schemaVersion: Data?
}

struct Pulsar_Proto_CommandGetOrCreateSchema: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var topic: String {
		get { _topic ?? String() }
		set { _topic = newValue }
	}

	/// Returns true if `topic` has been explicitly set.
	var hasTopic: Bool { _topic != nil }
	/// Clears the value of `topic`. Subsequent reads from it will return its default value.
	mutating func clearTopic() { _topic = nil }

	var schema: Pulsar_Proto_Schema {
		get { _schema ?? Pulsar_Proto_Schema() }
		set { _schema = newValue }
	}

	/// Returns true if `schema` has been explicitly set.
	var hasSchema: Bool { _schema != nil }
	/// Clears the value of `schema`. Subsequent reads from it will return its default value.
	mutating func clearSchema() { _schema = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _topic: String? = nil
	fileprivate var _schema: Pulsar_Proto_Schema? = nil
}

struct Pulsar_Proto_CommandGetOrCreateSchemaResponse: @unchecked Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var errorCode: Pulsar_Proto_ServerError {
		get { _errorCode ?? .unknownError }
		set { _errorCode = newValue }
	}

	/// Returns true if `errorCode` has been explicitly set.
	var hasErrorCode: Bool { _errorCode != nil }
	/// Clears the value of `errorCode`. Subsequent reads from it will return its default value.
	mutating func clearErrorCode() { _errorCode = nil }

	var errorMessage: String {
		get { _errorMessage ?? String() }
		set { _errorMessage = newValue }
	}

	/// Returns true if `errorMessage` has been explicitly set.
	var hasErrorMessage: Bool { _errorMessage != nil }
	/// Clears the value of `errorMessage`. Subsequent reads from it will return its default value.
	mutating func clearErrorMessage() { _errorMessage = nil }

	var schemaVersion: Data {
		get { _schemaVersion ?? Data() }
		set { _schemaVersion = newValue }
	}

	/// Returns true if `schemaVersion` has been explicitly set.
	var hasSchemaVersion: Bool { _schemaVersion != nil }
	/// Clears the value of `schemaVersion`. Subsequent reads from it will return its default value.
	mutating func clearSchemaVersion() { _schemaVersion = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64?
	fileprivate var _errorCode: Pulsar_Proto_ServerError?
	fileprivate var _errorMessage: String?
	fileprivate var _schemaVersion: Data?
}

struct Pulsar_Proto_CommandTcClientConnectRequest: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var tcID: UInt64 {
		get { _tcID ?? 0 }
		set { _tcID = newValue }
	}

	/// Returns true if `tcID` has been explicitly set.
	var hasTcID: Bool { _tcID != nil }
	/// Clears the value of `tcID`. Subsequent reads from it will return its default value.
	mutating func clearTcID() { _tcID = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _tcID: UInt64? = nil
}

struct Pulsar_Proto_CommandTcClientConnectResponse: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var error: Pulsar_Proto_ServerError {
		get { _error ?? .unknownError }
		set { _error = newValue }
	}

	/// Returns true if `error` has been explicitly set.
	var hasError: Bool { _error != nil }
	/// Clears the value of `error`. Subsequent reads from it will return its default value.
	mutating func clearError() { _error = nil }

	var message: String {
		get { _message ?? String() }
		set { _message = newValue }
	}

	/// Returns true if `message` has been explicitly set.
	var hasMessage: Bool { _message != nil }
	/// Clears the value of `message`. Subsequent reads from it will return its default value.
	mutating func clearMessage() { _message = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _error: Pulsar_Proto_ServerError? = nil
	fileprivate var _message: String? = nil
}

struct Pulsar_Proto_CommandNewTxn: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var txnTtlSeconds: UInt64 {
		get { _txnTtlSeconds ?? 0 }
		set { _txnTtlSeconds = newValue }
	}

	/// Returns true if `txnTtlSeconds` has been explicitly set.
	var hasTxnTtlSeconds: Bool { _txnTtlSeconds != nil }
	/// Clears the value of `txnTtlSeconds`. Subsequent reads from it will return its default value.
	mutating func clearTxnTtlSeconds() { _txnTtlSeconds = nil }

	var tcID: UInt64 {
		get { _tcID ?? 0 }
		set { _tcID = newValue }
	}

	/// Returns true if `tcID` has been explicitly set.
	var hasTcID: Bool { _tcID != nil }
	/// Clears the value of `tcID`. Subsequent reads from it will return its default value.
	mutating func clearTcID() { _tcID = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _txnTtlSeconds: UInt64? = nil
	fileprivate var _tcID: UInt64? = nil
}

struct Pulsar_Proto_CommandNewTxnResponse: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var txnidLeastBits: UInt64 {
		get { _txnidLeastBits ?? 0 }
		set { _txnidLeastBits = newValue }
	}

	/// Returns true if `txnidLeastBits` has been explicitly set.
	var hasTxnidLeastBits: Bool { _txnidLeastBits != nil }
	/// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidLeastBits() { _txnidLeastBits = nil }

	var txnidMostBits: UInt64 {
		get { _txnidMostBits ?? 0 }
		set { _txnidMostBits = newValue }
	}

	/// Returns true if `txnidMostBits` has been explicitly set.
	var hasTxnidMostBits: Bool { _txnidMostBits != nil }
	/// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidMostBits() { _txnidMostBits = nil }

	var error: Pulsar_Proto_ServerError {
		get { _error ?? .unknownError }
		set { _error = newValue }
	}

	/// Returns true if `error` has been explicitly set.
	var hasError: Bool { _error != nil }
	/// Clears the value of `error`. Subsequent reads from it will return its default value.
	mutating func clearError() { _error = nil }

	var message: String {
		get { _message ?? String() }
		set { _message = newValue }
	}

	/// Returns true if `message` has been explicitly set.
	var hasMessage: Bool { _message != nil }
	/// Clears the value of `message`. Subsequent reads from it will return its default value.
	mutating func clearMessage() { _message = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _txnidLeastBits: UInt64? = nil
	fileprivate var _txnidMostBits: UInt64? = nil
	fileprivate var _error: Pulsar_Proto_ServerError? = nil
	fileprivate var _message: String? = nil
}

struct Pulsar_Proto_CommandAddPartitionToTxn: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var txnidLeastBits: UInt64 {
		get { _txnidLeastBits ?? 0 }
		set { _txnidLeastBits = newValue }
	}

	/// Returns true if `txnidLeastBits` has been explicitly set.
	var hasTxnidLeastBits: Bool { _txnidLeastBits != nil }
	/// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidLeastBits() { _txnidLeastBits = nil }

	var txnidMostBits: UInt64 {
		get { _txnidMostBits ?? 0 }
		set { _txnidMostBits = newValue }
	}

	/// Returns true if `txnidMostBits` has been explicitly set.
	var hasTxnidMostBits: Bool { _txnidMostBits != nil }
	/// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidMostBits() { _txnidMostBits = nil }

	var partitions: [String] = []

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _txnidLeastBits: UInt64? = nil
	fileprivate var _txnidMostBits: UInt64? = nil
}

struct Pulsar_Proto_CommandAddPartitionToTxnResponse: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var txnidLeastBits: UInt64 {
		get { _txnidLeastBits ?? 0 }
		set { _txnidLeastBits = newValue }
	}

	/// Returns true if `txnidLeastBits` has been explicitly set.
	var hasTxnidLeastBits: Bool { _txnidLeastBits != nil }
	/// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidLeastBits() { _txnidLeastBits = nil }

	var txnidMostBits: UInt64 {
		get { _txnidMostBits ?? 0 }
		set { _txnidMostBits = newValue }
	}

	/// Returns true if `txnidMostBits` has been explicitly set.
	var hasTxnidMostBits: Bool { _txnidMostBits != nil }
	/// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidMostBits() { _txnidMostBits = nil }

	var error: Pulsar_Proto_ServerError {
		get { _error ?? .unknownError }
		set { _error = newValue }
	}

	/// Returns true if `error` has been explicitly set.
	var hasError: Bool { _error != nil }
	/// Clears the value of `error`. Subsequent reads from it will return its default value.
	mutating func clearError() { _error = nil }

	var message: String {
		get { _message ?? String() }
		set { _message = newValue }
	}

	/// Returns true if `message` has been explicitly set.
	var hasMessage: Bool { _message != nil }
	/// Clears the value of `message`. Subsequent reads from it will return its default value.
	mutating func clearMessage() { _message = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _txnidLeastBits: UInt64? = nil
	fileprivate var _txnidMostBits: UInt64? = nil
	fileprivate var _error: Pulsar_Proto_ServerError? = nil
	fileprivate var _message: String? = nil
}

struct Pulsar_Proto_Subscription: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var topic: String {
		get { _topic ?? String() }
		set { _topic = newValue }
	}

	/// Returns true if `topic` has been explicitly set.
	var hasTopic: Bool { _topic != nil }
	/// Clears the value of `topic`. Subsequent reads from it will return its default value.
	mutating func clearTopic() { _topic = nil }

	var subscription: String {
		get { _subscription ?? String() }
		set { _subscription = newValue }
	}

	/// Returns true if `subscription` has been explicitly set.
	var hasSubscription: Bool { _subscription != nil }
	/// Clears the value of `subscription`. Subsequent reads from it will return its default value.
	mutating func clearSubscription() { _subscription = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _topic: String? = nil
	fileprivate var _subscription: String? = nil
}

struct Pulsar_Proto_CommandAddSubscriptionToTxn: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var txnidLeastBits: UInt64 {
		get { _txnidLeastBits ?? 0 }
		set { _txnidLeastBits = newValue }
	}

	/// Returns true if `txnidLeastBits` has been explicitly set.
	var hasTxnidLeastBits: Bool { _txnidLeastBits != nil }
	/// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidLeastBits() { _txnidLeastBits = nil }

	var txnidMostBits: UInt64 {
		get { _txnidMostBits ?? 0 }
		set { _txnidMostBits = newValue }
	}

	/// Returns true if `txnidMostBits` has been explicitly set.
	var hasTxnidMostBits: Bool { _txnidMostBits != nil }
	/// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidMostBits() { _txnidMostBits = nil }

	var subscription: [Pulsar_Proto_Subscription] = []

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _txnidLeastBits: UInt64? = nil
	fileprivate var _txnidMostBits: UInt64? = nil
}

struct Pulsar_Proto_CommandAddSubscriptionToTxnResponse: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var txnidLeastBits: UInt64 {
		get { _txnidLeastBits ?? 0 }
		set { _txnidLeastBits = newValue }
	}

	/// Returns true if `txnidLeastBits` has been explicitly set.
	var hasTxnidLeastBits: Bool { _txnidLeastBits != nil }
	/// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidLeastBits() { _txnidLeastBits = nil }

	var txnidMostBits: UInt64 {
		get { _txnidMostBits ?? 0 }
		set { _txnidMostBits = newValue }
	}

	/// Returns true if `txnidMostBits` has been explicitly set.
	var hasTxnidMostBits: Bool { _txnidMostBits != nil }
	/// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidMostBits() { _txnidMostBits = nil }

	var error: Pulsar_Proto_ServerError {
		get { _error ?? .unknownError }
		set { _error = newValue }
	}

	/// Returns true if `error` has been explicitly set.
	var hasError: Bool { _error != nil }
	/// Clears the value of `error`. Subsequent reads from it will return its default value.
	mutating func clearError() { _error = nil }

	var message: String {
		get { _message ?? String() }
		set { _message = newValue }
	}

	/// Returns true if `message` has been explicitly set.
	var hasMessage: Bool { _message != nil }
	/// Clears the value of `message`. Subsequent reads from it will return its default value.
	mutating func clearMessage() { _message = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _txnidLeastBits: UInt64? = nil
	fileprivate var _txnidMostBits: UInt64? = nil
	fileprivate var _error: Pulsar_Proto_ServerError? = nil
	fileprivate var _message: String? = nil
}

struct Pulsar_Proto_CommandEndTxn: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var txnidLeastBits: UInt64 {
		get { _txnidLeastBits ?? 0 }
		set { _txnidLeastBits = newValue }
	}

	/// Returns true if `txnidLeastBits` has been explicitly set.
	var hasTxnidLeastBits: Bool { _txnidLeastBits != nil }
	/// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidLeastBits() { _txnidLeastBits = nil }

	var txnidMostBits: UInt64 {
		get { _txnidMostBits ?? 0 }
		set { _txnidMostBits = newValue }
	}

	/// Returns true if `txnidMostBits` has been explicitly set.
	var hasTxnidMostBits: Bool { _txnidMostBits != nil }
	/// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidMostBits() { _txnidMostBits = nil }

	var txnAction: Pulsar_Proto_TxnAction {
		get { _txnAction ?? .commit }
		set { _txnAction = newValue }
	}

	/// Returns true if `txnAction` has been explicitly set.
	var hasTxnAction: Bool { _txnAction != nil }
	/// Clears the value of `txnAction`. Subsequent reads from it will return its default value.
	mutating func clearTxnAction() { _txnAction = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _txnidLeastBits: UInt64? = nil
	fileprivate var _txnidMostBits: UInt64? = nil
	fileprivate var _txnAction: Pulsar_Proto_TxnAction? = nil
}

struct Pulsar_Proto_CommandEndTxnResponse: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var txnidLeastBits: UInt64 {
		get { _txnidLeastBits ?? 0 }
		set { _txnidLeastBits = newValue }
	}

	/// Returns true if `txnidLeastBits` has been explicitly set.
	var hasTxnidLeastBits: Bool { _txnidLeastBits != nil }
	/// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidLeastBits() { _txnidLeastBits = nil }

	var txnidMostBits: UInt64 {
		get { _txnidMostBits ?? 0 }
		set { _txnidMostBits = newValue }
	}

	/// Returns true if `txnidMostBits` has been explicitly set.
	var hasTxnidMostBits: Bool { _txnidMostBits != nil }
	/// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidMostBits() { _txnidMostBits = nil }

	var error: Pulsar_Proto_ServerError {
		get { _error ?? .unknownError }
		set { _error = newValue }
	}

	/// Returns true if `error` has been explicitly set.
	var hasError: Bool { _error != nil }
	/// Clears the value of `error`. Subsequent reads from it will return its default value.
	mutating func clearError() { _error = nil }

	var message: String {
		get { _message ?? String() }
		set { _message = newValue }
	}

	/// Returns true if `message` has been explicitly set.
	var hasMessage: Bool { _message != nil }
	/// Clears the value of `message`. Subsequent reads from it will return its default value.
	mutating func clearMessage() { _message = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _txnidLeastBits: UInt64? = nil
	fileprivate var _txnidMostBits: UInt64? = nil
	fileprivate var _error: Pulsar_Proto_ServerError? = nil
	fileprivate var _message: String? = nil
}

struct Pulsar_Proto_CommandEndTxnOnPartition: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var txnidLeastBits: UInt64 {
		get { _txnidLeastBits ?? 0 }
		set { _txnidLeastBits = newValue }
	}

	/// Returns true if `txnidLeastBits` has been explicitly set.
	var hasTxnidLeastBits: Bool { _txnidLeastBits != nil }
	/// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidLeastBits() { _txnidLeastBits = nil }

	var txnidMostBits: UInt64 {
		get { _txnidMostBits ?? 0 }
		set { _txnidMostBits = newValue }
	}

	/// Returns true if `txnidMostBits` has been explicitly set.
	var hasTxnidMostBits: Bool { _txnidMostBits != nil }
	/// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidMostBits() { _txnidMostBits = nil }

	var topic: String {
		get { _topic ?? String() }
		set { _topic = newValue }
	}

	/// Returns true if `topic` has been explicitly set.
	var hasTopic: Bool { _topic != nil }
	/// Clears the value of `topic`. Subsequent reads from it will return its default value.
	mutating func clearTopic() { _topic = nil }

	var txnAction: Pulsar_Proto_TxnAction {
		get { _txnAction ?? .commit }
		set { _txnAction = newValue }
	}

	/// Returns true if `txnAction` has been explicitly set.
	var hasTxnAction: Bool { _txnAction != nil }
	/// Clears the value of `txnAction`. Subsequent reads from it will return its default value.
	mutating func clearTxnAction() { _txnAction = nil }

	var txnidLeastBitsOfLowWatermark: UInt64 {
		get { _txnidLeastBitsOfLowWatermark ?? 0 }
		set { _txnidLeastBitsOfLowWatermark = newValue }
	}

	/// Returns true if `txnidLeastBitsOfLowWatermark` has been explicitly set.
	var hasTxnidLeastBitsOfLowWatermark: Bool { _txnidLeastBitsOfLowWatermark != nil }
	/// Clears the value of `txnidLeastBitsOfLowWatermark`. Subsequent reads from it will return its default value.
	mutating func clearTxnidLeastBitsOfLowWatermark() { _txnidLeastBitsOfLowWatermark = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _txnidLeastBits: UInt64? = nil
	fileprivate var _txnidMostBits: UInt64? = nil
	fileprivate var _topic: String? = nil
	fileprivate var _txnAction: Pulsar_Proto_TxnAction? = nil
	fileprivate var _txnidLeastBitsOfLowWatermark: UInt64? = nil
}

struct Pulsar_Proto_CommandEndTxnOnPartitionResponse: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var txnidLeastBits: UInt64 {
		get { _txnidLeastBits ?? 0 }
		set { _txnidLeastBits = newValue }
	}

	/// Returns true if `txnidLeastBits` has been explicitly set.
	var hasTxnidLeastBits: Bool { _txnidLeastBits != nil }
	/// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidLeastBits() { _txnidLeastBits = nil }

	var txnidMostBits: UInt64 {
		get { _txnidMostBits ?? 0 }
		set { _txnidMostBits = newValue }
	}

	/// Returns true if `txnidMostBits` has been explicitly set.
	var hasTxnidMostBits: Bool { _txnidMostBits != nil }
	/// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidMostBits() { _txnidMostBits = nil }

	var error: Pulsar_Proto_ServerError {
		get { _error ?? .unknownError }
		set { _error = newValue }
	}

	/// Returns true if `error` has been explicitly set.
	var hasError: Bool { _error != nil }
	/// Clears the value of `error`. Subsequent reads from it will return its default value.
	mutating func clearError() { _error = nil }

	var message: String {
		get { _message ?? String() }
		set { _message = newValue }
	}

	/// Returns true if `message` has been explicitly set.
	var hasMessage: Bool { _message != nil }
	/// Clears the value of `message`. Subsequent reads from it will return its default value.
	mutating func clearMessage() { _message = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _txnidLeastBits: UInt64? = nil
	fileprivate var _txnidMostBits: UInt64? = nil
	fileprivate var _error: Pulsar_Proto_ServerError? = nil
	fileprivate var _message: String? = nil
}

struct Pulsar_Proto_CommandEndTxnOnSubscription: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var txnidLeastBits: UInt64 {
		get { _txnidLeastBits ?? 0 }
		set { _txnidLeastBits = newValue }
	}

	/// Returns true if `txnidLeastBits` has been explicitly set.
	var hasTxnidLeastBits: Bool { _txnidLeastBits != nil }
	/// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidLeastBits() { _txnidLeastBits = nil }

	var txnidMostBits: UInt64 {
		get { _txnidMostBits ?? 0 }
		set { _txnidMostBits = newValue }
	}

	/// Returns true if `txnidMostBits` has been explicitly set.
	var hasTxnidMostBits: Bool { _txnidMostBits != nil }
	/// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidMostBits() { _txnidMostBits = nil }

	var subscription: Pulsar_Proto_Subscription {
		get { _subscription ?? Pulsar_Proto_Subscription() }
		set { _subscription = newValue }
	}

	/// Returns true if `subscription` has been explicitly set.
	var hasSubscription: Bool { _subscription != nil }
	/// Clears the value of `subscription`. Subsequent reads from it will return its default value.
	mutating func clearSubscription() { _subscription = nil }

	var txnAction: Pulsar_Proto_TxnAction {
		get { _txnAction ?? .commit }
		set { _txnAction = newValue }
	}

	/// Returns true if `txnAction` has been explicitly set.
	var hasTxnAction: Bool { _txnAction != nil }
	/// Clears the value of `txnAction`. Subsequent reads from it will return its default value.
	mutating func clearTxnAction() { _txnAction = nil }

	var txnidLeastBitsOfLowWatermark: UInt64 {
		get { _txnidLeastBitsOfLowWatermark ?? 0 }
		set { _txnidLeastBitsOfLowWatermark = newValue }
	}

	/// Returns true if `txnidLeastBitsOfLowWatermark` has been explicitly set.
	var hasTxnidLeastBitsOfLowWatermark: Bool { _txnidLeastBitsOfLowWatermark != nil }
	/// Clears the value of `txnidLeastBitsOfLowWatermark`. Subsequent reads from it will return its default value.
	mutating func clearTxnidLeastBitsOfLowWatermark() { _txnidLeastBitsOfLowWatermark = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _txnidLeastBits: UInt64? = nil
	fileprivate var _txnidMostBits: UInt64? = nil
	fileprivate var _subscription: Pulsar_Proto_Subscription? = nil
	fileprivate var _txnAction: Pulsar_Proto_TxnAction? = nil
	fileprivate var _txnidLeastBitsOfLowWatermark: UInt64? = nil
}

struct Pulsar_Proto_CommandEndTxnOnSubscriptionResponse: Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var requestID: UInt64 {
		get { _requestID ?? 0 }
		set { _requestID = newValue }
	}

	/// Returns true if `requestID` has been explicitly set.
	var hasRequestID: Bool { _requestID != nil }
	/// Clears the value of `requestID`. Subsequent reads from it will return its default value.
	mutating func clearRequestID() { _requestID = nil }

	var txnidLeastBits: UInt64 {
		get { _txnidLeastBits ?? 0 }
		set { _txnidLeastBits = newValue }
	}

	/// Returns true if `txnidLeastBits` has been explicitly set.
	var hasTxnidLeastBits: Bool { _txnidLeastBits != nil }
	/// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidLeastBits() { _txnidLeastBits = nil }

	var txnidMostBits: UInt64 {
		get { _txnidMostBits ?? 0 }
		set { _txnidMostBits = newValue }
	}

	/// Returns true if `txnidMostBits` has been explicitly set.
	var hasTxnidMostBits: Bool { _txnidMostBits != nil }
	/// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
	mutating func clearTxnidMostBits() { _txnidMostBits = nil }

	var error: Pulsar_Proto_ServerError {
		get { _error ?? .unknownError }
		set { _error = newValue }
	}

	/// Returns true if `error` has been explicitly set.
	var hasError: Bool { _error != nil }
	/// Clears the value of `error`. Subsequent reads from it will return its default value.
	mutating func clearError() { _error = nil }

	var message: String {
		get { _message ?? String() }
		set { _message = newValue }
	}

	/// Returns true if `message` has been explicitly set.
	var hasMessage: Bool { _message != nil }
	/// Clears the value of `message`. Subsequent reads from it will return its default value.
	mutating func clearMessage() { _message = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() { }

	fileprivate var _requestID: UInt64? = nil
	fileprivate var _txnidLeastBits: UInt64? = nil
	fileprivate var _txnidMostBits: UInt64? = nil
	fileprivate var _error: Pulsar_Proto_ServerError? = nil
	fileprivate var _message: String? = nil
}

struct Pulsar_Proto_BaseCommand: @unchecked Sendable {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var type: Pulsar_Proto_BaseCommand.TypeEnum {
		get { _storage._type ?? .connect }
		set { _uniqueStorage()._type = newValue }
	}

	/// Returns true if `type` has been explicitly set.
	var hasType: Bool { _storage._type != nil }
	/// Clears the value of `type`. Subsequent reads from it will return its default value.
	mutating func clearType() { _uniqueStorage()._type = nil }

	var connect: Pulsar_Proto_CommandConnect {
		get { _storage._connect ?? Pulsar_Proto_CommandConnect() }
		set { _uniqueStorage()._connect = newValue }
	}

	/// Returns true if `connect` has been explicitly set.
	var hasConnect: Bool { _storage._connect != nil }
	/// Clears the value of `connect`. Subsequent reads from it will return its default value.
	mutating func clearConnect() { _uniqueStorage()._connect = nil }

	var connected: Pulsar_Proto_CommandConnected {
		get { _storage._connected ?? Pulsar_Proto_CommandConnected() }
		set { _uniqueStorage()._connected = newValue }
	}

	/// Returns true if `connected` has been explicitly set.
	var hasConnected: Bool { _storage._connected != nil }
	/// Clears the value of `connected`. Subsequent reads from it will return its default value.
	mutating func clearConnected() { _uniqueStorage()._connected = nil }

	var subscribe: Pulsar_Proto_CommandSubscribe {
		get { _storage._subscribe ?? Pulsar_Proto_CommandSubscribe() }
		set { _uniqueStorage()._subscribe = newValue }
	}

	/// Returns true if `subscribe` has been explicitly set.
	var hasSubscribe: Bool { _storage._subscribe != nil }
	/// Clears the value of `subscribe`. Subsequent reads from it will return its default value.
	mutating func clearSubscribe() { _uniqueStorage()._subscribe = nil }

	var producer: Pulsar_Proto_CommandProducer {
		get { _storage._producer ?? Pulsar_Proto_CommandProducer() }
		set { _uniqueStorage()._producer = newValue }
	}

	/// Returns true if `producer` has been explicitly set.
	var hasProducer: Bool { _storage._producer != nil }
	/// Clears the value of `producer`. Subsequent reads from it will return its default value.
	mutating func clearProducer() { _uniqueStorage()._producer = nil }

	var send: Pulsar_Proto_CommandSend {
		get { _storage._send ?? Pulsar_Proto_CommandSend() }
		set { _uniqueStorage()._send = newValue }
	}

	/// Returns true if `send` has been explicitly set.
	var hasSend: Bool { _storage._send != nil }
	/// Clears the value of `send`. Subsequent reads from it will return its default value.
	mutating func clearSend() { _uniqueStorage()._send = nil }

	var sendReceipt: Pulsar_Proto_CommandSendReceipt {
		get { _storage._sendReceipt ?? Pulsar_Proto_CommandSendReceipt() }
		set { _uniqueStorage()._sendReceipt = newValue }
	}

	/// Returns true if `sendReceipt` has been explicitly set.
	var hasSendReceipt: Bool { _storage._sendReceipt != nil }
	/// Clears the value of `sendReceipt`. Subsequent reads from it will return its default value.
	mutating func clearSendReceipt() { _uniqueStorage()._sendReceipt = nil }

	var sendError: Pulsar_Proto_CommandSendError {
		get { _storage._sendError ?? Pulsar_Proto_CommandSendError() }
		set { _uniqueStorage()._sendError = newValue }
	}

	/// Returns true if `sendError` has been explicitly set.
	var hasSendError: Bool { _storage._sendError != nil }
	/// Clears the value of `sendError`. Subsequent reads from it will return its default value.
	mutating func clearSendError() { _uniqueStorage()._sendError = nil }

	var message: Pulsar_Proto_CommandMessage {
		get { _storage._message ?? Pulsar_Proto_CommandMessage() }
		set { _uniqueStorage()._message = newValue }
	}

	/// Returns true if `message` has been explicitly set.
	var hasMessage: Bool { _storage._message != nil }
	/// Clears the value of `message`. Subsequent reads from it will return its default value.
	mutating func clearMessage() { _uniqueStorage()._message = nil }

	var ack: Pulsar_Proto_CommandAck {
		get { _storage._ack ?? Pulsar_Proto_CommandAck() }
		set { _uniqueStorage()._ack = newValue }
	}

	/// Returns true if `ack` has been explicitly set.
	var hasAck: Bool { _storage._ack != nil }
	/// Clears the value of `ack`. Subsequent reads from it will return its default value.
	mutating func clearAck() { _uniqueStorage()._ack = nil }

	var flow: Pulsar_Proto_CommandFlow {
		get { _storage._flow ?? Pulsar_Proto_CommandFlow() }
		set { _uniqueStorage()._flow = newValue }
	}

	/// Returns true if `flow` has been explicitly set.
	var hasFlow: Bool { _storage._flow != nil }
	/// Clears the value of `flow`. Subsequent reads from it will return its default value.
	mutating func clearFlow() { _uniqueStorage()._flow = nil }

	var unsubscribe: Pulsar_Proto_CommandUnsubscribe {
		get { _storage._unsubscribe ?? Pulsar_Proto_CommandUnsubscribe() }
		set { _uniqueStorage()._unsubscribe = newValue }
	}

	/// Returns true if `unsubscribe` has been explicitly set.
	var hasUnsubscribe: Bool { _storage._unsubscribe != nil }
	/// Clears the value of `unsubscribe`. Subsequent reads from it will return its default value.
	mutating func clearUnsubscribe() { _uniqueStorage()._unsubscribe = nil }

	var success: Pulsar_Proto_CommandSuccess {
		get { _storage._success ?? Pulsar_Proto_CommandSuccess() }
		set { _uniqueStorage()._success = newValue }
	}

	/// Returns true if `success` has been explicitly set.
	var hasSuccess: Bool { _storage._success != nil }
	/// Clears the value of `success`. Subsequent reads from it will return its default value.
	mutating func clearSuccess() { _uniqueStorage()._success = nil }

	var error: Pulsar_Proto_CommandError {
		get { _storage._error ?? Pulsar_Proto_CommandError() }
		set { _uniqueStorage()._error = newValue }
	}

	/// Returns true if `error` has been explicitly set.
	var hasError: Bool { _storage._error != nil }
	/// Clears the value of `error`. Subsequent reads from it will return its default value.
	mutating func clearError() { _uniqueStorage()._error = nil }

	var closeProducer: Pulsar_Proto_CommandCloseProducer {
		get { _storage._closeProducer ?? Pulsar_Proto_CommandCloseProducer() }
		set { _uniqueStorage()._closeProducer = newValue }
	}

	/// Returns true if `closeProducer` has been explicitly set.
	var hasCloseProducer: Bool { _storage._closeProducer != nil }
	/// Clears the value of `closeProducer`. Subsequent reads from it will return its default value.
	mutating func clearCloseProducer() { _uniqueStorage()._closeProducer = nil }

	var closeConsumer: Pulsar_Proto_CommandCloseConsumer {
		get { _storage._closeConsumer ?? Pulsar_Proto_CommandCloseConsumer() }
		set { _uniqueStorage()._closeConsumer = newValue }
	}

	/// Returns true if `closeConsumer` has been explicitly set.
	var hasCloseConsumer: Bool { _storage._closeConsumer != nil }
	/// Clears the value of `closeConsumer`. Subsequent reads from it will return its default value.
	mutating func clearCloseConsumer() { _uniqueStorage()._closeConsumer = nil }

	var producerSuccess: Pulsar_Proto_CommandProducerSuccess {
		get { _storage._producerSuccess ?? Pulsar_Proto_CommandProducerSuccess() }
		set { _uniqueStorage()._producerSuccess = newValue }
	}

	/// Returns true if `producerSuccess` has been explicitly set.
	var hasProducerSuccess: Bool { _storage._producerSuccess != nil }
	/// Clears the value of `producerSuccess`. Subsequent reads from it will return its default value.
	mutating func clearProducerSuccess() { _uniqueStorage()._producerSuccess = nil }

	var ping: Pulsar_Proto_CommandPing {
		get { _storage._ping ?? Pulsar_Proto_CommandPing() }
		set { _uniqueStorage()._ping = newValue }
	}

	/// Returns true if `ping` has been explicitly set.
	var hasPing: Bool { _storage._ping != nil }
	/// Clears the value of `ping`. Subsequent reads from it will return its default value.
	mutating func clearPing() { _uniqueStorage()._ping = nil }

	var pong: Pulsar_Proto_CommandPong {
		get { _storage._pong ?? Pulsar_Proto_CommandPong() }
		set { _uniqueStorage()._pong = newValue }
	}

	/// Returns true if `pong` has been explicitly set.
	var hasPong: Bool { _storage._pong != nil }
	/// Clears the value of `pong`. Subsequent reads from it will return its default value.
	mutating func clearPong() { _uniqueStorage()._pong = nil }

	var redeliverUnacknowledgedMessages: Pulsar_Proto_CommandRedeliverUnacknowledgedMessages {
		get { _storage._redeliverUnacknowledgedMessages ?? Pulsar_Proto_CommandRedeliverUnacknowledgedMessages() }
		set { _uniqueStorage()._redeliverUnacknowledgedMessages = newValue }
	}

	/// Returns true if `redeliverUnacknowledgedMessages` has been explicitly set.
	var hasRedeliverUnacknowledgedMessages: Bool { _storage._redeliverUnacknowledgedMessages != nil }
	/// Clears the value of `redeliverUnacknowledgedMessages`. Subsequent reads from it will return its default value.
	mutating func clearRedeliverUnacknowledgedMessages() { _uniqueStorage()._redeliverUnacknowledgedMessages = nil }

	var partitionMetadata: Pulsar_Proto_CommandPartitionedTopicMetadata {
		get { _storage._partitionMetadata ?? Pulsar_Proto_CommandPartitionedTopicMetadata() }
		set { _uniqueStorage()._partitionMetadata = newValue }
	}

	/// Returns true if `partitionMetadata` has been explicitly set.
	var hasPartitionMetadata: Bool { _storage._partitionMetadata != nil }
	/// Clears the value of `partitionMetadata`. Subsequent reads from it will return its default value.
	mutating func clearPartitionMetadata() { _uniqueStorage()._partitionMetadata = nil }

	var partitionMetadataResponse: Pulsar_Proto_CommandPartitionedTopicMetadataResponse {
		get { _storage._partitionMetadataResponse ?? Pulsar_Proto_CommandPartitionedTopicMetadataResponse() }
		set { _uniqueStorage()._partitionMetadataResponse = newValue }
	}

	/// Returns true if `partitionMetadataResponse` has been explicitly set.
	var hasPartitionMetadataResponse: Bool { _storage._partitionMetadataResponse != nil }
	/// Clears the value of `partitionMetadataResponse`. Subsequent reads from it will return its default value.
	mutating func clearPartitionMetadataResponse() { _uniqueStorage()._partitionMetadataResponse = nil }

	var lookupTopic: Pulsar_Proto_CommandLookupTopic {
		get { _storage._lookupTopic ?? Pulsar_Proto_CommandLookupTopic() }
		set { _uniqueStorage()._lookupTopic = newValue }
	}

	/// Returns true if `lookupTopic` has been explicitly set.
	var hasLookupTopic: Bool { _storage._lookupTopic != nil }
	/// Clears the value of `lookupTopic`. Subsequent reads from it will return its default value.
	mutating func clearLookupTopic() { _uniqueStorage()._lookupTopic = nil }

	var lookupTopicResponse: Pulsar_Proto_CommandLookupTopicResponse {
		get { _storage._lookupTopicResponse ?? Pulsar_Proto_CommandLookupTopicResponse() }
		set { _uniqueStorage()._lookupTopicResponse = newValue }
	}

	/// Returns true if `lookupTopicResponse` has been explicitly set.
	var hasLookupTopicResponse: Bool { _storage._lookupTopicResponse != nil }
	/// Clears the value of `lookupTopicResponse`. Subsequent reads from it will return its default value.
	mutating func clearLookupTopicResponse() { _uniqueStorage()._lookupTopicResponse = nil }

	var consumerStats: Pulsar_Proto_CommandConsumerStats {
		get { _storage._consumerStats ?? Pulsar_Proto_CommandConsumerStats() }
		set { _uniqueStorage()._consumerStats = newValue }
	}

	/// Returns true if `consumerStats` has been explicitly set.
	var hasConsumerStats: Bool { _storage._consumerStats != nil }
	/// Clears the value of `consumerStats`. Subsequent reads from it will return its default value.
	mutating func clearConsumerStats() { _uniqueStorage()._consumerStats = nil }

	var consumerStatsResponse: Pulsar_Proto_CommandConsumerStatsResponse {
		get { _storage._consumerStatsResponse ?? Pulsar_Proto_CommandConsumerStatsResponse() }
		set { _uniqueStorage()._consumerStatsResponse = newValue }
	}

	/// Returns true if `consumerStatsResponse` has been explicitly set.
	var hasConsumerStatsResponse: Bool { _storage._consumerStatsResponse != nil }
	/// Clears the value of `consumerStatsResponse`. Subsequent reads from it will return its default value.
	mutating func clearConsumerStatsResponse() { _uniqueStorage()._consumerStatsResponse = nil }

	var reachedEndOfTopic: Pulsar_Proto_CommandReachedEndOfTopic {
		get { _storage._reachedEndOfTopic ?? Pulsar_Proto_CommandReachedEndOfTopic() }
		set { _uniqueStorage()._reachedEndOfTopic = newValue }
	}

	/// Returns true if `reachedEndOfTopic` has been explicitly set.
	var hasReachedEndOfTopic: Bool { _storage._reachedEndOfTopic != nil }
	/// Clears the value of `reachedEndOfTopic`. Subsequent reads from it will return its default value.
	mutating func clearReachedEndOfTopic() { _uniqueStorage()._reachedEndOfTopic = nil }

	var seek: Pulsar_Proto_CommandSeek {
		get { _storage._seek ?? Pulsar_Proto_CommandSeek() }
		set { _uniqueStorage()._seek = newValue }
	}

	/// Returns true if `seek` has been explicitly set.
	var hasSeek: Bool { _storage._seek != nil }
	/// Clears the value of `seek`. Subsequent reads from it will return its default value.
	mutating func clearSeek() { _uniqueStorage()._seek = nil }

	var getLastMessageID: Pulsar_Proto_CommandGetLastMessageID {
		get { _storage._getLastMessageID ?? Pulsar_Proto_CommandGetLastMessageID() }
		set { _uniqueStorage()._getLastMessageID = newValue }
	}

	/// Returns true if `getLastMessageID` has been explicitly set.
	var hasGetLastMessageID: Bool { _storage._getLastMessageID != nil }
	/// Clears the value of `getLastMessageID`. Subsequent reads from it will return its default value.
	mutating func clearGetLastMessageID() { _uniqueStorage()._getLastMessageID = nil }

	var getLastMessageIDResponse: Pulsar_Proto_CommandGetLastMessageIDResponse {
		get { _storage._getLastMessageIDResponse ?? Pulsar_Proto_CommandGetLastMessageIDResponse() }
		set { _uniqueStorage()._getLastMessageIDResponse = newValue }
	}

	/// Returns true if `getLastMessageIDResponse` has been explicitly set.
	var hasGetLastMessageIDResponse: Bool { _storage._getLastMessageIDResponse != nil }
	/// Clears the value of `getLastMessageIDResponse`. Subsequent reads from it will return its default value.
	mutating func clearGetLastMessageIDResponse() { _uniqueStorage()._getLastMessageIDResponse = nil }

	var activeConsumerChange: Pulsar_Proto_CommandActiveConsumerChange {
		get { _storage._activeConsumerChange ?? Pulsar_Proto_CommandActiveConsumerChange() }
		set { _uniqueStorage()._activeConsumerChange = newValue }
	}

	/// Returns true if `activeConsumerChange` has been explicitly set.
	var hasActiveConsumerChange: Bool { _storage._activeConsumerChange != nil }
	/// Clears the value of `activeConsumerChange`. Subsequent reads from it will return its default value.
	mutating func clearActiveConsumerChange() { _uniqueStorage()._activeConsumerChange = nil }

	var getTopicsOfNamespace: Pulsar_Proto_CommandGetTopicsOfNamespace {
		get { _storage._getTopicsOfNamespace ?? Pulsar_Proto_CommandGetTopicsOfNamespace() }
		set { _uniqueStorage()._getTopicsOfNamespace = newValue }
	}

	/// Returns true if `getTopicsOfNamespace` has been explicitly set.
	var hasGetTopicsOfNamespace: Bool { _storage._getTopicsOfNamespace != nil }
	/// Clears the value of `getTopicsOfNamespace`. Subsequent reads from it will return its default value.
	mutating func clearGetTopicsOfNamespace() { _uniqueStorage()._getTopicsOfNamespace = nil }

	var getTopicsOfNamespaceResponse: Pulsar_Proto_CommandGetTopicsOfNamespaceResponse {
		get { _storage._getTopicsOfNamespaceResponse ?? Pulsar_Proto_CommandGetTopicsOfNamespaceResponse() }
		set { _uniqueStorage()._getTopicsOfNamespaceResponse = newValue }
	}

	/// Returns true if `getTopicsOfNamespaceResponse` has been explicitly set.
	var hasGetTopicsOfNamespaceResponse: Bool { _storage._getTopicsOfNamespaceResponse != nil }
	/// Clears the value of `getTopicsOfNamespaceResponse`. Subsequent reads from it will return its default value.
	mutating func clearGetTopicsOfNamespaceResponse() { _uniqueStorage()._getTopicsOfNamespaceResponse = nil }

	var getSchema: Pulsar_Proto_CommandGetSchema {
		get { _storage._getSchema ?? Pulsar_Proto_CommandGetSchema() }
		set { _uniqueStorage()._getSchema = newValue }
	}

	/// Returns true if `getSchema` has been explicitly set.
	var hasGetSchema: Bool { _storage._getSchema != nil }
	/// Clears the value of `getSchema`. Subsequent reads from it will return its default value.
	mutating func clearGetSchema() { _uniqueStorage()._getSchema = nil }

	var getSchemaResponse: Pulsar_Proto_CommandGetSchemaResponse {
		get { _storage._getSchemaResponse ?? Pulsar_Proto_CommandGetSchemaResponse() }
		set { _uniqueStorage()._getSchemaResponse = newValue }
	}

	/// Returns true if `getSchemaResponse` has been explicitly set.
	var hasGetSchemaResponse: Bool { _storage._getSchemaResponse != nil }
	/// Clears the value of `getSchemaResponse`. Subsequent reads from it will return its default value.
	mutating func clearGetSchemaResponse() { _uniqueStorage()._getSchemaResponse = nil }

	var authChallenge: Pulsar_Proto_CommandAuthChallenge {
		get { _storage._authChallenge ?? Pulsar_Proto_CommandAuthChallenge() }
		set { _uniqueStorage()._authChallenge = newValue }
	}

	/// Returns true if `authChallenge` has been explicitly set.
	var hasAuthChallenge: Bool { _storage._authChallenge != nil }
	/// Clears the value of `authChallenge`. Subsequent reads from it will return its default value.
	mutating func clearAuthChallenge() { _uniqueStorage()._authChallenge = nil }

	var authResponse: Pulsar_Proto_CommandAuthResponse {
		get { _storage._authResponse ?? Pulsar_Proto_CommandAuthResponse() }
		set { _uniqueStorage()._authResponse = newValue }
	}

	/// Returns true if `authResponse` has been explicitly set.
	var hasAuthResponse: Bool { _storage._authResponse != nil }
	/// Clears the value of `authResponse`. Subsequent reads from it will return its default value.
	mutating func clearAuthResponse() { _uniqueStorage()._authResponse = nil }

	var ackResponse: Pulsar_Proto_CommandAckResponse {
		get { _storage._ackResponse ?? Pulsar_Proto_CommandAckResponse() }
		set { _uniqueStorage()._ackResponse = newValue }
	}

	/// Returns true if `ackResponse` has been explicitly set.
	var hasAckResponse: Bool { _storage._ackResponse != nil }
	/// Clears the value of `ackResponse`. Subsequent reads from it will return its default value.
	mutating func clearAckResponse() { _uniqueStorage()._ackResponse = nil }

	var getOrCreateSchema: Pulsar_Proto_CommandGetOrCreateSchema {
		get { _storage._getOrCreateSchema ?? Pulsar_Proto_CommandGetOrCreateSchema() }
		set { _uniqueStorage()._getOrCreateSchema = newValue }
	}

	/// Returns true if `getOrCreateSchema` has been explicitly set.
	var hasGetOrCreateSchema: Bool { _storage._getOrCreateSchema != nil }
	/// Clears the value of `getOrCreateSchema`. Subsequent reads from it will return its default value.
	mutating func clearGetOrCreateSchema() { _uniqueStorage()._getOrCreateSchema = nil }

	var getOrCreateSchemaResponse: Pulsar_Proto_CommandGetOrCreateSchemaResponse {
		get { _storage._getOrCreateSchemaResponse ?? Pulsar_Proto_CommandGetOrCreateSchemaResponse() }
		set { _uniqueStorage()._getOrCreateSchemaResponse = newValue }
	}

	/// Returns true if `getOrCreateSchemaResponse` has been explicitly set.
	var hasGetOrCreateSchemaResponse: Bool { _storage._getOrCreateSchemaResponse != nil }
	/// Clears the value of `getOrCreateSchemaResponse`. Subsequent reads from it will return its default value.
	mutating func clearGetOrCreateSchemaResponse() { _uniqueStorage()._getOrCreateSchemaResponse = nil }

	/// transaction related
	var newTxn: Pulsar_Proto_CommandNewTxn {
		get { _storage._newTxn ?? Pulsar_Proto_CommandNewTxn() }
		set { _uniqueStorage()._newTxn = newValue }
	}

	/// Returns true if `newTxn` has been explicitly set.
	var hasNewTxn: Bool { _storage._newTxn != nil }
	/// Clears the value of `newTxn`. Subsequent reads from it will return its default value.
	mutating func clearNewTxn() { _uniqueStorage()._newTxn = nil }

	var newTxnResponse: Pulsar_Proto_CommandNewTxnResponse {
		get { _storage._newTxnResponse ?? Pulsar_Proto_CommandNewTxnResponse() }
		set { _uniqueStorage()._newTxnResponse = newValue }
	}

	/// Returns true if `newTxnResponse` has been explicitly set.
	var hasNewTxnResponse: Bool { _storage._newTxnResponse != nil }
	/// Clears the value of `newTxnResponse`. Subsequent reads from it will return its default value.
	mutating func clearNewTxnResponse() { _uniqueStorage()._newTxnResponse = nil }

	var addPartitionToTxn: Pulsar_Proto_CommandAddPartitionToTxn {
		get { _storage._addPartitionToTxn ?? Pulsar_Proto_CommandAddPartitionToTxn() }
		set { _uniqueStorage()._addPartitionToTxn = newValue }
	}

	/// Returns true if `addPartitionToTxn` has been explicitly set.
	var hasAddPartitionToTxn: Bool { _storage._addPartitionToTxn != nil }
	/// Clears the value of `addPartitionToTxn`. Subsequent reads from it will return its default value.
	mutating func clearAddPartitionToTxn() { _uniqueStorage()._addPartitionToTxn = nil }

	var addPartitionToTxnResponse: Pulsar_Proto_CommandAddPartitionToTxnResponse {
		get { _storage._addPartitionToTxnResponse ?? Pulsar_Proto_CommandAddPartitionToTxnResponse() }
		set { _uniqueStorage()._addPartitionToTxnResponse = newValue }
	}

	/// Returns true if `addPartitionToTxnResponse` has been explicitly set.
	var hasAddPartitionToTxnResponse: Bool { _storage._addPartitionToTxnResponse != nil }
	/// Clears the value of `addPartitionToTxnResponse`. Subsequent reads from it will return its default value.
	mutating func clearAddPartitionToTxnResponse() { _uniqueStorage()._addPartitionToTxnResponse = nil }

	var addSubscriptionToTxn: Pulsar_Proto_CommandAddSubscriptionToTxn {
		get { _storage._addSubscriptionToTxn ?? Pulsar_Proto_CommandAddSubscriptionToTxn() }
		set { _uniqueStorage()._addSubscriptionToTxn = newValue }
	}

	/// Returns true if `addSubscriptionToTxn` has been explicitly set.
	var hasAddSubscriptionToTxn: Bool { _storage._addSubscriptionToTxn != nil }
	/// Clears the value of `addSubscriptionToTxn`. Subsequent reads from it will return its default value.
	mutating func clearAddSubscriptionToTxn() { _uniqueStorage()._addSubscriptionToTxn = nil }

	var addSubscriptionToTxnResponse: Pulsar_Proto_CommandAddSubscriptionToTxnResponse {
		get { _storage._addSubscriptionToTxnResponse ?? Pulsar_Proto_CommandAddSubscriptionToTxnResponse() }
		set { _uniqueStorage()._addSubscriptionToTxnResponse = newValue }
	}

	/// Returns true if `addSubscriptionToTxnResponse` has been explicitly set.
	var hasAddSubscriptionToTxnResponse: Bool { _storage._addSubscriptionToTxnResponse != nil }
	/// Clears the value of `addSubscriptionToTxnResponse`. Subsequent reads from it will return its default value.
	mutating func clearAddSubscriptionToTxnResponse() { _uniqueStorage()._addSubscriptionToTxnResponse = nil }

	var endTxn: Pulsar_Proto_CommandEndTxn {
		get { _storage._endTxn ?? Pulsar_Proto_CommandEndTxn() }
		set { _uniqueStorage()._endTxn = newValue }
	}

	/// Returns true if `endTxn` has been explicitly set.
	var hasEndTxn: Bool { _storage._endTxn != nil }
	/// Clears the value of `endTxn`. Subsequent reads from it will return its default value.
	mutating func clearEndTxn() { _uniqueStorage()._endTxn = nil }

	var endTxnResponse: Pulsar_Proto_CommandEndTxnResponse {
		get { _storage._endTxnResponse ?? Pulsar_Proto_CommandEndTxnResponse() }
		set { _uniqueStorage()._endTxnResponse = newValue }
	}

	/// Returns true if `endTxnResponse` has been explicitly set.
	var hasEndTxnResponse: Bool { _storage._endTxnResponse != nil }
	/// Clears the value of `endTxnResponse`. Subsequent reads from it will return its default value.
	mutating func clearEndTxnResponse() { _uniqueStorage()._endTxnResponse = nil }

	var endTxnOnPartition: Pulsar_Proto_CommandEndTxnOnPartition {
		get { _storage._endTxnOnPartition ?? Pulsar_Proto_CommandEndTxnOnPartition() }
		set { _uniqueStorage()._endTxnOnPartition = newValue }
	}

	/// Returns true if `endTxnOnPartition` has been explicitly set.
	var hasEndTxnOnPartition: Bool { _storage._endTxnOnPartition != nil }
	/// Clears the value of `endTxnOnPartition`. Subsequent reads from it will return its default value.
	mutating func clearEndTxnOnPartition() { _uniqueStorage()._endTxnOnPartition = nil }

	var endTxnOnPartitionResponse: Pulsar_Proto_CommandEndTxnOnPartitionResponse {
		get { _storage._endTxnOnPartitionResponse ?? Pulsar_Proto_CommandEndTxnOnPartitionResponse() }
		set { _uniqueStorage()._endTxnOnPartitionResponse = newValue }
	}

	/// Returns true if `endTxnOnPartitionResponse` has been explicitly set.
	var hasEndTxnOnPartitionResponse: Bool { _storage._endTxnOnPartitionResponse != nil }
	/// Clears the value of `endTxnOnPartitionResponse`. Subsequent reads from it will return its default value.
	mutating func clearEndTxnOnPartitionResponse() { _uniqueStorage()._endTxnOnPartitionResponse = nil }

	var endTxnOnSubscription: Pulsar_Proto_CommandEndTxnOnSubscription {
		get { _storage._endTxnOnSubscription ?? Pulsar_Proto_CommandEndTxnOnSubscription() }
		set { _uniqueStorage()._endTxnOnSubscription = newValue }
	}

	/// Returns true if `endTxnOnSubscription` has been explicitly set.
	var hasEndTxnOnSubscription: Bool { _storage._endTxnOnSubscription != nil }
	/// Clears the value of `endTxnOnSubscription`. Subsequent reads from it will return its default value.
	mutating func clearEndTxnOnSubscription() { _uniqueStorage()._endTxnOnSubscription = nil }

	var endTxnOnSubscriptionResponse: Pulsar_Proto_CommandEndTxnOnSubscriptionResponse {
		get { _storage._endTxnOnSubscriptionResponse ?? Pulsar_Proto_CommandEndTxnOnSubscriptionResponse() }
		set { _uniqueStorage()._endTxnOnSubscriptionResponse = newValue }
	}

	/// Returns true if `endTxnOnSubscriptionResponse` has been explicitly set.
	var hasEndTxnOnSubscriptionResponse: Bool { _storage._endTxnOnSubscriptionResponse != nil }
	/// Clears the value of `endTxnOnSubscriptionResponse`. Subsequent reads from it will return its default value.
	mutating func clearEndTxnOnSubscriptionResponse() { _uniqueStorage()._endTxnOnSubscriptionResponse = nil }

	var tcClientConnectRequest: Pulsar_Proto_CommandTcClientConnectRequest {
		get { _storage._tcClientConnectRequest ?? Pulsar_Proto_CommandTcClientConnectRequest() }
		set { _uniqueStorage()._tcClientConnectRequest = newValue }
	}

	/// Returns true if `tcClientConnectRequest` has been explicitly set.
	var hasTcClientConnectRequest: Bool { _storage._tcClientConnectRequest != nil }
	/// Clears the value of `tcClientConnectRequest`. Subsequent reads from it will return its default value.
	mutating func clearTcClientConnectRequest() { _uniqueStorage()._tcClientConnectRequest = nil }

	var tcClientConnectResponse: Pulsar_Proto_CommandTcClientConnectResponse {
		get { _storage._tcClientConnectResponse ?? Pulsar_Proto_CommandTcClientConnectResponse() }
		set { _uniqueStorage()._tcClientConnectResponse = newValue }
	}

	/// Returns true if `tcClientConnectResponse` has been explicitly set.
	var hasTcClientConnectResponse: Bool { _storage._tcClientConnectResponse != nil }
	/// Clears the value of `tcClientConnectResponse`. Subsequent reads from it will return its default value.
	mutating func clearTcClientConnectResponse() { _uniqueStorage()._tcClientConnectResponse = nil }

	var watchTopicList: Pulsar_Proto_CommandWatchTopicList {
		get { _storage._watchTopicList ?? Pulsar_Proto_CommandWatchTopicList() }
		set { _uniqueStorage()._watchTopicList = newValue }
	}

	/// Returns true if `watchTopicList` has been explicitly set.
	var hasWatchTopicList: Bool { _storage._watchTopicList != nil }
	/// Clears the value of `watchTopicList`. Subsequent reads from it will return its default value.
	mutating func clearWatchTopicList() { _uniqueStorage()._watchTopicList = nil }

	var watchTopicListSuccess: Pulsar_Proto_CommandWatchTopicListSuccess {
		get { _storage._watchTopicListSuccess ?? Pulsar_Proto_CommandWatchTopicListSuccess() }
		set { _uniqueStorage()._watchTopicListSuccess = newValue }
	}

	/// Returns true if `watchTopicListSuccess` has been explicitly set.
	var hasWatchTopicListSuccess: Bool { _storage._watchTopicListSuccess != nil }
	/// Clears the value of `watchTopicListSuccess`. Subsequent reads from it will return its default value.
	mutating func clearWatchTopicListSuccess() { _uniqueStorage()._watchTopicListSuccess = nil }

	var watchTopicUpdate: Pulsar_Proto_CommandWatchTopicUpdate {
		get { _storage._watchTopicUpdate ?? Pulsar_Proto_CommandWatchTopicUpdate() }
		set { _uniqueStorage()._watchTopicUpdate = newValue }
	}

	/// Returns true if `watchTopicUpdate` has been explicitly set.
	var hasWatchTopicUpdate: Bool { _storage._watchTopicUpdate != nil }
	/// Clears the value of `watchTopicUpdate`. Subsequent reads from it will return its default value.
	mutating func clearWatchTopicUpdate() { _uniqueStorage()._watchTopicUpdate = nil }

	var watchTopicListClose: Pulsar_Proto_CommandWatchTopicListClose {
		get { _storage._watchTopicListClose ?? Pulsar_Proto_CommandWatchTopicListClose() }
		set { _uniqueStorage()._watchTopicListClose = newValue }
	}

	/// Returns true if `watchTopicListClose` has been explicitly set.
	var hasWatchTopicListClose: Bool { _storage._watchTopicListClose != nil }
	/// Clears the value of `watchTopicListClose`. Subsequent reads from it will return its default value.
	mutating func clearWatchTopicListClose() { _uniqueStorage()._watchTopicListClose = nil }

	var topicMigrated: Pulsar_Proto_CommandTopicMigrated {
		get { _storage._topicMigrated ?? Pulsar_Proto_CommandTopicMigrated() }
		set { _uniqueStorage()._topicMigrated = newValue }
	}

	/// Returns true if `topicMigrated` has been explicitly set.
	var hasTopicMigrated: Bool { _storage._topicMigrated != nil }
	/// Clears the value of `topicMigrated`. Subsequent reads from it will return its default value.
	mutating func clearTopicMigrated() { _uniqueStorage()._topicMigrated = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
		typealias RawValue = Int
		case connect // = 2
		case connected // = 3
		case subscribe // = 4
		case producer // = 5
		case send // = 6
		case sendReceipt // = 7
		case sendError // = 8
		case message // = 9
		case ack // = 10
		case flow // = 11
		case unsubscribe // = 12
		case success // = 13
		case error // = 14
		case closeProducer // = 15
		case closeConsumer // = 16
		case producerSuccess // = 17
		case ping // = 18
		case pong // = 19
		case redeliverUnacknowledgedMessages // = 20
		case partitionedMetadata // = 21
		case partitionedMetadataResponse // = 22
		case lookup // = 23
		case lookupResponse // = 24
		case consumerStats // = 25
		case consumerStatsResponse // = 26
		case reachedEndOfTopic // = 27
		case seek // = 28
		case getLastMessageID // = 29
		case getLastMessageIDResponse // = 30
		case activeConsumerChange // = 31
		case getTopicsOfNamespace // = 32
		case getTopicsOfNamespaceResponse // = 33
		case getSchema // = 34
		case getSchemaResponse // = 35
		case authChallenge // = 36
		case authResponse // = 37
		case ackResponse // = 38
		case getOrCreateSchema // = 39
		case getOrCreateSchemaResponse // = 40

		/// transaction related
		case newTxn // = 50
		case newTxnResponse // = 51
		case addPartitionToTxn // = 52
		case addPartitionToTxnResponse // = 53
		case addSubscriptionToTxn // = 54
		case addSubscriptionToTxnResponse // = 55
		case endTxn // = 56
		case endTxnResponse // = 57
		case endTxnOnPartition // = 58
		case endTxnOnPartitionResponse // = 59
		case endTxnOnSubscription // = 60
		case endTxnOnSubscriptionResponse // = 61
		case tcClientConnectRequest // = 62
		case tcClientConnectResponse // = 63
		case watchTopicList // = 64
		case watchTopicListSuccess // = 65
		case watchTopicUpdate // = 66
		case watchTopicListClose // = 67
		case topicMigrated // = 68

		init() {
			self = .connect
		}

		init?(rawValue: Int) {
			switch rawValue {
				case 2: self = .connect
				case 3: self = .connected
				case 4: self = .subscribe
				case 5: self = .producer
				case 6: self = .send
				case 7: self = .sendReceipt
				case 8: self = .sendError
				case 9: self = .message
				case 10: self = .ack
				case 11: self = .flow
				case 12: self = .unsubscribe
				case 13: self = .success
				case 14: self = .error
				case 15: self = .closeProducer
				case 16: self = .closeConsumer
				case 17: self = .producerSuccess
				case 18: self = .ping
				case 19: self = .pong
				case 20: self = .redeliverUnacknowledgedMessages
				case 21: self = .partitionedMetadata
				case 22: self = .partitionedMetadataResponse
				case 23: self = .lookup
				case 24: self = .lookupResponse
				case 25: self = .consumerStats
				case 26: self = .consumerStatsResponse
				case 27: self = .reachedEndOfTopic
				case 28: self = .seek
				case 29: self = .getLastMessageID
				case 30: self = .getLastMessageIDResponse
				case 31: self = .activeConsumerChange
				case 32: self = .getTopicsOfNamespace
				case 33: self = .getTopicsOfNamespaceResponse
				case 34: self = .getSchema
				case 35: self = .getSchemaResponse
				case 36: self = .authChallenge
				case 37: self = .authResponse
				case 38: self = .ackResponse
				case 39: self = .getOrCreateSchema
				case 40: self = .getOrCreateSchemaResponse
				case 50: self = .newTxn
				case 51: self = .newTxnResponse
				case 52: self = .addPartitionToTxn
				case 53: self = .addPartitionToTxnResponse
				case 54: self = .addSubscriptionToTxn
				case 55: self = .addSubscriptionToTxnResponse
				case 56: self = .endTxn
				case 57: self = .endTxnResponse
				case 58: self = .endTxnOnPartition
				case 59: self = .endTxnOnPartitionResponse
				case 60: self = .endTxnOnSubscription
				case 61: self = .endTxnOnSubscriptionResponse
				case 62: self = .tcClientConnectRequest
				case 63: self = .tcClientConnectResponse
				case 64: self = .watchTopicList
				case 65: self = .watchTopicListSuccess
				case 66: self = .watchTopicUpdate
				case 67: self = .watchTopicListClose
				case 68: self = .topicMigrated
				default: return nil
			}
		}

		var rawValue: Int {
			switch self {
				case .connect: 2
				case .connected: 3
				case .subscribe: 4
				case .producer: 5
				case .send: 6
				case .sendReceipt: 7
				case .sendError: 8
				case .message: 9
				case .ack: 10
				case .flow: 11
				case .unsubscribe: 12
				case .success: 13
				case .error: 14
				case .closeProducer: 15
				case .closeConsumer: 16
				case .producerSuccess: 17
				case .ping: 18
				case .pong: 19
				case .redeliverUnacknowledgedMessages: 20
				case .partitionedMetadata: 21
				case .partitionedMetadataResponse: 22
				case .lookup: 23
				case .lookupResponse: 24
				case .consumerStats: 25
				case .consumerStatsResponse: 26
				case .reachedEndOfTopic: 27
				case .seek: 28
				case .getLastMessageID: 29
				case .getLastMessageIDResponse: 30
				case .activeConsumerChange: 31
				case .getTopicsOfNamespace: 32
				case .getTopicsOfNamespaceResponse: 33
				case .getSchema: 34
				case .getSchemaResponse: 35
				case .authChallenge: 36
				case .authResponse: 37
				case .ackResponse: 38
				case .getOrCreateSchema: 39
				case .getOrCreateSchemaResponse: 40
				case .newTxn: 50
				case .newTxnResponse: 51
				case .addPartitionToTxn: 52
				case .addPartitionToTxnResponse: 53
				case .addSubscriptionToTxn: 54
				case .addSubscriptionToTxnResponse: 55
				case .endTxn: 56
				case .endTxnResponse: 57
				case .endTxnOnPartition: 58
				case .endTxnOnPartitionResponse: 59
				case .endTxnOnSubscription: 60
				case .endTxnOnSubscriptionResponse: 61
				case .tcClientConnectRequest: 62
				case .tcClientConnectResponse: 63
				case .watchTopicList: 64
				case .watchTopicListSuccess: 65
				case .watchTopicUpdate: 66
				case .watchTopicListClose: 67
				case .topicMigrated: 68
			}
		}
	}

	init() { }

	fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "pulsar.proto"

extension Pulsar_Proto_CompressionType: SwiftProtobuf._ProtoNameProviding {
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		0: .same(proto: "NONE"),
		1: .same(proto: "LZ4"),
		2: .same(proto: "ZLIB"),
		3: .same(proto: "ZSTD"),
		4: .same(proto: "SNAPPY")
	]
}

extension Pulsar_Proto_ProducerAccessMode: SwiftProtobuf._ProtoNameProviding {
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		0: .same(proto: "Shared"),
		1: .same(proto: "Exclusive"),
		2: .same(proto: "WaitForExclusive"),
		3: .same(proto: "ExclusiveWithFencing")
	]
}

extension Pulsar_Proto_ServerError: SwiftProtobuf._ProtoNameProviding {
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		0: .same(proto: "UnknownError"),
		1: .same(proto: "MetadataError"),
		2: .same(proto: "PersistenceError"),
		3: .same(proto: "AuthenticationError"),
		4: .same(proto: "AuthorizationError"),
		5: .same(proto: "ConsumerBusy"),
		6: .same(proto: "ServiceNotReady"),
		7: .same(proto: "ProducerBlockedQuotaExceededError"),
		8: .same(proto: "ProducerBlockedQuotaExceededException"),
		9: .same(proto: "ChecksumError"),
		10: .same(proto: "UnsupportedVersionError"),
		11: .same(proto: "TopicNotFound"),
		12: .same(proto: "SubscriptionNotFound"),
		13: .same(proto: "ConsumerNotFound"),
		14: .same(proto: "TooManyRequests"),
		15: .same(proto: "TopicTerminatedError"),
		16: .same(proto: "ProducerBusy"),
		17: .same(proto: "InvalidTopicName"),
		18: .same(proto: "IncompatibleSchema"),
		19: .same(proto: "ConsumerAssignError"),
		20: .same(proto: "TransactionCoordinatorNotFound"),
		21: .same(proto: "InvalidTxnStatus"),
		22: .same(proto: "NotAllowedError"),
		23: .same(proto: "TransactionConflict"),
		24: .same(proto: "TransactionNotFound"),
		25: .same(proto: "ProducerFenced")
	]
}

extension Pulsar_Proto_AuthMethod: SwiftProtobuf._ProtoNameProviding {
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		0: .same(proto: "AuthMethodNone"),
		1: .same(proto: "AuthMethodYcaV1"),
		2: .same(proto: "AuthMethodAthens")
	]
}

extension Pulsar_Proto_ProtocolVersion: SwiftProtobuf._ProtoNameProviding {
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		0: .same(proto: "v0"),
		1: .same(proto: "v1"),
		2: .same(proto: "v2"),
		3: .same(proto: "v3"),
		4: .same(proto: "v4"),
		5: .same(proto: "v5"),
		6: .same(proto: "v6"),
		7: .same(proto: "v7"),
		8: .same(proto: "v8"),
		9: .same(proto: "v9"),
		10: .same(proto: "v10"),
		11: .same(proto: "v11"),
		12: .same(proto: "v12"),
		13: .same(proto: "v13"),
		14: .same(proto: "v14"),
		15: .same(proto: "v15"),
		16: .same(proto: "v16"),
		17: .same(proto: "v17"),
		18: .same(proto: "v18"),
		19: .same(proto: "v19"),
		20: .same(proto: "v20"),
		21: .same(proto: "v21")
	]
}

extension Pulsar_Proto_KeySharedMode: SwiftProtobuf._ProtoNameProviding {
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		0: .same(proto: "AUTO_SPLIT"),
		1: .same(proto: "STICKY")
	]
}

extension Pulsar_Proto_TxnAction: SwiftProtobuf._ProtoNameProviding {
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		0: .same(proto: "COMMIT"),
		1: .same(proto: "ABORT")
	]
}

extension Pulsar_Proto_Schema: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".Schema"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .same(proto: "name"),
		3: .standard(proto: "schema_data"),
		4: .same(proto: "type"),
		5: .same(proto: "properties")
	]

	public var isInitialized: Bool {
		if _name == nil {
			return false
		}
		if _schemaData == nil {
			return false
		}
		if _type == nil {
			return false
		}
		if !SwiftProtobuf.Internal.areAllInitialized(properties) {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularStringField(value: &_name)
				case 3: try decoder.decodeSingularBytesField(value: &_schemaData)
				case 4: try decoder.decodeSingularEnumField(value: &_type)
				case 5: try decoder.decodeRepeatedMessageField(value: &properties)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _name {
			try visitor.visitSingularStringField(value: v, fieldNumber: 1)
		}
		try { if let v = self._schemaData {
			try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._type {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
		} }()
		if !properties.isEmpty {
			try visitor.visitRepeatedMessageField(value: properties, fieldNumber: 5)
		}
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_Schema, rhs: Pulsar_Proto_Schema) -> Bool {
		if lhs._name != rhs._name {
			return false
		}
		if lhs._schemaData != rhs._schemaData {
			return false
		}
		if lhs._type != rhs._type {
			return false
		}
		if lhs.properties != rhs.properties {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_Schema.TypeEnum: SwiftProtobuf._ProtoNameProviding {
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		0: .same(proto: "None"),
		1: .same(proto: "String"),
		2: .same(proto: "Json"),
		3: .same(proto: "Protobuf"),
		4: .same(proto: "Avro"),
		5: .same(proto: "Bool"),
		6: .same(proto: "Int8"),
		7: .same(proto: "Int16"),
		8: .same(proto: "Int32"),
		9: .same(proto: "Int64"),
		10: .same(proto: "Float"),
		11: .same(proto: "Double"),
		12: .same(proto: "Date"),
		13: .same(proto: "Time"),
		14: .same(proto: "Timestamp"),
		15: .same(proto: "KeyValue"),
		16: .same(proto: "Instant"),
		17: .same(proto: "LocalDate"),
		18: .same(proto: "LocalTime"),
		19: .same(proto: "LocalDateTime"),
		20: .same(proto: "ProtobufNative"),
		21: .same(proto: "AutoConsume")
	]
}

extension Pulsar_Proto_MessageIDData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".MessageIdData"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .same(proto: "ledgerId"),
		2: .same(proto: "entryId"),
		3: .same(proto: "partition"),
		4: .standard(proto: "batch_index"),
		5: .standard(proto: "ack_set"),
		6: .standard(proto: "batch_size"),
		7: .standard(proto: "first_chunk_message_id")
	]

	fileprivate class _StorageClass {
		var _ledgerID: UInt64?
		var _entryID: UInt64?
		var _partition: Int32?
		var _batchIndex: Int32?
		var _ackSet: [Int64] = []
		var _batchSize: Int32?
		var _firstChunkMessageID: Pulsar_Proto_MessageIDData?

		#if swift(>=5.10)
			// This property is used as the initial default value for new instances of the type.
			// The type itself is protecting the reference to its storage via CoW semantics.
			// This will force a copy to be made of this reference when the first mutation occurs;
			// hence, it is safe to mark this as `nonisolated(unsafe)`.
			nonisolated(unsafe) static let defaultInstance = _StorageClass()
		#else
			static let defaultInstance = _StorageClass()
		#endif

		private init() { }

		init(copying source: _StorageClass) {
			_ledgerID = source._ledgerID
			_entryID = source._entryID
			_partition = source._partition
			_batchIndex = source._batchIndex
			_ackSet = source._ackSet
			_batchSize = source._batchSize
			_firstChunkMessageID = source._firstChunkMessageID
		}
	}

	fileprivate mutating func _uniqueStorage() -> _StorageClass {
		if !isKnownUniquelyReferenced(&_storage) {
			_storage = _StorageClass(copying: _storage)
		}
		return _storage
	}

	public var isInitialized: Bool {
		withExtendedLifetime(_storage) { (_storage: _StorageClass) in
			if _storage._ledgerID == nil {
				return false
			}
			if _storage._entryID == nil {
				return false
			}
			if let v = _storage._firstChunkMessageID, !v.isInitialized {
				return false
			}
			return true
		}
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		_ = _uniqueStorage()
		try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
			while let fieldNumber = try decoder.nextFieldNumber() {
				// The use of inline closures is to circumvent an issue where the compiler
				// allocates stack space for every case branch when no optimizations are
				// enabled. https://github.com/apple/swift-protobuf/issues/1034
				switch fieldNumber {
					case 1: try decoder.decodeSingularUInt64Field(value: &_storage._ledgerID)
					case 2: try decoder.decodeSingularUInt64Field(value: &_storage._entryID)
					case 3: try decoder.decodeSingularInt32Field(value: &_storage._partition)
					case 4: try decoder.decodeSingularInt32Field(value: &_storage._batchIndex)
					case 5: try decoder.decodeRepeatedInt64Field(value: &_storage._ackSet)
					case 6: try decoder.decodeSingularInt32Field(value: &_storage._batchSize)
					case 7: try decoder.decodeSingularMessageField(value: &_storage._firstChunkMessageID)
					default: break
				}
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every if/case branch local when no optimizations
			// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
			// https://github.com/apple/swift-protobuf/issues/1182
			try { if let v = _storage._ledgerID {
				try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
			} }()
			try { if let v = _storage._entryID {
				try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
			} }()
			try { if let v = _storage._partition {
				try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
			} }()
			try { if let v = _storage._batchIndex {
				try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
			} }()
			if !_storage._ackSet.isEmpty {
				try visitor.visitRepeatedInt64Field(value: _storage._ackSet, fieldNumber: 5)
			}
			try { if let v = _storage._batchSize {
				try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
			} }()
			try { if let v = _storage._firstChunkMessageID {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
			} }()
		}
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_MessageIDData, rhs: Pulsar_Proto_MessageIDData) -> Bool {
		if lhs._storage !== rhs._storage {
			let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
				let _storage = _args.0
				let rhs_storage = _args.1
				if _storage._ledgerID != rhs_storage._ledgerID {
					return false
				}
				if _storage._entryID != rhs_storage._entryID {
					return false
				}
				if _storage._partition != rhs_storage._partition {
					return false
				}
				if _storage._batchIndex != rhs_storage._batchIndex {
					return false
				}
				if _storage._ackSet != rhs_storage._ackSet {
					return false
				}
				if _storage._batchSize != rhs_storage._batchSize {
					return false
				}
				if _storage._firstChunkMessageID != rhs_storage._firstChunkMessageID {
					return false
				}
				return true
			}
			if !storagesAreEqual {
				return false
			}
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_KeyValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".KeyValue"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .same(proto: "key"),
		2: .same(proto: "value")
	]

	public var isInitialized: Bool {
		if _key == nil {
			return false
		}
		if _value == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularStringField(value: &_key)
				case 2: try decoder.decodeSingularStringField(value: &_value)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _key {
			try visitor.visitSingularStringField(value: v, fieldNumber: 1)
		}
		try { if let v = self._value {
			try visitor.visitSingularStringField(value: v, fieldNumber: 2)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_KeyValue, rhs: Pulsar_Proto_KeyValue) -> Bool {
		if lhs._key != rhs._key {
			return false
		}
		if lhs._value != rhs._value {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_KeyLongValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".KeyLongValue"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .same(proto: "key"),
		2: .same(proto: "value")
	]

	public var isInitialized: Bool {
		if _key == nil {
			return false
		}
		if _value == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularStringField(value: &_key)
				case 2: try decoder.decodeSingularUInt64Field(value: &_value)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _key {
			try visitor.visitSingularStringField(value: v, fieldNumber: 1)
		}
		try { if let v = self._value {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_KeyLongValue, rhs: Pulsar_Proto_KeyLongValue) -> Bool {
		if lhs._key != rhs._key {
			return false
		}
		if lhs._value != rhs._value {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_IntRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".IntRange"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .same(proto: "start"),
		2: .same(proto: "end")
	]

	public var isInitialized: Bool {
		if _start == nil {
			return false
		}
		if _end == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularInt32Field(value: &_start)
				case 2: try decoder.decodeSingularInt32Field(value: &_end)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _start {
			try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._end {
			try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_IntRange, rhs: Pulsar_Proto_IntRange) -> Bool {
		if lhs._start != rhs._start {
			return false
		}
		if lhs._end != rhs._end {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_EncryptionKeys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".EncryptionKeys"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .same(proto: "key"),
		2: .same(proto: "value"),
		3: .same(proto: "metadata")
	]

	public var isInitialized: Bool {
		if _key == nil {
			return false
		}
		if _value == nil {
			return false
		}
		if !SwiftProtobuf.Internal.areAllInitialized(metadata) {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularStringField(value: &_key)
				case 2: try decoder.decodeSingularBytesField(value: &_value)
				case 3: try decoder.decodeRepeatedMessageField(value: &metadata)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _key {
			try visitor.visitSingularStringField(value: v, fieldNumber: 1)
		}
		try { if let v = self._value {
			try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
		} }()
		if !metadata.isEmpty {
			try visitor.visitRepeatedMessageField(value: metadata, fieldNumber: 3)
		}
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_EncryptionKeys, rhs: Pulsar_Proto_EncryptionKeys) -> Bool {
		if lhs._key != rhs._key {
			return false
		}
		if lhs._value != rhs._value {
			return false
		}
		if lhs.metadata != rhs.metadata {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_MessageMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".MessageMetadata"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "producer_name"),
		2: .standard(proto: "sequence_id"),
		3: .standard(proto: "publish_time"),
		4: .same(proto: "properties"),
		5: .standard(proto: "replicated_from"),
		6: .standard(proto: "partition_key"),
		7: .standard(proto: "replicate_to"),
		8: .same(proto: "compression"),
		9: .standard(proto: "uncompressed_size"),
		11: .standard(proto: "num_messages_in_batch"),
		12: .standard(proto: "event_time"),
		13: .standard(proto: "encryption_keys"),
		14: .standard(proto: "encryption_algo"),
		15: .standard(proto: "encryption_param"),
		16: .standard(proto: "schema_version"),
		17: .standard(proto: "partition_key_b64_encoded"),
		18: .standard(proto: "ordering_key"),
		19: .standard(proto: "deliver_at_time"),
		20: .standard(proto: "marker_type"),
		22: .standard(proto: "txnid_least_bits"),
		23: .standard(proto: "txnid_most_bits"),
		24: .standard(proto: "highest_sequence_id"),
		25: .standard(proto: "null_value"),
		26: .same(proto: "uuid"),
		27: .standard(proto: "num_chunks_from_msg"),
		28: .standard(proto: "total_chunk_msg_size"),
		29: .standard(proto: "chunk_id"),
		30: .standard(proto: "null_partition_key")
	]

	fileprivate class _StorageClass {
		var _producerName: String?
		var _sequenceID: UInt64?
		var _publishTime: UInt64?
		var _properties: [Pulsar_Proto_KeyValue] = []
		var _replicatedFrom: String?
		var _partitionKey: String?
		var _replicateTo: [String] = []
		var _compression: Pulsar_Proto_CompressionType?
		var _uncompressedSize: UInt32?
		var _numMessagesInBatch: Int32?
		var _eventTime: UInt64?
		var _encryptionKeys: [Pulsar_Proto_EncryptionKeys] = []
		var _encryptionAlgo: String?
		var _encryptionParam: Data?
		var _schemaVersion: Data?
		var _partitionKeyB64Encoded: Bool?
		var _orderingKey: Data?
		var _deliverAtTime: Int64?
		var _markerType: Int32?
		var _txnidLeastBits: UInt64?
		var _txnidMostBits: UInt64?
		var _highestSequenceID: UInt64?
		var _nullValue: Bool?
		var _uuid: String?
		var _numChunksFromMsg: Int32?
		var _totalChunkMsgSize: Int32?
		var _chunkID: Int32?
		var _nullPartitionKey: Bool?

		#if swift(>=5.10)
			// This property is used as the initial default value for new instances of the type.
			// The type itself is protecting the reference to its storage via CoW semantics.
			// This will force a copy to be made of this reference when the first mutation occurs;
			// hence, it is safe to mark this as `nonisolated(unsafe)`.
			nonisolated(unsafe) static let defaultInstance = _StorageClass()
		#else
			static let defaultInstance = _StorageClass()
		#endif

		private init() { }

		init(copying source: _StorageClass) {
			_producerName = source._producerName
			_sequenceID = source._sequenceID
			_publishTime = source._publishTime
			_properties = source._properties
			_replicatedFrom = source._replicatedFrom
			_partitionKey = source._partitionKey
			_replicateTo = source._replicateTo
			_compression = source._compression
			_uncompressedSize = source._uncompressedSize
			_numMessagesInBatch = source._numMessagesInBatch
			_eventTime = source._eventTime
			_encryptionKeys = source._encryptionKeys
			_encryptionAlgo = source._encryptionAlgo
			_encryptionParam = source._encryptionParam
			_schemaVersion = source._schemaVersion
			_partitionKeyB64Encoded = source._partitionKeyB64Encoded
			_orderingKey = source._orderingKey
			_deliverAtTime = source._deliverAtTime
			_markerType = source._markerType
			_txnidLeastBits = source._txnidLeastBits
			_txnidMostBits = source._txnidMostBits
			_highestSequenceID = source._highestSequenceID
			_nullValue = source._nullValue
			_uuid = source._uuid
			_numChunksFromMsg = source._numChunksFromMsg
			_totalChunkMsgSize = source._totalChunkMsgSize
			_chunkID = source._chunkID
			_nullPartitionKey = source._nullPartitionKey
		}
	}

	fileprivate mutating func _uniqueStorage() -> _StorageClass {
		if !isKnownUniquelyReferenced(&_storage) {
			_storage = _StorageClass(copying: _storage)
		}
		return _storage
	}

	public var isInitialized: Bool {
		withExtendedLifetime(_storage) { (_storage: _StorageClass) in
			if _storage._producerName == nil {
				return false
			}
			if _storage._sequenceID == nil {
				return false
			}
			if _storage._publishTime == nil {
				return false
			}
			if !SwiftProtobuf.Internal.areAllInitialized(_storage._properties) {
				return false
			}
			if !SwiftProtobuf.Internal.areAllInitialized(_storage._encryptionKeys) {
				return false
			}
			return true
		}
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		_ = _uniqueStorage()
		try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
			while let fieldNumber = try decoder.nextFieldNumber() {
				// The use of inline closures is to circumvent an issue where the compiler
				// allocates stack space for every case branch when no optimizations are
				// enabled. https://github.com/apple/swift-protobuf/issues/1034
				switch fieldNumber {
					case 1: try decoder.decodeSingularStringField(value: &_storage._producerName)
					case 2: try decoder.decodeSingularUInt64Field(value: &_storage._sequenceID)
					case 3: try decoder.decodeSingularUInt64Field(value: &_storage._publishTime)
					case 4: try decoder.decodeRepeatedMessageField(value: &_storage._properties)
					case 5: try decoder.decodeSingularStringField(value: &_storage._replicatedFrom)
					case 6: try decoder.decodeSingularStringField(value: &_storage._partitionKey)
					case 7: try decoder.decodeRepeatedStringField(value: &_storage._replicateTo)
					case 8: try decoder.decodeSingularEnumField(value: &_storage._compression)
					case 9: try decoder.decodeSingularUInt32Field(value: &_storage._uncompressedSize)
					case 11: try decoder.decodeSingularInt32Field(value: &_storage._numMessagesInBatch)
					case 12: try decoder.decodeSingularUInt64Field(value: &_storage._eventTime)
					case 13: try decoder.decodeRepeatedMessageField(value: &_storage._encryptionKeys)
					case 14: try decoder.decodeSingularStringField(value: &_storage._encryptionAlgo)
					case 15: try decoder.decodeSingularBytesField(value: &_storage._encryptionParam)
					case 16: try decoder.decodeSingularBytesField(value: &_storage._schemaVersion)
					case 17: try decoder.decodeSingularBoolField(value: &_storage._partitionKeyB64Encoded)
					case 18: try decoder.decodeSingularBytesField(value: &_storage._orderingKey)
					case 19: try decoder.decodeSingularInt64Field(value: &_storage._deliverAtTime)
					case 20: try decoder.decodeSingularInt32Field(value: &_storage._markerType)
					case 22: try decoder.decodeSingularUInt64Field(value: &_storage._txnidLeastBits)
					case 23: try decoder.decodeSingularUInt64Field(value: &_storage._txnidMostBits)
					case 24: try decoder.decodeSingularUInt64Field(value: &_storage._highestSequenceID)
					case 25: try decoder.decodeSingularBoolField(value: &_storage._nullValue)
					case 26: try decoder.decodeSingularStringField(value: &_storage._uuid)
					case 27: try decoder.decodeSingularInt32Field(value: &_storage._numChunksFromMsg)
					case 28: try decoder.decodeSingularInt32Field(value: &_storage._totalChunkMsgSize)
					case 29: try decoder.decodeSingularInt32Field(value: &_storage._chunkID)
					case 30: try decoder.decodeSingularBoolField(value: &_storage._nullPartitionKey)
					default: break
				}
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every if/case branch local when no optimizations
			// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
			// https://github.com/apple/swift-protobuf/issues/1182
			try { if let v = _storage._producerName {
				try visitor.visitSingularStringField(value: v, fieldNumber: 1)
			} }()
			try { if let v = _storage._sequenceID {
				try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
			} }()
			try { if let v = _storage._publishTime {
				try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
			} }()
			if !_storage._properties.isEmpty {
				try visitor.visitRepeatedMessageField(value: _storage._properties, fieldNumber: 4)
			}
			try { if let v = _storage._replicatedFrom {
				try visitor.visitSingularStringField(value: v, fieldNumber: 5)
			} }()
			try { if let v = _storage._partitionKey {
				try visitor.visitSingularStringField(value: v, fieldNumber: 6)
			} }()
			if !_storage._replicateTo.isEmpty {
				try visitor.visitRepeatedStringField(value: _storage._replicateTo, fieldNumber: 7)
			}
			try { if let v = _storage._compression {
				try visitor.visitSingularEnumField(value: v, fieldNumber: 8)
			} }()
			try { if let v = _storage._uncompressedSize {
				try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
			} }()
			try { if let v = _storage._numMessagesInBatch {
				try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
			} }()
			try { if let v = _storage._eventTime {
				try visitor.visitSingularUInt64Field(value: v, fieldNumber: 12)
			} }()
			if !_storage._encryptionKeys.isEmpty {
				try visitor.visitRepeatedMessageField(value: _storage._encryptionKeys, fieldNumber: 13)
			}
			try { if let v = _storage._encryptionAlgo {
				try visitor.visitSingularStringField(value: v, fieldNumber: 14)
			} }()
			try { if let v = _storage._encryptionParam {
				try visitor.visitSingularBytesField(value: v, fieldNumber: 15)
			} }()
			try { if let v = _storage._schemaVersion {
				try visitor.visitSingularBytesField(value: v, fieldNumber: 16)
			} }()
			try { if let v = _storage._partitionKeyB64Encoded {
				try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
			} }()
			try { if let v = _storage._orderingKey {
				try visitor.visitSingularBytesField(value: v, fieldNumber: 18)
			} }()
			try { if let v = _storage._deliverAtTime {
				try visitor.visitSingularInt64Field(value: v, fieldNumber: 19)
			} }()
			try { if let v = _storage._markerType {
				try visitor.visitSingularInt32Field(value: v, fieldNumber: 20)
			} }()
			try { if let v = _storage._txnidLeastBits {
				try visitor.visitSingularUInt64Field(value: v, fieldNumber: 22)
			} }()
			try { if let v = _storage._txnidMostBits {
				try visitor.visitSingularUInt64Field(value: v, fieldNumber: 23)
			} }()
			try { if let v = _storage._highestSequenceID {
				try visitor.visitSingularUInt64Field(value: v, fieldNumber: 24)
			} }()
			try { if let v = _storage._nullValue {
				try visitor.visitSingularBoolField(value: v, fieldNumber: 25)
			} }()
			try { if let v = _storage._uuid {
				try visitor.visitSingularStringField(value: v, fieldNumber: 26)
			} }()
			try { if let v = _storage._numChunksFromMsg {
				try visitor.visitSingularInt32Field(value: v, fieldNumber: 27)
			} }()
			try { if let v = _storage._totalChunkMsgSize {
				try visitor.visitSingularInt32Field(value: v, fieldNumber: 28)
			} }()
			try { if let v = _storage._chunkID {
				try visitor.visitSingularInt32Field(value: v, fieldNumber: 29)
			} }()
			try { if let v = _storage._nullPartitionKey {
				try visitor.visitSingularBoolField(value: v, fieldNumber: 30)
			} }()
		}
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_MessageMetadata, rhs: Pulsar_Proto_MessageMetadata) -> Bool {
		if lhs._storage !== rhs._storage {
			let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
				let _storage = _args.0
				let rhs_storage = _args.1
				if _storage._producerName != rhs_storage._producerName {
					return false
				}
				if _storage._sequenceID != rhs_storage._sequenceID {
					return false
				}
				if _storage._publishTime != rhs_storage._publishTime {
					return false
				}
				if _storage._properties != rhs_storage._properties {
					return false
				}
				if _storage._replicatedFrom != rhs_storage._replicatedFrom {
					return false
				}
				if _storage._partitionKey != rhs_storage._partitionKey {
					return false
				}
				if _storage._replicateTo != rhs_storage._replicateTo {
					return false
				}
				if _storage._compression != rhs_storage._compression {
					return false
				}
				if _storage._uncompressedSize != rhs_storage._uncompressedSize {
					return false
				}
				if _storage._numMessagesInBatch != rhs_storage._numMessagesInBatch {
					return false
				}
				if _storage._eventTime != rhs_storage._eventTime {
					return false
				}
				if _storage._encryptionKeys != rhs_storage._encryptionKeys {
					return false
				}
				if _storage._encryptionAlgo != rhs_storage._encryptionAlgo {
					return false
				}
				if _storage._encryptionParam != rhs_storage._encryptionParam {
					return false
				}
				if _storage._schemaVersion != rhs_storage._schemaVersion {
					return false
				}
				if _storage._partitionKeyB64Encoded != rhs_storage._partitionKeyB64Encoded {
					return false
				}
				if _storage._orderingKey != rhs_storage._orderingKey {
					return false
				}
				if _storage._deliverAtTime != rhs_storage._deliverAtTime {
					return false
				}
				if _storage._markerType != rhs_storage._markerType {
					return false
				}
				if _storage._txnidLeastBits != rhs_storage._txnidLeastBits {
					return false
				}
				if _storage._txnidMostBits != rhs_storage._txnidMostBits {
					return false
				}
				if _storage._highestSequenceID != rhs_storage._highestSequenceID {
					return false
				}
				if _storage._nullValue != rhs_storage._nullValue {
					return false
				}
				if _storage._uuid != rhs_storage._uuid {
					return false
				}
				if _storage._numChunksFromMsg != rhs_storage._numChunksFromMsg {
					return false
				}
				if _storage._totalChunkMsgSize != rhs_storage._totalChunkMsgSize {
					return false
				}
				if _storage._chunkID != rhs_storage._chunkID {
					return false
				}
				if _storage._nullPartitionKey != rhs_storage._nullPartitionKey {
					return false
				}
				return true
			}
			if !storagesAreEqual {
				return false
			}
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_SingleMessageMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".SingleMessageMetadata"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .same(proto: "properties"),
		2: .standard(proto: "partition_key"),
		3: .standard(proto: "payload_size"),
		4: .standard(proto: "compacted_out"),
		5: .standard(proto: "event_time"),
		6: .standard(proto: "partition_key_b64_encoded"),
		7: .standard(proto: "ordering_key"),
		8: .standard(proto: "sequence_id"),
		9: .standard(proto: "null_value"),
		10: .standard(proto: "null_partition_key")
	]

	public var isInitialized: Bool {
		if _payloadSize == nil {
			return false
		}
		if !SwiftProtobuf.Internal.areAllInitialized(properties) {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeRepeatedMessageField(value: &properties)
				case 2: try decoder.decodeSingularStringField(value: &_partitionKey)
				case 3: try decoder.decodeSingularInt32Field(value: &_payloadSize)
				case 4: try decoder.decodeSingularBoolField(value: &_compactedOut)
				case 5: try decoder.decodeSingularUInt64Field(value: &_eventTime)
				case 6: try decoder.decodeSingularBoolField(value: &_partitionKeyB64Encoded)
				case 7: try decoder.decodeSingularBytesField(value: &_orderingKey)
				case 8: try decoder.decodeSingularUInt64Field(value: &_sequenceID)
				case 9: try decoder.decodeSingularBoolField(value: &_nullValue)
				case 10: try decoder.decodeSingularBoolField(value: &_nullPartitionKey)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if !properties.isEmpty {
			try visitor.visitRepeatedMessageField(value: properties, fieldNumber: 1)
		}
		try { if let v = self._partitionKey {
			try visitor.visitSingularStringField(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._payloadSize {
			try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._compactedOut {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._eventTime {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
		} }()
		try { if let v = self._partitionKeyB64Encoded {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
		} }()
		try { if let v = self._orderingKey {
			try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
		} }()
		try { if let v = self._sequenceID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
		} }()
		try { if let v = self._nullValue {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
		} }()
		try { if let v = self._nullPartitionKey {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_SingleMessageMetadata, rhs: Pulsar_Proto_SingleMessageMetadata) -> Bool {
		if lhs.properties != rhs.properties {
			return false
		}
		if lhs._partitionKey != rhs._partitionKey {
			return false
		}
		if lhs._payloadSize != rhs._payloadSize {
			return false
		}
		if lhs._compactedOut != rhs._compactedOut {
			return false
		}
		if lhs._eventTime != rhs._eventTime {
			return false
		}
		if lhs._partitionKeyB64Encoded != rhs._partitionKeyB64Encoded {
			return false
		}
		if lhs._orderingKey != rhs._orderingKey {
			return false
		}
		if lhs._sequenceID != rhs._sequenceID {
			return false
		}
		if lhs._nullValue != rhs._nullValue {
			return false
		}
		if lhs._nullPartitionKey != rhs._nullPartitionKey {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_BrokerEntryMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".BrokerEntryMetadata"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "broker_timestamp"),
		2: .same(proto: "index")
	]

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_brokerTimestamp)
				case 2: try decoder.decodeSingularUInt64Field(value: &_index)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _brokerTimestamp {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._index {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_BrokerEntryMetadata, rhs: Pulsar_Proto_BrokerEntryMetadata) -> Bool {
		if lhs._brokerTimestamp != rhs._brokerTimestamp {
			return false
		}
		if lhs._index != rhs._index {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandConnect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandConnect"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "client_version"),
		2: .standard(proto: "auth_method"),
		5: .standard(proto: "auth_method_name"),
		3: .standard(proto: "auth_data"),
		4: .standard(proto: "protocol_version"),
		6: .standard(proto: "proxy_to_broker_url"),
		7: .standard(proto: "original_principal"),
		8: .standard(proto: "original_auth_data"),
		9: .standard(proto: "original_auth_method"),
		10: .standard(proto: "feature_flags"),
		11: .standard(proto: "proxy_version")
	]

	public var isInitialized: Bool {
		if _clientVersion == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularStringField(value: &_clientVersion)
				case 2: try decoder.decodeSingularEnumField(value: &_authMethod)
				case 3: try decoder.decodeSingularBytesField(value: &_authData)
				case 4: try decoder.decodeSingularInt32Field(value: &_protocolVersion)
				case 5: try decoder.decodeSingularStringField(value: &_authMethodName)
				case 6: try decoder.decodeSingularStringField(value: &_proxyToBrokerURL)
				case 7: try decoder.decodeSingularStringField(value: &_originalPrincipal)
				case 8: try decoder.decodeSingularStringField(value: &_originalAuthData)
				case 9: try decoder.decodeSingularStringField(value: &_originalAuthMethod)
				case 10: try decoder.decodeSingularMessageField(value: &_featureFlags)
				case 11: try decoder.decodeSingularStringField(value: &_proxyVersion)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _clientVersion {
			try visitor.visitSingularStringField(value: v, fieldNumber: 1)
		}
		try { if let v = self._authMethod {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._authData {
			try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._protocolVersion {
			try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._authMethodName {
			try visitor.visitSingularStringField(value: v, fieldNumber: 5)
		} }()
		try { if let v = self._proxyToBrokerURL {
			try visitor.visitSingularStringField(value: v, fieldNumber: 6)
		} }()
		try { if let v = self._originalPrincipal {
			try visitor.visitSingularStringField(value: v, fieldNumber: 7)
		} }()
		try { if let v = self._originalAuthData {
			try visitor.visitSingularStringField(value: v, fieldNumber: 8)
		} }()
		try { if let v = self._originalAuthMethod {
			try visitor.visitSingularStringField(value: v, fieldNumber: 9)
		} }()
		try { if let v = self._featureFlags {
			try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
		} }()
		try { if let v = self._proxyVersion {
			try visitor.visitSingularStringField(value: v, fieldNumber: 11)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandConnect, rhs: Pulsar_Proto_CommandConnect) -> Bool {
		if lhs._clientVersion != rhs._clientVersion {
			return false
		}
		if lhs._authMethod != rhs._authMethod {
			return false
		}
		if lhs._authMethodName != rhs._authMethodName {
			return false
		}
		if lhs._authData != rhs._authData {
			return false
		}
		if lhs._protocolVersion != rhs._protocolVersion {
			return false
		}
		if lhs._proxyToBrokerURL != rhs._proxyToBrokerURL {
			return false
		}
		if lhs._originalPrincipal != rhs._originalPrincipal {
			return false
		}
		if lhs._originalAuthData != rhs._originalAuthData {
			return false
		}
		if lhs._originalAuthMethod != rhs._originalAuthMethod {
			return false
		}
		if lhs._featureFlags != rhs._featureFlags {
			return false
		}
		if lhs._proxyVersion != rhs._proxyVersion {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_FeatureFlags: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".FeatureFlags"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "supports_auth_refresh"),
		2: .standard(proto: "supports_broker_entry_metadata"),
		3: .standard(proto: "supports_partial_producer"),
		4: .standard(proto: "supports_topic_watchers"),
		5: .standard(proto: "supports_get_partitioned_metadata_without_auto_creation")
	]

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularBoolField(value: &_supportsAuthRefresh)
				case 2: try decoder.decodeSingularBoolField(value: &_supportsBrokerEntryMetadata)
				case 3: try decoder.decodeSingularBoolField(value: &_supportsPartialProducer)
				case 4: try decoder.decodeSingularBoolField(value: &_supportsTopicWatchers)
				case 5: try decoder.decodeSingularBoolField(value: &_supportsGetPartitionedMetadataWithoutAutoCreation)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _supportsAuthRefresh {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
		}
		try { if let v = self._supportsBrokerEntryMetadata {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._supportsPartialProducer {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._supportsTopicWatchers {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._supportsGetPartitionedMetadataWithoutAutoCreation {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_FeatureFlags, rhs: Pulsar_Proto_FeatureFlags) -> Bool {
		if lhs._supportsAuthRefresh != rhs._supportsAuthRefresh {
			return false
		}
		if lhs._supportsBrokerEntryMetadata != rhs._supportsBrokerEntryMetadata {
			return false
		}
		if lhs._supportsPartialProducer != rhs._supportsPartialProducer {
			return false
		}
		if lhs._supportsTopicWatchers != rhs._supportsTopicWatchers {
			return false
		}
		if lhs._supportsGetPartitionedMetadataWithoutAutoCreation != rhs._supportsGetPartitionedMetadataWithoutAutoCreation {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandConnected: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandConnected"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "server_version"),
		2: .standard(proto: "protocol_version"),
		3: .standard(proto: "max_message_size"),
		4: .standard(proto: "feature_flags")
	]

	public var isInitialized: Bool {
		if _serverVersion == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularStringField(value: &_serverVersion)
				case 2: try decoder.decodeSingularInt32Field(value: &_protocolVersion)
				case 3: try decoder.decodeSingularInt32Field(value: &_maxMessageSize)
				case 4: try decoder.decodeSingularMessageField(value: &_featureFlags)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _serverVersion {
			try visitor.visitSingularStringField(value: v, fieldNumber: 1)
		}
		try { if let v = self._protocolVersion {
			try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._maxMessageSize {
			try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._featureFlags {
			try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandConnected, rhs: Pulsar_Proto_CommandConnected) -> Bool {
		if lhs._serverVersion != rhs._serverVersion {
			return false
		}
		if lhs._protocolVersion != rhs._protocolVersion {
			return false
		}
		if lhs._maxMessageSize != rhs._maxMessageSize {
			return false
		}
		if lhs._featureFlags != rhs._featureFlags {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandAuthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandAuthResponse"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "client_version"),
		2: .same(proto: "response"),
		3: .standard(proto: "protocol_version")
	]

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularStringField(value: &_clientVersion)
				case 2: try decoder.decodeSingularMessageField(value: &_response)
				case 3: try decoder.decodeSingularInt32Field(value: &_protocolVersion)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _clientVersion {
			try visitor.visitSingularStringField(value: v, fieldNumber: 1)
		}
		try { if let v = self._response {
			try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._protocolVersion {
			try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandAuthResponse, rhs: Pulsar_Proto_CommandAuthResponse) -> Bool {
		if lhs._clientVersion != rhs._clientVersion {
			return false
		}
		if lhs._response != rhs._response {
			return false
		}
		if lhs._protocolVersion != rhs._protocolVersion {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandAuthChallenge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandAuthChallenge"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "server_version"),
		2: .same(proto: "challenge"),
		3: .standard(proto: "protocol_version")
	]

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularStringField(value: &_serverVersion)
				case 2: try decoder.decodeSingularMessageField(value: &_challenge)
				case 3: try decoder.decodeSingularInt32Field(value: &_protocolVersion)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _serverVersion {
			try visitor.visitSingularStringField(value: v, fieldNumber: 1)
		}
		try { if let v = self._challenge {
			try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._protocolVersion {
			try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandAuthChallenge, rhs: Pulsar_Proto_CommandAuthChallenge) -> Bool {
		if lhs._serverVersion != rhs._serverVersion {
			return false
		}
		if lhs._challenge != rhs._challenge {
			return false
		}
		if lhs._protocolVersion != rhs._protocolVersion {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_AuthData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".AuthData"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "auth_method_name"),
		2: .standard(proto: "auth_data")
	]

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularStringField(value: &_authMethodName)
				case 2: try decoder.decodeSingularBytesField(value: &_authData)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _authMethodName {
			try visitor.visitSingularStringField(value: v, fieldNumber: 1)
		}
		try { if let v = self._authData {
			try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_AuthData, rhs: Pulsar_Proto_AuthData) -> Bool {
		if lhs._authMethodName != rhs._authMethodName {
			return false
		}
		if lhs._authData != rhs._authData {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_KeySharedMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".KeySharedMeta"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .same(proto: "keySharedMode"),
		3: .same(proto: "hashRanges"),
		4: .same(proto: "allowOutOfOrderDelivery")
	]

	public var isInitialized: Bool {
		if _keySharedMode == nil {
			return false
		}
		if !SwiftProtobuf.Internal.areAllInitialized(hashRanges) {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularEnumField(value: &_keySharedMode)
				case 3: try decoder.decodeRepeatedMessageField(value: &hashRanges)
				case 4: try decoder.decodeSingularBoolField(value: &_allowOutOfOrderDelivery)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _keySharedMode {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
		}
		if !hashRanges.isEmpty {
			try visitor.visitRepeatedMessageField(value: hashRanges, fieldNumber: 3)
		}
		try { if let v = self._allowOutOfOrderDelivery {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_KeySharedMeta, rhs: Pulsar_Proto_KeySharedMeta) -> Bool {
		if lhs._keySharedMode != rhs._keySharedMode {
			return false
		}
		if lhs.hashRanges != rhs.hashRanges {
			return false
		}
		if lhs._allowOutOfOrderDelivery != rhs._allowOutOfOrderDelivery {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandSubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandSubscribe"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .same(proto: "topic"),
		2: .same(proto: "subscription"),
		3: .same(proto: "subType"),
		4: .standard(proto: "consumer_id"),
		5: .standard(proto: "request_id"),
		6: .standard(proto: "consumer_name"),
		7: .standard(proto: "priority_level"),
		8: .same(proto: "durable"),
		9: .standard(proto: "start_message_id"),
		10: .same(proto: "metadata"),
		11: .standard(proto: "read_compacted"),
		12: .same(proto: "schema"),
		13: .same(proto: "initialPosition"),
		14: .standard(proto: "replicate_subscription_state"),
		15: .standard(proto: "force_topic_creation"),
		16: .standard(proto: "start_message_rollback_duration_sec"),
		17: .same(proto: "keySharedMeta"),
		18: .standard(proto: "subscription_properties"),
		19: .standard(proto: "consumer_epoch")
	]

	fileprivate class _StorageClass {
		var _topic: String?
		var _subscription: String?
		var _subType: Pulsar_Proto_CommandSubscribe.SubType?
		var _consumerID: UInt64?
		var _requestID: UInt64?
		var _consumerName: String?
		var _priorityLevel: Int32?
		var _durable: Bool?
		var _startMessageID: Pulsar_Proto_MessageIDData?
		var _metadata: [Pulsar_Proto_KeyValue] = []
		var _readCompacted: Bool?
		var _schema: Pulsar_Proto_Schema?
		var _initialPosition: Pulsar_Proto_CommandSubscribe.InitialPosition?
		var _replicateSubscriptionState: Bool?
		var _forceTopicCreation: Bool?
		var _startMessageRollbackDurationSec: UInt64?
		var _keySharedMeta: Pulsar_Proto_KeySharedMeta?
		var _subscriptionProperties: [Pulsar_Proto_KeyValue] = []
		var _consumerEpoch: UInt64?

		#if swift(>=5.10)
			// This property is used as the initial default value for new instances of the type.
			// The type itself is protecting the reference to its storage via CoW semantics.
			// This will force a copy to be made of this reference when the first mutation occurs;
			// hence, it is safe to mark this as `nonisolated(unsafe)`.
			nonisolated(unsafe) static let defaultInstance = _StorageClass()
		#else
			static let defaultInstance = _StorageClass()
		#endif

		private init() { }

		init(copying source: _StorageClass) {
			_topic = source._topic
			_subscription = source._subscription
			_subType = source._subType
			_consumerID = source._consumerID
			_requestID = source._requestID
			_consumerName = source._consumerName
			_priorityLevel = source._priorityLevel
			_durable = source._durable
			_startMessageID = source._startMessageID
			_metadata = source._metadata
			_readCompacted = source._readCompacted
			_schema = source._schema
			_initialPosition = source._initialPosition
			_replicateSubscriptionState = source._replicateSubscriptionState
			_forceTopicCreation = source._forceTopicCreation
			_startMessageRollbackDurationSec = source._startMessageRollbackDurationSec
			_keySharedMeta = source._keySharedMeta
			_subscriptionProperties = source._subscriptionProperties
			_consumerEpoch = source._consumerEpoch
		}
	}

	fileprivate mutating func _uniqueStorage() -> _StorageClass {
		if !isKnownUniquelyReferenced(&_storage) {
			_storage = _StorageClass(copying: _storage)
		}
		return _storage
	}

	public var isInitialized: Bool {
		withExtendedLifetime(_storage) { (_storage: _StorageClass) in
			if _storage._topic == nil {
				return false
			}
			if _storage._subscription == nil {
				return false
			}
			if _storage._subType == nil {
				return false
			}
			if _storage._consumerID == nil {
				return false
			}
			if _storage._requestID == nil {
				return false
			}
			if let v = _storage._startMessageID, !v.isInitialized {
				return false
			}
			if !SwiftProtobuf.Internal.areAllInitialized(_storage._metadata) {
				return false
			}
			if let v = _storage._schema, !v.isInitialized {
				return false
			}
			if let v = _storage._keySharedMeta, !v.isInitialized {
				return false
			}
			if !SwiftProtobuf.Internal.areAllInitialized(_storage._subscriptionProperties) {
				return false
			}
			return true
		}
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		_ = _uniqueStorage()
		try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
			while let fieldNumber = try decoder.nextFieldNumber() {
				// The use of inline closures is to circumvent an issue where the compiler
				// allocates stack space for every case branch when no optimizations are
				// enabled. https://github.com/apple/swift-protobuf/issues/1034
				switch fieldNumber {
					case 1: try decoder.decodeSingularStringField(value: &_storage._topic)
					case 2: try decoder.decodeSingularStringField(value: &_storage._subscription)
					case 3: try decoder.decodeSingularEnumField(value: &_storage._subType)
					case 4: try decoder.decodeSingularUInt64Field(value: &_storage._consumerID)
					case 5: try decoder.decodeSingularUInt64Field(value: &_storage._requestID)
					case 6: try decoder.decodeSingularStringField(value: &_storage._consumerName)
					case 7: try decoder.decodeSingularInt32Field(value: &_storage._priorityLevel)
					case 8: try decoder.decodeSingularBoolField(value: &_storage._durable)
					case 9: try decoder.decodeSingularMessageField(value: &_storage._startMessageID)
					case 10: try decoder.decodeRepeatedMessageField(value: &_storage._metadata)
					case 11: try decoder.decodeSingularBoolField(value: &_storage._readCompacted)
					case 12: try decoder.decodeSingularMessageField(value: &_storage._schema)
					case 13: try decoder.decodeSingularEnumField(value: &_storage._initialPosition)
					case 14: try decoder.decodeSingularBoolField(value: &_storage._replicateSubscriptionState)
					case 15: try decoder.decodeSingularBoolField(value: &_storage._forceTopicCreation)
					case 16: try decoder.decodeSingularUInt64Field(value: &_storage._startMessageRollbackDurationSec)
					case 17: try decoder.decodeSingularMessageField(value: &_storage._keySharedMeta)
					case 18: try decoder.decodeRepeatedMessageField(value: &_storage._subscriptionProperties)
					case 19: try decoder.decodeSingularUInt64Field(value: &_storage._consumerEpoch)
					default: break
				}
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every if/case branch local when no optimizations
			// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
			// https://github.com/apple/swift-protobuf/issues/1182
			try { if let v = _storage._topic {
				try visitor.visitSingularStringField(value: v, fieldNumber: 1)
			} }()
			try { if let v = _storage._subscription {
				try visitor.visitSingularStringField(value: v, fieldNumber: 2)
			} }()
			try { if let v = _storage._subType {
				try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
			} }()
			try { if let v = _storage._consumerID {
				try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
			} }()
			try { if let v = _storage._requestID {
				try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
			} }()
			try { if let v = _storage._consumerName {
				try visitor.visitSingularStringField(value: v, fieldNumber: 6)
			} }()
			try { if let v = _storage._priorityLevel {
				try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
			} }()
			try { if let v = _storage._durable {
				try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
			} }()
			try { if let v = _storage._startMessageID {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
			} }()
			if !_storage._metadata.isEmpty {
				try visitor.visitRepeatedMessageField(value: _storage._metadata, fieldNumber: 10)
			}
			try { if let v = _storage._readCompacted {
				try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
			} }()
			try { if let v = _storage._schema {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
			} }()
			try { if let v = _storage._initialPosition {
				try visitor.visitSingularEnumField(value: v, fieldNumber: 13)
			} }()
			try { if let v = _storage._replicateSubscriptionState {
				try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
			} }()
			try { if let v = _storage._forceTopicCreation {
				try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
			} }()
			try { if let v = _storage._startMessageRollbackDurationSec {
				try visitor.visitSingularUInt64Field(value: v, fieldNumber: 16)
			} }()
			try { if let v = _storage._keySharedMeta {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
			} }()
			if !_storage._subscriptionProperties.isEmpty {
				try visitor.visitRepeatedMessageField(value: _storage._subscriptionProperties, fieldNumber: 18)
			}
			try { if let v = _storage._consumerEpoch {
				try visitor.visitSingularUInt64Field(value: v, fieldNumber: 19)
			} }()
		}
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandSubscribe, rhs: Pulsar_Proto_CommandSubscribe) -> Bool {
		if lhs._storage !== rhs._storage {
			let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
				let _storage = _args.0
				let rhs_storage = _args.1
				if _storage._topic != rhs_storage._topic {
					return false
				}
				if _storage._subscription != rhs_storage._subscription {
					return false
				}
				if _storage._subType != rhs_storage._subType {
					return false
				}
				if _storage._consumerID != rhs_storage._consumerID {
					return false
				}
				if _storage._requestID != rhs_storage._requestID {
					return false
				}
				if _storage._consumerName != rhs_storage._consumerName {
					return false
				}
				if _storage._priorityLevel != rhs_storage._priorityLevel {
					return false
				}
				if _storage._durable != rhs_storage._durable {
					return false
				}
				if _storage._startMessageID != rhs_storage._startMessageID {
					return false
				}
				if _storage._metadata != rhs_storage._metadata {
					return false
				}
				if _storage._readCompacted != rhs_storage._readCompacted {
					return false
				}
				if _storage._schema != rhs_storage._schema {
					return false
				}
				if _storage._initialPosition != rhs_storage._initialPosition {
					return false
				}
				if _storage._replicateSubscriptionState != rhs_storage._replicateSubscriptionState {
					return false
				}
				if _storage._forceTopicCreation != rhs_storage._forceTopicCreation {
					return false
				}
				if _storage._startMessageRollbackDurationSec != rhs_storage._startMessageRollbackDurationSec {
					return false
				}
				if _storage._keySharedMeta != rhs_storage._keySharedMeta {
					return false
				}
				if _storage._subscriptionProperties != rhs_storage._subscriptionProperties {
					return false
				}
				if _storage._consumerEpoch != rhs_storage._consumerEpoch {
					return false
				}
				return true
			}
			if !storagesAreEqual {
				return false
			}
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandSubscribe.SubType: SwiftProtobuf._ProtoNameProviding {
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		0: .same(proto: "Exclusive"),
		1: .same(proto: "Shared"),
		2: .same(proto: "Failover"),
		3: .same(proto: "Key_Shared")
	]
}

extension Pulsar_Proto_CommandSubscribe.InitialPosition: SwiftProtobuf._ProtoNameProviding {
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		0: .same(proto: "Latest"),
		1: .same(proto: "Earliest")
	]
}

extension Pulsar_Proto_CommandPartitionedTopicMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandPartitionedTopicMetadata"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .same(proto: "topic"),
		2: .standard(proto: "request_id"),
		3: .standard(proto: "original_principal"),
		4: .standard(proto: "original_auth_data"),
		5: .standard(proto: "original_auth_method"),
		6: .standard(proto: "metadata_auto_creation_enabled")
	]

	public var isInitialized: Bool {
		if _topic == nil {
			return false
		}
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularStringField(value: &_topic)
				case 2: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 3: try decoder.decodeSingularStringField(value: &_originalPrincipal)
				case 4: try decoder.decodeSingularStringField(value: &_originalAuthData)
				case 5: try decoder.decodeSingularStringField(value: &_originalAuthMethod)
				case 6: try decoder.decodeSingularBoolField(value: &_metadataAutoCreationEnabled)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _topic {
			try visitor.visitSingularStringField(value: v, fieldNumber: 1)
		}
		try { if let v = self._requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._originalPrincipal {
			try visitor.visitSingularStringField(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._originalAuthData {
			try visitor.visitSingularStringField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._originalAuthMethod {
			try visitor.visitSingularStringField(value: v, fieldNumber: 5)
		} }()
		try { if let v = self._metadataAutoCreationEnabled {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandPartitionedTopicMetadata, rhs: Pulsar_Proto_CommandPartitionedTopicMetadata) -> Bool {
		if lhs._topic != rhs._topic {
			return false
		}
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._originalPrincipal != rhs._originalPrincipal {
			return false
		}
		if lhs._originalAuthData != rhs._originalAuthData {
			return false
		}
		if lhs._originalAuthMethod != rhs._originalAuthMethod {
			return false
		}
		if lhs._metadataAutoCreationEnabled != rhs._metadataAutoCreationEnabled {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandPartitionedTopicMetadataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandPartitionedTopicMetadataResponse"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .same(proto: "partitions"),
		2: .standard(proto: "request_id"),
		3: .same(proto: "response"),
		4: .same(proto: "error"),
		5: .same(proto: "message")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt32Field(value: &_partitions)
				case 2: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 3: try decoder.decodeSingularEnumField(value: &_response)
				case 4: try decoder.decodeSingularEnumField(value: &_error)
				case 5: try decoder.decodeSingularStringField(value: &_message)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _partitions {
			try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._response {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._error {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._message {
			try visitor.visitSingularStringField(value: v, fieldNumber: 5)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandPartitionedTopicMetadataResponse, rhs: Pulsar_Proto_CommandPartitionedTopicMetadataResponse) -> Bool {
		if lhs._partitions != rhs._partitions {
			return false
		}
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._response != rhs._response {
			return false
		}
		if lhs._error != rhs._error {
			return false
		}
		if lhs._message != rhs._message {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandPartitionedTopicMetadataResponse.LookupType: SwiftProtobuf._ProtoNameProviding {
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		0: .same(proto: "Success"),
		1: .same(proto: "Failed")
	]
}

extension Pulsar_Proto_CommandLookupTopic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandLookupTopic"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .same(proto: "topic"),
		2: .standard(proto: "request_id"),
		3: .same(proto: "authoritative"),
		4: .standard(proto: "original_principal"),
		5: .standard(proto: "original_auth_data"),
		6: .standard(proto: "original_auth_method"),
		7: .standard(proto: "advertised_listener_name"),
		8: .same(proto: "properties")
	]

	public var isInitialized: Bool {
		if _topic == nil {
			return false
		}
		if _requestID == nil {
			return false
		}
		if !SwiftProtobuf.Internal.areAllInitialized(properties) {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularStringField(value: &_topic)
				case 2: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 3: try decoder.decodeSingularBoolField(value: &_authoritative)
				case 4: try decoder.decodeSingularStringField(value: &_originalPrincipal)
				case 5: try decoder.decodeSingularStringField(value: &_originalAuthData)
				case 6: try decoder.decodeSingularStringField(value: &_originalAuthMethod)
				case 7: try decoder.decodeSingularStringField(value: &_advertisedListenerName)
				case 8: try decoder.decodeRepeatedMessageField(value: &properties)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _topic {
			try visitor.visitSingularStringField(value: v, fieldNumber: 1)
		}
		try { if let v = self._requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._authoritative {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._originalPrincipal {
			try visitor.visitSingularStringField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._originalAuthData {
			try visitor.visitSingularStringField(value: v, fieldNumber: 5)
		} }()
		try { if let v = self._originalAuthMethod {
			try visitor.visitSingularStringField(value: v, fieldNumber: 6)
		} }()
		try { if let v = self._advertisedListenerName {
			try visitor.visitSingularStringField(value: v, fieldNumber: 7)
		} }()
		if !properties.isEmpty {
			try visitor.visitRepeatedMessageField(value: properties, fieldNumber: 8)
		}
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandLookupTopic, rhs: Pulsar_Proto_CommandLookupTopic) -> Bool {
		if lhs._topic != rhs._topic {
			return false
		}
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._authoritative != rhs._authoritative {
			return false
		}
		if lhs._originalPrincipal != rhs._originalPrincipal {
			return false
		}
		if lhs._originalAuthData != rhs._originalAuthData {
			return false
		}
		if lhs._originalAuthMethod != rhs._originalAuthMethod {
			return false
		}
		if lhs._advertisedListenerName != rhs._advertisedListenerName {
			return false
		}
		if lhs.properties != rhs.properties {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandLookupTopicResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandLookupTopicResponse"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .same(proto: "brokerServiceUrl"),
		2: .same(proto: "brokerServiceUrlTls"),
		3: .same(proto: "response"),
		4: .standard(proto: "request_id"),
		5: .same(proto: "authoritative"),
		6: .same(proto: "error"),
		7: .same(proto: "message"),
		8: .standard(proto: "proxy_through_service_url")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularStringField(value: &_brokerServiceURL)
				case 2: try decoder.decodeSingularStringField(value: &_brokerServiceURLTls)
				case 3: try decoder.decodeSingularEnumField(value: &_response)
				case 4: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 5: try decoder.decodeSingularBoolField(value: &_authoritative)
				case 6: try decoder.decodeSingularEnumField(value: &_error)
				case 7: try decoder.decodeSingularStringField(value: &_message)
				case 8: try decoder.decodeSingularBoolField(value: &_proxyThroughServiceURL)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _brokerServiceURL {
			try visitor.visitSingularStringField(value: v, fieldNumber: 1)
		}
		try { if let v = self._brokerServiceURLTls {
			try visitor.visitSingularStringField(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._response {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._authoritative {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
		} }()
		try { if let v = self._error {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
		} }()
		try { if let v = self._message {
			try visitor.visitSingularStringField(value: v, fieldNumber: 7)
		} }()
		try { if let v = self._proxyThroughServiceURL {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandLookupTopicResponse, rhs: Pulsar_Proto_CommandLookupTopicResponse) -> Bool {
		if lhs._brokerServiceURL != rhs._brokerServiceURL {
			return false
		}
		if lhs._brokerServiceURLTls != rhs._brokerServiceURLTls {
			return false
		}
		if lhs._response != rhs._response {
			return false
		}
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._authoritative != rhs._authoritative {
			return false
		}
		if lhs._error != rhs._error {
			return false
		}
		if lhs._message != rhs._message {
			return false
		}
		if lhs._proxyThroughServiceURL != rhs._proxyThroughServiceURL {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandLookupTopicResponse.LookupType: SwiftProtobuf._ProtoNameProviding {
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		0: .same(proto: "Redirect"),
		1: .same(proto: "Connect"),
		2: .same(proto: "Failed")
	]
}

extension Pulsar_Proto_CommandProducer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandProducer"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .same(proto: "topic"),
		2: .standard(proto: "producer_id"),
		3: .standard(proto: "request_id"),
		4: .standard(proto: "producer_name"),
		5: .same(proto: "encrypted"),
		6: .same(proto: "metadata"),
		7: .same(proto: "schema"),
		8: .same(proto: "epoch"),
		9: .standard(proto: "user_provided_producer_name"),
		10: .standard(proto: "producer_access_mode"),
		11: .standard(proto: "topic_epoch"),
		12: .standard(proto: "txn_enabled"),
		13: .standard(proto: "initial_subscription_name")
	]

	public var isInitialized: Bool {
		if _topic == nil {
			return false
		}
		if _producerID == nil {
			return false
		}
		if _requestID == nil {
			return false
		}
		if !SwiftProtobuf.Internal.areAllInitialized(metadata) {
			return false
		}
		if let v = _schema, !v.isInitialized {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularStringField(value: &_topic)
				case 2: try decoder.decodeSingularUInt64Field(value: &_producerID)
				case 3: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 4: try decoder.decodeSingularStringField(value: &_producerName)
				case 5: try decoder.decodeSingularBoolField(value: &_encrypted)
				case 6: try decoder.decodeRepeatedMessageField(value: &metadata)
				case 7: try decoder.decodeSingularMessageField(value: &_schema)
				case 8: try decoder.decodeSingularUInt64Field(value: &_epoch)
				case 9: try decoder.decodeSingularBoolField(value: &_userProvidedProducerName)
				case 10: try decoder.decodeSingularEnumField(value: &_producerAccessMode)
				case 11: try decoder.decodeSingularUInt64Field(value: &_topicEpoch)
				case 12: try decoder.decodeSingularBoolField(value: &_txnEnabled)
				case 13: try decoder.decodeSingularStringField(value: &_initialSubscriptionName)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _topic {
			try visitor.visitSingularStringField(value: v, fieldNumber: 1)
		}
		try { if let v = self._producerID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._producerName {
			try visitor.visitSingularStringField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._encrypted {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
		} }()
		if !metadata.isEmpty {
			try visitor.visitRepeatedMessageField(value: metadata, fieldNumber: 6)
		}
		try { if let v = self._schema {
			try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
		} }()
		try { if let v = self._epoch {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
		} }()
		try { if let v = self._userProvidedProducerName {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
		} }()
		try { if let v = self._producerAccessMode {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
		} }()
		try { if let v = self._topicEpoch {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 11)
		} }()
		try { if let v = self._txnEnabled {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
		} }()
		try { if let v = self._initialSubscriptionName {
			try visitor.visitSingularStringField(value: v, fieldNumber: 13)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandProducer, rhs: Pulsar_Proto_CommandProducer) -> Bool {
		if lhs._topic != rhs._topic {
			return false
		}
		if lhs._producerID != rhs._producerID {
			return false
		}
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._producerName != rhs._producerName {
			return false
		}
		if lhs._encrypted != rhs._encrypted {
			return false
		}
		if lhs.metadata != rhs.metadata {
			return false
		}
		if lhs._schema != rhs._schema {
			return false
		}
		if lhs._epoch != rhs._epoch {
			return false
		}
		if lhs._userProvidedProducerName != rhs._userProvidedProducerName {
			return false
		}
		if lhs._producerAccessMode != rhs._producerAccessMode {
			return false
		}
		if lhs._topicEpoch != rhs._topicEpoch {
			return false
		}
		if lhs._txnEnabled != rhs._txnEnabled {
			return false
		}
		if lhs._initialSubscriptionName != rhs._initialSubscriptionName {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandSend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandSend"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "producer_id"),
		2: .standard(proto: "sequence_id"),
		3: .standard(proto: "num_messages"),
		4: .standard(proto: "txnid_least_bits"),
		5: .standard(proto: "txnid_most_bits"),
		6: .standard(proto: "highest_sequence_id"),
		7: .standard(proto: "is_chunk"),
		8: .same(proto: "marker"),
		9: .standard(proto: "message_id")
	]

	public var isInitialized: Bool {
		if _producerID == nil {
			return false
		}
		if _sequenceID == nil {
			return false
		}
		if let v = _messageID, !v.isInitialized {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_producerID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_sequenceID)
				case 3: try decoder.decodeSingularInt32Field(value: &_numMessages)
				case 4: try decoder.decodeSingularUInt64Field(value: &_txnidLeastBits)
				case 5: try decoder.decodeSingularUInt64Field(value: &_txnidMostBits)
				case 6: try decoder.decodeSingularUInt64Field(value: &_highestSequenceID)
				case 7: try decoder.decodeSingularBoolField(value: &_isChunk)
				case 8: try decoder.decodeSingularBoolField(value: &_marker)
				case 9: try decoder.decodeSingularMessageField(value: &_messageID)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _producerID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._sequenceID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._numMessages {
			try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._txnidLeastBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._txnidMostBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
		} }()
		try { if let v = self._highestSequenceID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
		} }()
		try { if let v = self._isChunk {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
		} }()
		try { if let v = self._marker {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
		} }()
		try { if let v = self._messageID {
			try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandSend, rhs: Pulsar_Proto_CommandSend) -> Bool {
		if lhs._producerID != rhs._producerID {
			return false
		}
		if lhs._sequenceID != rhs._sequenceID {
			return false
		}
		if lhs._numMessages != rhs._numMessages {
			return false
		}
		if lhs._txnidLeastBits != rhs._txnidLeastBits {
			return false
		}
		if lhs._txnidMostBits != rhs._txnidMostBits {
			return false
		}
		if lhs._highestSequenceID != rhs._highestSequenceID {
			return false
		}
		if lhs._isChunk != rhs._isChunk {
			return false
		}
		if lhs._marker != rhs._marker {
			return false
		}
		if lhs._messageID != rhs._messageID {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandSendReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandSendReceipt"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "producer_id"),
		2: .standard(proto: "sequence_id"),
		3: .standard(proto: "message_id"),
		4: .standard(proto: "highest_sequence_id")
	]

	public var isInitialized: Bool {
		if _producerID == nil {
			return false
		}
		if _sequenceID == nil {
			return false
		}
		if let v = _messageID, !v.isInitialized {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_producerID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_sequenceID)
				case 3: try decoder.decodeSingularMessageField(value: &_messageID)
				case 4: try decoder.decodeSingularUInt64Field(value: &_highestSequenceID)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _producerID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._sequenceID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._messageID {
			try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._highestSequenceID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandSendReceipt, rhs: Pulsar_Proto_CommandSendReceipt) -> Bool {
		if lhs._producerID != rhs._producerID {
			return false
		}
		if lhs._sequenceID != rhs._sequenceID {
			return false
		}
		if lhs._messageID != rhs._messageID {
			return false
		}
		if lhs._highestSequenceID != rhs._highestSequenceID {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandSendError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandSendError"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "producer_id"),
		2: .standard(proto: "sequence_id"),
		3: .same(proto: "error"),
		4: .same(proto: "message")
	]

	public var isInitialized: Bool {
		if _producerID == nil {
			return false
		}
		if _sequenceID == nil {
			return false
		}
		if _error == nil {
			return false
		}
		if _message == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_producerID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_sequenceID)
				case 3: try decoder.decodeSingularEnumField(value: &_error)
				case 4: try decoder.decodeSingularStringField(value: &_message)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _producerID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._sequenceID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._error {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._message {
			try visitor.visitSingularStringField(value: v, fieldNumber: 4)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandSendError, rhs: Pulsar_Proto_CommandSendError) -> Bool {
		if lhs._producerID != rhs._producerID {
			return false
		}
		if lhs._sequenceID != rhs._sequenceID {
			return false
		}
		if lhs._error != rhs._error {
			return false
		}
		if lhs._message != rhs._message {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandMessage"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "consumer_id"),
		2: .standard(proto: "message_id"),
		3: .standard(proto: "redelivery_count"),
		4: .standard(proto: "ack_set"),
		5: .standard(proto: "consumer_epoch")
	]

	public var isInitialized: Bool {
		if _consumerID == nil {
			return false
		}
		if _messageID == nil {
			return false
		}
		if let v = _messageID, !v.isInitialized {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_consumerID)
				case 2: try decoder.decodeSingularMessageField(value: &_messageID)
				case 3: try decoder.decodeSingularUInt32Field(value: &_redeliveryCount)
				case 4: try decoder.decodeRepeatedInt64Field(value: &ackSet)
				case 5: try decoder.decodeSingularUInt64Field(value: &_consumerEpoch)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _consumerID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._messageID {
			try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._redeliveryCount {
			try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
		} }()
		if !ackSet.isEmpty {
			try visitor.visitRepeatedInt64Field(value: ackSet, fieldNumber: 4)
		}
		try { if let v = self._consumerEpoch {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandMessage, rhs: Pulsar_Proto_CommandMessage) -> Bool {
		if lhs._consumerID != rhs._consumerID {
			return false
		}
		if lhs._messageID != rhs._messageID {
			return false
		}
		if lhs._redeliveryCount != rhs._redeliveryCount {
			return false
		}
		if lhs.ackSet != rhs.ackSet {
			return false
		}
		if lhs._consumerEpoch != rhs._consumerEpoch {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandAck"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "consumer_id"),
		2: .standard(proto: "ack_type"),
		3: .standard(proto: "message_id"),
		4: .standard(proto: "validation_error"),
		5: .same(proto: "properties"),
		6: .standard(proto: "txnid_least_bits"),
		7: .standard(proto: "txnid_most_bits"),
		8: .standard(proto: "request_id")
	]

	public var isInitialized: Bool {
		if _consumerID == nil {
			return false
		}
		if _ackType == nil {
			return false
		}
		if !SwiftProtobuf.Internal.areAllInitialized(messageID) {
			return false
		}
		if !SwiftProtobuf.Internal.areAllInitialized(properties) {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_consumerID)
				case 2: try decoder.decodeSingularEnumField(value: &_ackType)
				case 3: try decoder.decodeRepeatedMessageField(value: &messageID)
				case 4: try decoder.decodeSingularEnumField(value: &_validationError)
				case 5: try decoder.decodeRepeatedMessageField(value: &properties)
				case 6: try decoder.decodeSingularUInt64Field(value: &_txnidLeastBits)
				case 7: try decoder.decodeSingularUInt64Field(value: &_txnidMostBits)
				case 8: try decoder.decodeSingularUInt64Field(value: &_requestID)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _consumerID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._ackType {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
		} }()
		if !messageID.isEmpty {
			try visitor.visitRepeatedMessageField(value: messageID, fieldNumber: 3)
		}
		try { if let v = self._validationError {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
		} }()
		if !properties.isEmpty {
			try visitor.visitRepeatedMessageField(value: properties, fieldNumber: 5)
		}
		try { if let v = self._txnidLeastBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
		} }()
		try { if let v = self._txnidMostBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
		} }()
		try { if let v = self._requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandAck, rhs: Pulsar_Proto_CommandAck) -> Bool {
		if lhs._consumerID != rhs._consumerID {
			return false
		}
		if lhs._ackType != rhs._ackType {
			return false
		}
		if lhs.messageID != rhs.messageID {
			return false
		}
		if lhs._validationError != rhs._validationError {
			return false
		}
		if lhs.properties != rhs.properties {
			return false
		}
		if lhs._txnidLeastBits != rhs._txnidLeastBits {
			return false
		}
		if lhs._txnidMostBits != rhs._txnidMostBits {
			return false
		}
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandAck.AckType: SwiftProtobuf._ProtoNameProviding {
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		0: .same(proto: "Individual"),
		1: .same(proto: "Cumulative")
	]
}

extension Pulsar_Proto_CommandAck.ValidationError: SwiftProtobuf._ProtoNameProviding {
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		0: .same(proto: "UncompressedSizeCorruption"),
		1: .same(proto: "DecompressionError"),
		2: .same(proto: "ChecksumMismatch"),
		3: .same(proto: "BatchDeSerializeError"),
		4: .same(proto: "DecryptionError")
	]
}

extension Pulsar_Proto_CommandAckResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandAckResponse"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "consumer_id"),
		2: .standard(proto: "txnid_least_bits"),
		3: .standard(proto: "txnid_most_bits"),
		4: .same(proto: "error"),
		5: .same(proto: "message"),
		6: .standard(proto: "request_id")
	]

	public var isInitialized: Bool {
		if _consumerID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_consumerID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_txnidLeastBits)
				case 3: try decoder.decodeSingularUInt64Field(value: &_txnidMostBits)
				case 4: try decoder.decodeSingularEnumField(value: &_error)
				case 5: try decoder.decodeSingularStringField(value: &_message)
				case 6: try decoder.decodeSingularUInt64Field(value: &_requestID)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _consumerID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._txnidLeastBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._txnidMostBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._error {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._message {
			try visitor.visitSingularStringField(value: v, fieldNumber: 5)
		} }()
		try { if let v = self._requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandAckResponse, rhs: Pulsar_Proto_CommandAckResponse) -> Bool {
		if lhs._consumerID != rhs._consumerID {
			return false
		}
		if lhs._txnidLeastBits != rhs._txnidLeastBits {
			return false
		}
		if lhs._txnidMostBits != rhs._txnidMostBits {
			return false
		}
		if lhs._error != rhs._error {
			return false
		}
		if lhs._message != rhs._message {
			return false
		}
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandActiveConsumerChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandActiveConsumerChange"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "consumer_id"),
		2: .standard(proto: "is_active")
	]

	public var isInitialized: Bool {
		if _consumerID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_consumerID)
				case 2: try decoder.decodeSingularBoolField(value: &_isActive)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _consumerID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._isActive {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandActiveConsumerChange, rhs: Pulsar_Proto_CommandActiveConsumerChange) -> Bool {
		if lhs._consumerID != rhs._consumerID {
			return false
		}
		if lhs._isActive != rhs._isActive {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandFlow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandFlow"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "consumer_id"),
		2: .same(proto: "messagePermits")
	]

	public var isInitialized: Bool {
		if _consumerID == nil {
			return false
		}
		if _messagePermits == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_consumerID)
				case 2: try decoder.decodeSingularUInt32Field(value: &_messagePermits)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _consumerID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._messagePermits {
			try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandFlow, rhs: Pulsar_Proto_CommandFlow) -> Bool {
		if lhs._consumerID != rhs._consumerID {
			return false
		}
		if lhs._messagePermits != rhs._messagePermits {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandUnsubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandUnsubscribe"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "consumer_id"),
		2: .standard(proto: "request_id"),
		3: .same(proto: "force")
	]

	public var isInitialized: Bool {
		if _consumerID == nil {
			return false
		}
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_consumerID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 3: try decoder.decodeSingularBoolField(value: &_force)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _consumerID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._force {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandUnsubscribe, rhs: Pulsar_Proto_CommandUnsubscribe) -> Bool {
		if lhs._consumerID != rhs._consumerID {
			return false
		}
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._force != rhs._force {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandSeek: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandSeek"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "consumer_id"),
		2: .standard(proto: "request_id"),
		3: .standard(proto: "message_id"),
		4: .standard(proto: "message_publish_time")
	]

	public var isInitialized: Bool {
		if _consumerID == nil {
			return false
		}
		if _requestID == nil {
			return false
		}
		if let v = _messageID, !v.isInitialized {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_consumerID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 3: try decoder.decodeSingularMessageField(value: &_messageID)
				case 4: try decoder.decodeSingularUInt64Field(value: &_messagePublishTime)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _consumerID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._messageID {
			try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._messagePublishTime {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandSeek, rhs: Pulsar_Proto_CommandSeek) -> Bool {
		if lhs._consumerID != rhs._consumerID {
			return false
		}
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._messageID != rhs._messageID {
			return false
		}
		if lhs._messagePublishTime != rhs._messagePublishTime {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandReachedEndOfTopic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandReachedEndOfTopic"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "consumer_id")
	]

	public var isInitialized: Bool {
		if _consumerID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_consumerID)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _consumerID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandReachedEndOfTopic, rhs: Pulsar_Proto_CommandReachedEndOfTopic) -> Bool {
		if lhs._consumerID != rhs._consumerID {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandTopicMigrated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandTopicMigrated"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "resource_id"),
		2: .standard(proto: "resource_type"),
		3: .same(proto: "brokerServiceUrl"),
		4: .same(proto: "brokerServiceUrlTls")
	]

	public var isInitialized: Bool {
		if _resourceID == nil {
			return false
		}
		if _resourceType == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_resourceID)
				case 2: try decoder.decodeSingularEnumField(value: &_resourceType)
				case 3: try decoder.decodeSingularStringField(value: &_brokerServiceURL)
				case 4: try decoder.decodeSingularStringField(value: &_brokerServiceURLTls)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _resourceID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._resourceType {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._brokerServiceURL {
			try visitor.visitSingularStringField(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._brokerServiceURLTls {
			try visitor.visitSingularStringField(value: v, fieldNumber: 4)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandTopicMigrated, rhs: Pulsar_Proto_CommandTopicMigrated) -> Bool {
		if lhs._resourceID != rhs._resourceID {
			return false
		}
		if lhs._resourceType != rhs._resourceType {
			return false
		}
		if lhs._brokerServiceURL != rhs._brokerServiceURL {
			return false
		}
		if lhs._brokerServiceURLTls != rhs._brokerServiceURLTls {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandTopicMigrated.ResourceType: SwiftProtobuf._ProtoNameProviding {
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		0: .same(proto: "Producer"),
		1: .same(proto: "Consumer")
	]
}

extension Pulsar_Proto_CommandCloseProducer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandCloseProducer"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "producer_id"),
		2: .standard(proto: "request_id"),
		3: .same(proto: "assignedBrokerServiceUrl"),
		4: .same(proto: "assignedBrokerServiceUrlTls")
	]

	public var isInitialized: Bool {
		if _producerID == nil {
			return false
		}
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_producerID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 3: try decoder.decodeSingularStringField(value: &_assignedBrokerServiceURL)
				case 4: try decoder.decodeSingularStringField(value: &_assignedBrokerServiceURLTls)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _producerID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._assignedBrokerServiceURL {
			try visitor.visitSingularStringField(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._assignedBrokerServiceURLTls {
			try visitor.visitSingularStringField(value: v, fieldNumber: 4)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandCloseProducer, rhs: Pulsar_Proto_CommandCloseProducer) -> Bool {
		if lhs._producerID != rhs._producerID {
			return false
		}
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._assignedBrokerServiceURL != rhs._assignedBrokerServiceURL {
			return false
		}
		if lhs._assignedBrokerServiceURLTls != rhs._assignedBrokerServiceURLTls {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandCloseConsumer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandCloseConsumer"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "consumer_id"),
		2: .standard(proto: "request_id"),
		3: .same(proto: "assignedBrokerServiceUrl"),
		4: .same(proto: "assignedBrokerServiceUrlTls")
	]

	public var isInitialized: Bool {
		if _consumerID == nil {
			return false
		}
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_consumerID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 3: try decoder.decodeSingularStringField(value: &_assignedBrokerServiceURL)
				case 4: try decoder.decodeSingularStringField(value: &_assignedBrokerServiceURLTls)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _consumerID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._assignedBrokerServiceURL {
			try visitor.visitSingularStringField(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._assignedBrokerServiceURLTls {
			try visitor.visitSingularStringField(value: v, fieldNumber: 4)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandCloseConsumer, rhs: Pulsar_Proto_CommandCloseConsumer) -> Bool {
		if lhs._consumerID != rhs._consumerID {
			return false
		}
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._assignedBrokerServiceURL != rhs._assignedBrokerServiceURL {
			return false
		}
		if lhs._assignedBrokerServiceURLTls != rhs._assignedBrokerServiceURLTls {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandRedeliverUnacknowledgedMessages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandRedeliverUnacknowledgedMessages"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "consumer_id"),
		2: .standard(proto: "message_ids"),
		3: .standard(proto: "consumer_epoch")
	]

	public var isInitialized: Bool {
		if _consumerID == nil {
			return false
		}
		if !SwiftProtobuf.Internal.areAllInitialized(messageIDs) {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_consumerID)
				case 2: try decoder.decodeRepeatedMessageField(value: &messageIDs)
				case 3: try decoder.decodeSingularUInt64Field(value: &_consumerEpoch)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _consumerID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		if !messageIDs.isEmpty {
			try visitor.visitRepeatedMessageField(value: messageIDs, fieldNumber: 2)
		}
		try { if let v = self._consumerEpoch {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandRedeliverUnacknowledgedMessages, rhs: Pulsar_Proto_CommandRedeliverUnacknowledgedMessages) -> Bool {
		if lhs._consumerID != rhs._consumerID {
			return false
		}
		if lhs.messageIDs != rhs.messageIDs {
			return false
		}
		if lhs._consumerEpoch != rhs._consumerEpoch {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandSuccess"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .same(proto: "schema")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		if let v = _schema, !v.isInitialized {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularMessageField(value: &_schema)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._schema {
			try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandSuccess, rhs: Pulsar_Proto_CommandSuccess) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._schema != rhs._schema {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandProducerSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandProducerSuccess"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "producer_name"),
		3: .standard(proto: "last_sequence_id"),
		4: .standard(proto: "schema_version"),
		5: .standard(proto: "topic_epoch"),
		6: .standard(proto: "producer_ready")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		if _producerName == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularStringField(value: &_producerName)
				case 3: try decoder.decodeSingularInt64Field(value: &_lastSequenceID)
				case 4: try decoder.decodeSingularBytesField(value: &_schemaVersion)
				case 5: try decoder.decodeSingularUInt64Field(value: &_topicEpoch)
				case 6: try decoder.decodeSingularBoolField(value: &_producerReady)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._producerName {
			try visitor.visitSingularStringField(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._lastSequenceID {
			try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._schemaVersion {
			try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._topicEpoch {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
		} }()
		try { if let v = self._producerReady {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandProducerSuccess, rhs: Pulsar_Proto_CommandProducerSuccess) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._producerName != rhs._producerName {
			return false
		}
		if lhs._lastSequenceID != rhs._lastSequenceID {
			return false
		}
		if lhs._schemaVersion != rhs._schemaVersion {
			return false
		}
		if lhs._topicEpoch != rhs._topicEpoch {
			return false
		}
		if lhs._producerReady != rhs._producerReady {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandError"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .same(proto: "error"),
		3: .same(proto: "message")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		if _error == nil {
			return false
		}
		if _message == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularEnumField(value: &_error)
				case 3: try decoder.decodeSingularStringField(value: &_message)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._error {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._message {
			try visitor.visitSingularStringField(value: v, fieldNumber: 3)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandError, rhs: Pulsar_Proto_CommandError) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._error != rhs._error {
			return false
		}
		if lhs._message != rhs._message {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandPing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandPing"
	static let _protobuf_nameMap = SwiftProtobuf._NameMap()

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		// Load everything into unknown fields
		while try decoder.nextFieldNumber() != nil { }
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandPing, rhs: Pulsar_Proto_CommandPing) -> Bool {
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandPong: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandPong"
	static let _protobuf_nameMap = SwiftProtobuf._NameMap()

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		// Load everything into unknown fields
		while try decoder.nextFieldNumber() != nil { }
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandPong, rhs: Pulsar_Proto_CommandPong) -> Bool {
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandConsumerStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandConsumerStats"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		4: .standard(proto: "consumer_id")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		if _consumerID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 4: try decoder.decodeSingularUInt64Field(value: &_consumerID)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._consumerID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandConsumerStats, rhs: Pulsar_Proto_CommandConsumerStats) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._consumerID != rhs._consumerID {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandConsumerStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandConsumerStatsResponse"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "error_code"),
		3: .standard(proto: "error_message"),
		4: .same(proto: "msgRateOut"),
		5: .same(proto: "msgThroughputOut"),
		6: .same(proto: "msgRateRedeliver"),
		7: .same(proto: "consumerName"),
		8: .same(proto: "availablePermits"),
		9: .same(proto: "unackedMessages"),
		10: .same(proto: "blockedConsumerOnUnackedMsgs"),
		11: .same(proto: "address"),
		12: .same(proto: "connectedSince"),
		13: .same(proto: "type"),
		14: .same(proto: "msgRateExpired"),
		15: .same(proto: "msgBacklog"),
		16: .same(proto: "messageAckRate")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularEnumField(value: &_errorCode)
				case 3: try decoder.decodeSingularStringField(value: &_errorMessage)
				case 4: try decoder.decodeSingularDoubleField(value: &_msgRateOut)
				case 5: try decoder.decodeSingularDoubleField(value: &_msgThroughputOut)
				case 6: try decoder.decodeSingularDoubleField(value: &_msgRateRedeliver)
				case 7: try decoder.decodeSingularStringField(value: &_consumerName)
				case 8: try decoder.decodeSingularUInt64Field(value: &_availablePermits)
				case 9: try decoder.decodeSingularUInt64Field(value: &_unackedMessages)
				case 10: try decoder.decodeSingularBoolField(value: &_blockedConsumerOnUnackedMsgs)
				case 11: try decoder.decodeSingularStringField(value: &_address)
				case 12: try decoder.decodeSingularStringField(value: &_connectedSince)
				case 13: try decoder.decodeSingularStringField(value: &_type)
				case 14: try decoder.decodeSingularDoubleField(value: &_msgRateExpired)
				case 15: try decoder.decodeSingularUInt64Field(value: &_msgBacklog)
				case 16: try decoder.decodeSingularDoubleField(value: &_messageAckRate)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._errorCode {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._errorMessage {
			try visitor.visitSingularStringField(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._msgRateOut {
			try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._msgThroughputOut {
			try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
		} }()
		try { if let v = self._msgRateRedeliver {
			try visitor.visitSingularDoubleField(value: v, fieldNumber: 6)
		} }()
		try { if let v = self._consumerName {
			try visitor.visitSingularStringField(value: v, fieldNumber: 7)
		} }()
		try { if let v = self._availablePermits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
		} }()
		try { if let v = self._unackedMessages {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
		} }()
		try { if let v = self._blockedConsumerOnUnackedMsgs {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
		} }()
		try { if let v = self._address {
			try visitor.visitSingularStringField(value: v, fieldNumber: 11)
		} }()
		try { if let v = self._connectedSince {
			try visitor.visitSingularStringField(value: v, fieldNumber: 12)
		} }()
		try { if let v = self._type {
			try visitor.visitSingularStringField(value: v, fieldNumber: 13)
		} }()
		try { if let v = self._msgRateExpired {
			try visitor.visitSingularDoubleField(value: v, fieldNumber: 14)
		} }()
		try { if let v = self._msgBacklog {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 15)
		} }()
		try { if let v = self._messageAckRate {
			try visitor.visitSingularDoubleField(value: v, fieldNumber: 16)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandConsumerStatsResponse, rhs: Pulsar_Proto_CommandConsumerStatsResponse) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._errorCode != rhs._errorCode {
			return false
		}
		if lhs._errorMessage != rhs._errorMessage {
			return false
		}
		if lhs._msgRateOut != rhs._msgRateOut {
			return false
		}
		if lhs._msgThroughputOut != rhs._msgThroughputOut {
			return false
		}
		if lhs._msgRateRedeliver != rhs._msgRateRedeliver {
			return false
		}
		if lhs._consumerName != rhs._consumerName {
			return false
		}
		if lhs._availablePermits != rhs._availablePermits {
			return false
		}
		if lhs._unackedMessages != rhs._unackedMessages {
			return false
		}
		if lhs._blockedConsumerOnUnackedMsgs != rhs._blockedConsumerOnUnackedMsgs {
			return false
		}
		if lhs._address != rhs._address {
			return false
		}
		if lhs._connectedSince != rhs._connectedSince {
			return false
		}
		if lhs._type != rhs._type {
			return false
		}
		if lhs._msgRateExpired != rhs._msgRateExpired {
			return false
		}
		if lhs._msgBacklog != rhs._msgBacklog {
			return false
		}
		if lhs._messageAckRate != rhs._messageAckRate {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandGetLastMessageID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandGetLastMessageId"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "consumer_id"),
		2: .standard(proto: "request_id")
	]

	public var isInitialized: Bool {
		if _consumerID == nil {
			return false
		}
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_consumerID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_requestID)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _consumerID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandGetLastMessageID, rhs: Pulsar_Proto_CommandGetLastMessageID) -> Bool {
		if lhs._consumerID != rhs._consumerID {
			return false
		}
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandGetLastMessageIDResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandGetLastMessageIdResponse"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "last_message_id"),
		2: .standard(proto: "request_id"),
		3: .standard(proto: "consumer_mark_delete_position")
	]

	public var isInitialized: Bool {
		if _lastMessageID == nil {
			return false
		}
		if _requestID == nil {
			return false
		}
		if let v = _lastMessageID, !v.isInitialized {
			return false
		}
		if let v = _consumerMarkDeletePosition, !v.isInitialized {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularMessageField(value: &_lastMessageID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 3: try decoder.decodeSingularMessageField(value: &_consumerMarkDeletePosition)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _lastMessageID {
			try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
		}
		try { if let v = self._requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._consumerMarkDeletePosition {
			try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandGetLastMessageIDResponse, rhs: Pulsar_Proto_CommandGetLastMessageIDResponse) -> Bool {
		if lhs._lastMessageID != rhs._lastMessageID {
			return false
		}
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._consumerMarkDeletePosition != rhs._consumerMarkDeletePosition {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandGetTopicsOfNamespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandGetTopicsOfNamespace"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .same(proto: "namespace"),
		3: .same(proto: "mode"),
		4: .standard(proto: "topics_pattern"),
		5: .standard(proto: "topics_hash")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		if _namespace == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularStringField(value: &_namespace)
				case 3: try decoder.decodeSingularEnumField(value: &_mode)
				case 4: try decoder.decodeSingularStringField(value: &_topicsPattern)
				case 5: try decoder.decodeSingularStringField(value: &_topicsHash)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._namespace {
			try visitor.visitSingularStringField(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._mode {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._topicsPattern {
			try visitor.visitSingularStringField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._topicsHash {
			try visitor.visitSingularStringField(value: v, fieldNumber: 5)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandGetTopicsOfNamespace, rhs: Pulsar_Proto_CommandGetTopicsOfNamespace) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._namespace != rhs._namespace {
			return false
		}
		if lhs._mode != rhs._mode {
			return false
		}
		if lhs._topicsPattern != rhs._topicsPattern {
			return false
		}
		if lhs._topicsHash != rhs._topicsHash {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandGetTopicsOfNamespace.Mode: SwiftProtobuf._ProtoNameProviding {
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		0: .same(proto: "PERSISTENT"),
		1: .same(proto: "NON_PERSISTENT"),
		2: .same(proto: "ALL")
	]
}

extension Pulsar_Proto_CommandGetTopicsOfNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandGetTopicsOfNamespaceResponse"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .same(proto: "topics"),
		3: .same(proto: "filtered"),
		4: .standard(proto: "topics_hash"),
		5: .same(proto: "changed")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeRepeatedStringField(value: &topics)
				case 3: try decoder.decodeSingularBoolField(value: &_filtered)
				case 4: try decoder.decodeSingularStringField(value: &_topicsHash)
				case 5: try decoder.decodeSingularBoolField(value: &_changed)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		if !topics.isEmpty {
			try visitor.visitRepeatedStringField(value: topics, fieldNumber: 2)
		}
		try { if let v = self._filtered {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._topicsHash {
			try visitor.visitSingularStringField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._changed {
			try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandGetTopicsOfNamespaceResponse, rhs: Pulsar_Proto_CommandGetTopicsOfNamespaceResponse) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs.topics != rhs.topics {
			return false
		}
		if lhs._filtered != rhs._filtered {
			return false
		}
		if lhs._topicsHash != rhs._topicsHash {
			return false
		}
		if lhs._changed != rhs._changed {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandWatchTopicList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandWatchTopicList"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "watcher_id"),
		3: .same(proto: "namespace"),
		4: .standard(proto: "topics_pattern"),
		5: .standard(proto: "topics_hash")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		if _watcherID == nil {
			return false
		}
		if _namespace == nil {
			return false
		}
		if _topicsPattern == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_watcherID)
				case 3: try decoder.decodeSingularStringField(value: &_namespace)
				case 4: try decoder.decodeSingularStringField(value: &_topicsPattern)
				case 5: try decoder.decodeSingularStringField(value: &_topicsHash)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._watcherID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._namespace {
			try visitor.visitSingularStringField(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._topicsPattern {
			try visitor.visitSingularStringField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._topicsHash {
			try visitor.visitSingularStringField(value: v, fieldNumber: 5)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandWatchTopicList, rhs: Pulsar_Proto_CommandWatchTopicList) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._watcherID != rhs._watcherID {
			return false
		}
		if lhs._namespace != rhs._namespace {
			return false
		}
		if lhs._topicsPattern != rhs._topicsPattern {
			return false
		}
		if lhs._topicsHash != rhs._topicsHash {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandWatchTopicListSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandWatchTopicListSuccess"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "watcher_id"),
		3: .same(proto: "topic"),
		4: .standard(proto: "topics_hash")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		if _watcherID == nil {
			return false
		}
		if _topicsHash == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_watcherID)
				case 3: try decoder.decodeRepeatedStringField(value: &topic)
				case 4: try decoder.decodeSingularStringField(value: &_topicsHash)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._watcherID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		if !topic.isEmpty {
			try visitor.visitRepeatedStringField(value: topic, fieldNumber: 3)
		}
		try { if let v = self._topicsHash {
			try visitor.visitSingularStringField(value: v, fieldNumber: 4)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandWatchTopicListSuccess, rhs: Pulsar_Proto_CommandWatchTopicListSuccess) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._watcherID != rhs._watcherID {
			return false
		}
		if lhs.topic != rhs.topic {
			return false
		}
		if lhs._topicsHash != rhs._topicsHash {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandWatchTopicUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandWatchTopicUpdate"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "watcher_id"),
		2: .standard(proto: "new_topics"),
		3: .standard(proto: "deleted_topics"),
		4: .standard(proto: "topics_hash")
	]

	public var isInitialized: Bool {
		if _watcherID == nil {
			return false
		}
		if _topicsHash == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_watcherID)
				case 2: try decoder.decodeRepeatedStringField(value: &newTopics)
				case 3: try decoder.decodeRepeatedStringField(value: &deletedTopics)
				case 4: try decoder.decodeSingularStringField(value: &_topicsHash)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _watcherID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		if !newTopics.isEmpty {
			try visitor.visitRepeatedStringField(value: newTopics, fieldNumber: 2)
		}
		if !deletedTopics.isEmpty {
			try visitor.visitRepeatedStringField(value: deletedTopics, fieldNumber: 3)
		}
		try { if let v = self._topicsHash {
			try visitor.visitSingularStringField(value: v, fieldNumber: 4)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandWatchTopicUpdate, rhs: Pulsar_Proto_CommandWatchTopicUpdate) -> Bool {
		if lhs._watcherID != rhs._watcherID {
			return false
		}
		if lhs.newTopics != rhs.newTopics {
			return false
		}
		if lhs.deletedTopics != rhs.deletedTopics {
			return false
		}
		if lhs._topicsHash != rhs._topicsHash {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandWatchTopicListClose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandWatchTopicListClose"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "watcher_id")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		if _watcherID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_watcherID)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._watcherID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandWatchTopicListClose, rhs: Pulsar_Proto_CommandWatchTopicListClose) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._watcherID != rhs._watcherID {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandGetSchema: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandGetSchema"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .same(proto: "topic"),
		3: .standard(proto: "schema_version")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		if _topic == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularStringField(value: &_topic)
				case 3: try decoder.decodeSingularBytesField(value: &_schemaVersion)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._topic {
			try visitor.visitSingularStringField(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._schemaVersion {
			try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandGetSchema, rhs: Pulsar_Proto_CommandGetSchema) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._topic != rhs._topic {
			return false
		}
		if lhs._schemaVersion != rhs._schemaVersion {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandGetSchemaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandGetSchemaResponse"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "error_code"),
		3: .standard(proto: "error_message"),
		4: .same(proto: "schema"),
		5: .standard(proto: "schema_version")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		if let v = _schema, !v.isInitialized {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularEnumField(value: &_errorCode)
				case 3: try decoder.decodeSingularStringField(value: &_errorMessage)
				case 4: try decoder.decodeSingularMessageField(value: &_schema)
				case 5: try decoder.decodeSingularBytesField(value: &_schemaVersion)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._errorCode {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._errorMessage {
			try visitor.visitSingularStringField(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._schema {
			try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._schemaVersion {
			try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandGetSchemaResponse, rhs: Pulsar_Proto_CommandGetSchemaResponse) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._errorCode != rhs._errorCode {
			return false
		}
		if lhs._errorMessage != rhs._errorMessage {
			return false
		}
		if lhs._schema != rhs._schema {
			return false
		}
		if lhs._schemaVersion != rhs._schemaVersion {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandGetOrCreateSchema: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandGetOrCreateSchema"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .same(proto: "topic"),
		3: .same(proto: "schema")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		if _topic == nil {
			return false
		}
		if _schema == nil {
			return false
		}
		if let v = _schema, !v.isInitialized {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularStringField(value: &_topic)
				case 3: try decoder.decodeSingularMessageField(value: &_schema)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._topic {
			try visitor.visitSingularStringField(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._schema {
			try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandGetOrCreateSchema, rhs: Pulsar_Proto_CommandGetOrCreateSchema) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._topic != rhs._topic {
			return false
		}
		if lhs._schema != rhs._schema {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandGetOrCreateSchemaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandGetOrCreateSchemaResponse"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "error_code"),
		3: .standard(proto: "error_message"),
		4: .standard(proto: "schema_version")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularEnumField(value: &_errorCode)
				case 3: try decoder.decodeSingularStringField(value: &_errorMessage)
				case 4: try decoder.decodeSingularBytesField(value: &_schemaVersion)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._errorCode {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._errorMessage {
			try visitor.visitSingularStringField(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._schemaVersion {
			try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandGetOrCreateSchemaResponse, rhs: Pulsar_Proto_CommandGetOrCreateSchemaResponse) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._errorCode != rhs._errorCode {
			return false
		}
		if lhs._errorMessage != rhs._errorMessage {
			return false
		}
		if lhs._schemaVersion != rhs._schemaVersion {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandTcClientConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandTcClientConnectRequest"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "tc_id")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		if _tcID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_tcID)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._tcID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandTcClientConnectRequest, rhs: Pulsar_Proto_CommandTcClientConnectRequest) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._tcID != rhs._tcID {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandTcClientConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandTcClientConnectResponse"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .same(proto: "error"),
		3: .same(proto: "message")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularEnumField(value: &_error)
				case 3: try decoder.decodeSingularStringField(value: &_message)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._error {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._message {
			try visitor.visitSingularStringField(value: v, fieldNumber: 3)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandTcClientConnectResponse, rhs: Pulsar_Proto_CommandTcClientConnectResponse) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._error != rhs._error {
			return false
		}
		if lhs._message != rhs._message {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandNewTxn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandNewTxn"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "txn_ttl_seconds"),
		3: .standard(proto: "tc_id")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_txnTtlSeconds)
				case 3: try decoder.decodeSingularUInt64Field(value: &_tcID)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._txnTtlSeconds {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._tcID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandNewTxn, rhs: Pulsar_Proto_CommandNewTxn) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._txnTtlSeconds != rhs._txnTtlSeconds {
			return false
		}
		if lhs._tcID != rhs._tcID {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandNewTxnResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandNewTxnResponse"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "txnid_least_bits"),
		3: .standard(proto: "txnid_most_bits"),
		4: .same(proto: "error"),
		5: .same(proto: "message")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_txnidLeastBits)
				case 3: try decoder.decodeSingularUInt64Field(value: &_txnidMostBits)
				case 4: try decoder.decodeSingularEnumField(value: &_error)
				case 5: try decoder.decodeSingularStringField(value: &_message)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._txnidLeastBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._txnidMostBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._error {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._message {
			try visitor.visitSingularStringField(value: v, fieldNumber: 5)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandNewTxnResponse, rhs: Pulsar_Proto_CommandNewTxnResponse) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._txnidLeastBits != rhs._txnidLeastBits {
			return false
		}
		if lhs._txnidMostBits != rhs._txnidMostBits {
			return false
		}
		if lhs._error != rhs._error {
			return false
		}
		if lhs._message != rhs._message {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandAddPartitionToTxn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandAddPartitionToTxn"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "txnid_least_bits"),
		3: .standard(proto: "txnid_most_bits"),
		4: .same(proto: "partitions")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_txnidLeastBits)
				case 3: try decoder.decodeSingularUInt64Field(value: &_txnidMostBits)
				case 4: try decoder.decodeRepeatedStringField(value: &partitions)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._txnidLeastBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._txnidMostBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
		} }()
		if !partitions.isEmpty {
			try visitor.visitRepeatedStringField(value: partitions, fieldNumber: 4)
		}
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandAddPartitionToTxn, rhs: Pulsar_Proto_CommandAddPartitionToTxn) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._txnidLeastBits != rhs._txnidLeastBits {
			return false
		}
		if lhs._txnidMostBits != rhs._txnidMostBits {
			return false
		}
		if lhs.partitions != rhs.partitions {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandAddPartitionToTxnResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandAddPartitionToTxnResponse"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "txnid_least_bits"),
		3: .standard(proto: "txnid_most_bits"),
		4: .same(proto: "error"),
		5: .same(proto: "message")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_txnidLeastBits)
				case 3: try decoder.decodeSingularUInt64Field(value: &_txnidMostBits)
				case 4: try decoder.decodeSingularEnumField(value: &_error)
				case 5: try decoder.decodeSingularStringField(value: &_message)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._txnidLeastBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._txnidMostBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._error {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._message {
			try visitor.visitSingularStringField(value: v, fieldNumber: 5)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandAddPartitionToTxnResponse, rhs: Pulsar_Proto_CommandAddPartitionToTxnResponse) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._txnidLeastBits != rhs._txnidLeastBits {
			return false
		}
		if lhs._txnidMostBits != rhs._txnidMostBits {
			return false
		}
		if lhs._error != rhs._error {
			return false
		}
		if lhs._message != rhs._message {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_Subscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".Subscription"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .same(proto: "topic"),
		2: .same(proto: "subscription")
	]

	public var isInitialized: Bool {
		if _topic == nil {
			return false
		}
		if _subscription == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularStringField(value: &_topic)
				case 2: try decoder.decodeSingularStringField(value: &_subscription)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _topic {
			try visitor.visitSingularStringField(value: v, fieldNumber: 1)
		}
		try { if let v = self._subscription {
			try visitor.visitSingularStringField(value: v, fieldNumber: 2)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_Subscription, rhs: Pulsar_Proto_Subscription) -> Bool {
		if lhs._topic != rhs._topic {
			return false
		}
		if lhs._subscription != rhs._subscription {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandAddSubscriptionToTxn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandAddSubscriptionToTxn"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "txnid_least_bits"),
		3: .standard(proto: "txnid_most_bits"),
		4: .same(proto: "subscription")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		if !SwiftProtobuf.Internal.areAllInitialized(subscription) {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_txnidLeastBits)
				case 3: try decoder.decodeSingularUInt64Field(value: &_txnidMostBits)
				case 4: try decoder.decodeRepeatedMessageField(value: &subscription)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._txnidLeastBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._txnidMostBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
		} }()
		if !subscription.isEmpty {
			try visitor.visitRepeatedMessageField(value: subscription, fieldNumber: 4)
		}
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandAddSubscriptionToTxn, rhs: Pulsar_Proto_CommandAddSubscriptionToTxn) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._txnidLeastBits != rhs._txnidLeastBits {
			return false
		}
		if lhs._txnidMostBits != rhs._txnidMostBits {
			return false
		}
		if lhs.subscription != rhs.subscription {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandAddSubscriptionToTxnResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandAddSubscriptionToTxnResponse"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "txnid_least_bits"),
		3: .standard(proto: "txnid_most_bits"),
		4: .same(proto: "error"),
		5: .same(proto: "message")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_txnidLeastBits)
				case 3: try decoder.decodeSingularUInt64Field(value: &_txnidMostBits)
				case 4: try decoder.decodeSingularEnumField(value: &_error)
				case 5: try decoder.decodeSingularStringField(value: &_message)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._txnidLeastBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._txnidMostBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._error {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._message {
			try visitor.visitSingularStringField(value: v, fieldNumber: 5)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandAddSubscriptionToTxnResponse, rhs: Pulsar_Proto_CommandAddSubscriptionToTxnResponse) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._txnidLeastBits != rhs._txnidLeastBits {
			return false
		}
		if lhs._txnidMostBits != rhs._txnidMostBits {
			return false
		}
		if lhs._error != rhs._error {
			return false
		}
		if lhs._message != rhs._message {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandEndTxn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandEndTxn"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "txnid_least_bits"),
		3: .standard(proto: "txnid_most_bits"),
		4: .standard(proto: "txn_action")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_txnidLeastBits)
				case 3: try decoder.decodeSingularUInt64Field(value: &_txnidMostBits)
				case 4: try decoder.decodeSingularEnumField(value: &_txnAction)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._txnidLeastBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._txnidMostBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._txnAction {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandEndTxn, rhs: Pulsar_Proto_CommandEndTxn) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._txnidLeastBits != rhs._txnidLeastBits {
			return false
		}
		if lhs._txnidMostBits != rhs._txnidMostBits {
			return false
		}
		if lhs._txnAction != rhs._txnAction {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandEndTxnResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandEndTxnResponse"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "txnid_least_bits"),
		3: .standard(proto: "txnid_most_bits"),
		4: .same(proto: "error"),
		5: .same(proto: "message")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_txnidLeastBits)
				case 3: try decoder.decodeSingularUInt64Field(value: &_txnidMostBits)
				case 4: try decoder.decodeSingularEnumField(value: &_error)
				case 5: try decoder.decodeSingularStringField(value: &_message)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._txnidLeastBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._txnidMostBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._error {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._message {
			try visitor.visitSingularStringField(value: v, fieldNumber: 5)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandEndTxnResponse, rhs: Pulsar_Proto_CommandEndTxnResponse) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._txnidLeastBits != rhs._txnidLeastBits {
			return false
		}
		if lhs._txnidMostBits != rhs._txnidMostBits {
			return false
		}
		if lhs._error != rhs._error {
			return false
		}
		if lhs._message != rhs._message {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandEndTxnOnPartition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandEndTxnOnPartition"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "txnid_least_bits"),
		3: .standard(proto: "txnid_most_bits"),
		4: .same(proto: "topic"),
		5: .standard(proto: "txn_action"),
		6: .standard(proto: "txnid_least_bits_of_low_watermark")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_txnidLeastBits)
				case 3: try decoder.decodeSingularUInt64Field(value: &_txnidMostBits)
				case 4: try decoder.decodeSingularStringField(value: &_topic)
				case 5: try decoder.decodeSingularEnumField(value: &_txnAction)
				case 6: try decoder.decodeSingularUInt64Field(value: &_txnidLeastBitsOfLowWatermark)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._txnidLeastBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._txnidMostBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._topic {
			try visitor.visitSingularStringField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._txnAction {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
		} }()
		try { if let v = self._txnidLeastBitsOfLowWatermark {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandEndTxnOnPartition, rhs: Pulsar_Proto_CommandEndTxnOnPartition) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._txnidLeastBits != rhs._txnidLeastBits {
			return false
		}
		if lhs._txnidMostBits != rhs._txnidMostBits {
			return false
		}
		if lhs._topic != rhs._topic {
			return false
		}
		if lhs._txnAction != rhs._txnAction {
			return false
		}
		if lhs._txnidLeastBitsOfLowWatermark != rhs._txnidLeastBitsOfLowWatermark {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandEndTxnOnPartitionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandEndTxnOnPartitionResponse"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "txnid_least_bits"),
		3: .standard(proto: "txnid_most_bits"),
		4: .same(proto: "error"),
		5: .same(proto: "message")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_txnidLeastBits)
				case 3: try decoder.decodeSingularUInt64Field(value: &_txnidMostBits)
				case 4: try decoder.decodeSingularEnumField(value: &_error)
				case 5: try decoder.decodeSingularStringField(value: &_message)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._txnidLeastBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._txnidMostBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._error {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._message {
			try visitor.visitSingularStringField(value: v, fieldNumber: 5)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandEndTxnOnPartitionResponse, rhs: Pulsar_Proto_CommandEndTxnOnPartitionResponse) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._txnidLeastBits != rhs._txnidLeastBits {
			return false
		}
		if lhs._txnidMostBits != rhs._txnidMostBits {
			return false
		}
		if lhs._error != rhs._error {
			return false
		}
		if lhs._message != rhs._message {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandEndTxnOnSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandEndTxnOnSubscription"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "txnid_least_bits"),
		3: .standard(proto: "txnid_most_bits"),
		4: .same(proto: "subscription"),
		5: .standard(proto: "txn_action"),
		6: .standard(proto: "txnid_least_bits_of_low_watermark")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		if let v = _subscription, !v.isInitialized {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_txnidLeastBits)
				case 3: try decoder.decodeSingularUInt64Field(value: &_txnidMostBits)
				case 4: try decoder.decodeSingularMessageField(value: &_subscription)
				case 5: try decoder.decodeSingularEnumField(value: &_txnAction)
				case 6: try decoder.decodeSingularUInt64Field(value: &_txnidLeastBitsOfLowWatermark)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._txnidLeastBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._txnidMostBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._subscription {
			try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._txnAction {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
		} }()
		try { if let v = self._txnidLeastBitsOfLowWatermark {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandEndTxnOnSubscription, rhs: Pulsar_Proto_CommandEndTxnOnSubscription) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._txnidLeastBits != rhs._txnidLeastBits {
			return false
		}
		if lhs._txnidMostBits != rhs._txnidMostBits {
			return false
		}
		if lhs._subscription != rhs._subscription {
			return false
		}
		if lhs._txnAction != rhs._txnAction {
			return false
		}
		if lhs._txnidLeastBitsOfLowWatermark != rhs._txnidLeastBitsOfLowWatermark {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_CommandEndTxnOnSubscriptionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".CommandEndTxnOnSubscriptionResponse"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "request_id"),
		2: .standard(proto: "txnid_least_bits"),
		3: .standard(proto: "txnid_most_bits"),
		4: .same(proto: "error"),
		5: .same(proto: "message")
	]

	public var isInitialized: Bool {
		if _requestID == nil {
			return false
		}
		return true
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
				case 1: try decoder.decodeSingularUInt64Field(value: &_requestID)
				case 2: try decoder.decodeSingularUInt64Field(value: &_txnidLeastBits)
				case 3: try decoder.decodeSingularUInt64Field(value: &_txnidMostBits)
				case 4: try decoder.decodeSingularEnumField(value: &_error)
				case 5: try decoder.decodeSingularStringField(value: &_message)
				default: break
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if let v = _requestID {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
		}
		try { if let v = self._txnidLeastBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
		} }()
		try { if let v = self._txnidMostBits {
			try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
		} }()
		try { if let v = self._error {
			try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
		} }()
		try { if let v = self._message {
			try visitor.visitSingularStringField(value: v, fieldNumber: 5)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_CommandEndTxnOnSubscriptionResponse, rhs: Pulsar_Proto_CommandEndTxnOnSubscriptionResponse) -> Bool {
		if lhs._requestID != rhs._requestID {
			return false
		}
		if lhs._txnidLeastBits != rhs._txnidLeastBits {
			return false
		}
		if lhs._txnidMostBits != rhs._txnidMostBits {
			return false
		}
		if lhs._error != rhs._error {
			return false
		}
		if lhs._message != rhs._message {
			return false
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_BaseCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".BaseCommand"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .same(proto: "type"),
		2: .same(proto: "connect"),
		3: .same(proto: "connected"),
		4: .same(proto: "subscribe"),
		5: .same(proto: "producer"),
		6: .same(proto: "send"),
		7: .standard(proto: "send_receipt"),
		8: .standard(proto: "send_error"),
		9: .same(proto: "message"),
		10: .same(proto: "ack"),
		11: .same(proto: "flow"),
		12: .same(proto: "unsubscribe"),
		13: .same(proto: "success"),
		14: .same(proto: "error"),
		15: .standard(proto: "close_producer"),
		16: .standard(proto: "close_consumer"),
		17: .standard(proto: "producer_success"),
		18: .same(proto: "ping"),
		19: .same(proto: "pong"),
		20: .same(proto: "redeliverUnacknowledgedMessages"),
		21: .same(proto: "partitionMetadata"),
		22: .same(proto: "partitionMetadataResponse"),
		23: .same(proto: "lookupTopic"),
		24: .same(proto: "lookupTopicResponse"),
		25: .same(proto: "consumerStats"),
		26: .same(proto: "consumerStatsResponse"),
		27: .same(proto: "reachedEndOfTopic"),
		28: .same(proto: "seek"),
		29: .same(proto: "getLastMessageId"),
		30: .same(proto: "getLastMessageIdResponse"),
		31: .standard(proto: "active_consumer_change"),
		32: .same(proto: "getTopicsOfNamespace"),
		33: .same(proto: "getTopicsOfNamespaceResponse"),
		34: .same(proto: "getSchema"),
		35: .same(proto: "getSchemaResponse"),
		36: .same(proto: "authChallenge"),
		37: .same(proto: "authResponse"),
		38: .same(proto: "ackResponse"),
		39: .same(proto: "getOrCreateSchema"),
		40: .same(proto: "getOrCreateSchemaResponse"),
		50: .same(proto: "newTxn"),
		51: .same(proto: "newTxnResponse"),
		52: .same(proto: "addPartitionToTxn"),
		53: .same(proto: "addPartitionToTxnResponse"),
		54: .same(proto: "addSubscriptionToTxn"),
		55: .same(proto: "addSubscriptionToTxnResponse"),
		56: .same(proto: "endTxn"),
		57: .same(proto: "endTxnResponse"),
		58: .same(proto: "endTxnOnPartition"),
		59: .same(proto: "endTxnOnPartitionResponse"),
		60: .same(proto: "endTxnOnSubscription"),
		61: .same(proto: "endTxnOnSubscriptionResponse"),
		62: .same(proto: "tcClientConnectRequest"),
		63: .same(proto: "tcClientConnectResponse"),
		64: .same(proto: "watchTopicList"),
		65: .same(proto: "watchTopicListSuccess"),
		66: .same(proto: "watchTopicUpdate"),
		67: .same(proto: "watchTopicListClose"),
		68: .same(proto: "topicMigrated")
	]

	fileprivate class _StorageClass {
		var _type: Pulsar_Proto_BaseCommand.TypeEnum?
		var _connect: Pulsar_Proto_CommandConnect?
		var _connected: Pulsar_Proto_CommandConnected?
		var _subscribe: Pulsar_Proto_CommandSubscribe?
		var _producer: Pulsar_Proto_CommandProducer?
		var _send: Pulsar_Proto_CommandSend?
		var _sendReceipt: Pulsar_Proto_CommandSendReceipt?
		var _sendError: Pulsar_Proto_CommandSendError?
		var _message: Pulsar_Proto_CommandMessage?
		var _ack: Pulsar_Proto_CommandAck?
		var _flow: Pulsar_Proto_CommandFlow?
		var _unsubscribe: Pulsar_Proto_CommandUnsubscribe?
		var _success: Pulsar_Proto_CommandSuccess?
		var _error: Pulsar_Proto_CommandError?
		var _closeProducer: Pulsar_Proto_CommandCloseProducer?
		var _closeConsumer: Pulsar_Proto_CommandCloseConsumer?
		var _producerSuccess: Pulsar_Proto_CommandProducerSuccess?
		var _ping: Pulsar_Proto_CommandPing?
		var _pong: Pulsar_Proto_CommandPong?
		var _redeliverUnacknowledgedMessages: Pulsar_Proto_CommandRedeliverUnacknowledgedMessages?
		var _partitionMetadata: Pulsar_Proto_CommandPartitionedTopicMetadata?
		var _partitionMetadataResponse: Pulsar_Proto_CommandPartitionedTopicMetadataResponse?
		var _lookupTopic: Pulsar_Proto_CommandLookupTopic?
		var _lookupTopicResponse: Pulsar_Proto_CommandLookupTopicResponse?
		var _consumerStats: Pulsar_Proto_CommandConsumerStats?
		var _consumerStatsResponse: Pulsar_Proto_CommandConsumerStatsResponse?
		var _reachedEndOfTopic: Pulsar_Proto_CommandReachedEndOfTopic?
		var _seek: Pulsar_Proto_CommandSeek?
		var _getLastMessageID: Pulsar_Proto_CommandGetLastMessageID?
		var _getLastMessageIDResponse: Pulsar_Proto_CommandGetLastMessageIDResponse?
		var _activeConsumerChange: Pulsar_Proto_CommandActiveConsumerChange?
		var _getTopicsOfNamespace: Pulsar_Proto_CommandGetTopicsOfNamespace?
		var _getTopicsOfNamespaceResponse: Pulsar_Proto_CommandGetTopicsOfNamespaceResponse?
		var _getSchema: Pulsar_Proto_CommandGetSchema?
		var _getSchemaResponse: Pulsar_Proto_CommandGetSchemaResponse?
		var _authChallenge: Pulsar_Proto_CommandAuthChallenge?
		var _authResponse: Pulsar_Proto_CommandAuthResponse?
		var _ackResponse: Pulsar_Proto_CommandAckResponse?
		var _getOrCreateSchema: Pulsar_Proto_CommandGetOrCreateSchema?
		var _getOrCreateSchemaResponse: Pulsar_Proto_CommandGetOrCreateSchemaResponse?
		var _newTxn: Pulsar_Proto_CommandNewTxn?
		var _newTxnResponse: Pulsar_Proto_CommandNewTxnResponse?
		var _addPartitionToTxn: Pulsar_Proto_CommandAddPartitionToTxn?
		var _addPartitionToTxnResponse: Pulsar_Proto_CommandAddPartitionToTxnResponse?
		var _addSubscriptionToTxn: Pulsar_Proto_CommandAddSubscriptionToTxn?
		var _addSubscriptionToTxnResponse: Pulsar_Proto_CommandAddSubscriptionToTxnResponse?
		var _endTxn: Pulsar_Proto_CommandEndTxn?
		var _endTxnResponse: Pulsar_Proto_CommandEndTxnResponse?
		var _endTxnOnPartition: Pulsar_Proto_CommandEndTxnOnPartition?
		var _endTxnOnPartitionResponse: Pulsar_Proto_CommandEndTxnOnPartitionResponse?
		var _endTxnOnSubscription: Pulsar_Proto_CommandEndTxnOnSubscription?
		var _endTxnOnSubscriptionResponse: Pulsar_Proto_CommandEndTxnOnSubscriptionResponse?
		var _tcClientConnectRequest: Pulsar_Proto_CommandTcClientConnectRequest?
		var _tcClientConnectResponse: Pulsar_Proto_CommandTcClientConnectResponse?
		var _watchTopicList: Pulsar_Proto_CommandWatchTopicList?
		var _watchTopicListSuccess: Pulsar_Proto_CommandWatchTopicListSuccess?
		var _watchTopicUpdate: Pulsar_Proto_CommandWatchTopicUpdate?
		var _watchTopicListClose: Pulsar_Proto_CommandWatchTopicListClose?
		var _topicMigrated: Pulsar_Proto_CommandTopicMigrated?

		#if swift(>=5.10)
			// This property is used as the initial default value for new instances of the type.
			// The type itself is protecting the reference to its storage via CoW semantics.
			// This will force a copy to be made of this reference when the first mutation occurs;
			// hence, it is safe to mark this as `nonisolated(unsafe)`.
			nonisolated(unsafe) static let defaultInstance = _StorageClass()
		#else
			static let defaultInstance = _StorageClass()
		#endif

		private init() { }

		init(copying source: _StorageClass) {
			_type = source._type
			_connect = source._connect
			_connected = source._connected
			_subscribe = source._subscribe
			_producer = source._producer
			_send = source._send
			_sendReceipt = source._sendReceipt
			_sendError = source._sendError
			_message = source._message
			_ack = source._ack
			_flow = source._flow
			_unsubscribe = source._unsubscribe
			_success = source._success
			_error = source._error
			_closeProducer = source._closeProducer
			_closeConsumer = source._closeConsumer
			_producerSuccess = source._producerSuccess
			_ping = source._ping
			_pong = source._pong
			_redeliverUnacknowledgedMessages = source._redeliverUnacknowledgedMessages
			_partitionMetadata = source._partitionMetadata
			_partitionMetadataResponse = source._partitionMetadataResponse
			_lookupTopic = source._lookupTopic
			_lookupTopicResponse = source._lookupTopicResponse
			_consumerStats = source._consumerStats
			_consumerStatsResponse = source._consumerStatsResponse
			_reachedEndOfTopic = source._reachedEndOfTopic
			_seek = source._seek
			_getLastMessageID = source._getLastMessageID
			_getLastMessageIDResponse = source._getLastMessageIDResponse
			_activeConsumerChange = source._activeConsumerChange
			_getTopicsOfNamespace = source._getTopicsOfNamespace
			_getTopicsOfNamespaceResponse = source._getTopicsOfNamespaceResponse
			_getSchema = source._getSchema
			_getSchemaResponse = source._getSchemaResponse
			_authChallenge = source._authChallenge
			_authResponse = source._authResponse
			_ackResponse = source._ackResponse
			_getOrCreateSchema = source._getOrCreateSchema
			_getOrCreateSchemaResponse = source._getOrCreateSchemaResponse
			_newTxn = source._newTxn
			_newTxnResponse = source._newTxnResponse
			_addPartitionToTxn = source._addPartitionToTxn
			_addPartitionToTxnResponse = source._addPartitionToTxnResponse
			_addSubscriptionToTxn = source._addSubscriptionToTxn
			_addSubscriptionToTxnResponse = source._addSubscriptionToTxnResponse
			_endTxn = source._endTxn
			_endTxnResponse = source._endTxnResponse
			_endTxnOnPartition = source._endTxnOnPartition
			_endTxnOnPartitionResponse = source._endTxnOnPartitionResponse
			_endTxnOnSubscription = source._endTxnOnSubscription
			_endTxnOnSubscriptionResponse = source._endTxnOnSubscriptionResponse
			_tcClientConnectRequest = source._tcClientConnectRequest
			_tcClientConnectResponse = source._tcClientConnectResponse
			_watchTopicList = source._watchTopicList
			_watchTopicListSuccess = source._watchTopicListSuccess
			_watchTopicUpdate = source._watchTopicUpdate
			_watchTopicListClose = source._watchTopicListClose
			_topicMigrated = source._topicMigrated
		}
	}

	fileprivate mutating func _uniqueStorage() -> _StorageClass {
		if !isKnownUniquelyReferenced(&_storage) {
			_storage = _StorageClass(copying: _storage)
		}
		return _storage
	}

	public var isInitialized: Bool {
		withExtendedLifetime(_storage) { (_storage: _StorageClass) in
			if _storage._type == nil {
				return false
			}
			if let v = _storage._connect, !v.isInitialized {
				return false
			}
			if let v = _storage._connected, !v.isInitialized {
				return false
			}
			if let v = _storage._subscribe, !v.isInitialized {
				return false
			}
			if let v = _storage._producer, !v.isInitialized {
				return false
			}
			if let v = _storage._send, !v.isInitialized {
				return false
			}
			if let v = _storage._sendReceipt, !v.isInitialized {
				return false
			}
			if let v = _storage._sendError, !v.isInitialized {
				return false
			}
			if let v = _storage._message, !v.isInitialized {
				return false
			}
			if let v = _storage._ack, !v.isInitialized {
				return false
			}
			if let v = _storage._flow, !v.isInitialized {
				return false
			}
			if let v = _storage._unsubscribe, !v.isInitialized {
				return false
			}
			if let v = _storage._success, !v.isInitialized {
				return false
			}
			if let v = _storage._error, !v.isInitialized {
				return false
			}
			if let v = _storage._closeProducer, !v.isInitialized {
				return false
			}
			if let v = _storage._closeConsumer, !v.isInitialized {
				return false
			}
			if let v = _storage._producerSuccess, !v.isInitialized {
				return false
			}
			if let v = _storage._redeliverUnacknowledgedMessages, !v.isInitialized {
				return false
			}
			if let v = _storage._partitionMetadata, !v.isInitialized {
				return false
			}
			if let v = _storage._partitionMetadataResponse, !v.isInitialized {
				return false
			}
			if let v = _storage._lookupTopic, !v.isInitialized {
				return false
			}
			if let v = _storage._lookupTopicResponse, !v.isInitialized {
				return false
			}
			if let v = _storage._consumerStats, !v.isInitialized {
				return false
			}
			if let v = _storage._consumerStatsResponse, !v.isInitialized {
				return false
			}
			if let v = _storage._reachedEndOfTopic, !v.isInitialized {
				return false
			}
			if let v = _storage._seek, !v.isInitialized {
				return false
			}
			if let v = _storage._getLastMessageID, !v.isInitialized {
				return false
			}
			if let v = _storage._getLastMessageIDResponse, !v.isInitialized {
				return false
			}
			if let v = _storage._activeConsumerChange, !v.isInitialized {
				return false
			}
			if let v = _storage._getTopicsOfNamespace, !v.isInitialized {
				return false
			}
			if let v = _storage._getTopicsOfNamespaceResponse, !v.isInitialized {
				return false
			}
			if let v = _storage._getSchema, !v.isInitialized {
				return false
			}
			if let v = _storage._getSchemaResponse, !v.isInitialized {
				return false
			}
			if let v = _storage._ackResponse, !v.isInitialized {
				return false
			}
			if let v = _storage._getOrCreateSchema, !v.isInitialized {
				return false
			}
			if let v = _storage._getOrCreateSchemaResponse, !v.isInitialized {
				return false
			}
			if let v = _storage._newTxn, !v.isInitialized {
				return false
			}
			if let v = _storage._newTxnResponse, !v.isInitialized {
				return false
			}
			if let v = _storage._addPartitionToTxn, !v.isInitialized {
				return false
			}
			if let v = _storage._addPartitionToTxnResponse, !v.isInitialized {
				return false
			}
			if let v = _storage._addSubscriptionToTxn, !v.isInitialized {
				return false
			}
			if let v = _storage._addSubscriptionToTxnResponse, !v.isInitialized {
				return false
			}
			if let v = _storage._endTxn, !v.isInitialized {
				return false
			}
			if let v = _storage._endTxnResponse, !v.isInitialized {
				return false
			}
			if let v = _storage._endTxnOnPartition, !v.isInitialized {
				return false
			}
			if let v = _storage._endTxnOnPartitionResponse, !v.isInitialized {
				return false
			}
			if let v = _storage._endTxnOnSubscription, !v.isInitialized {
				return false
			}
			if let v = _storage._endTxnOnSubscriptionResponse, !v.isInitialized {
				return false
			}
			if let v = _storage._tcClientConnectRequest, !v.isInitialized {
				return false
			}
			if let v = _storage._tcClientConnectResponse, !v.isInitialized {
				return false
			}
			if let v = _storage._watchTopicList, !v.isInitialized {
				return false
			}
			if let v = _storage._watchTopicListSuccess, !v.isInitialized {
				return false
			}
			if let v = _storage._watchTopicUpdate, !v.isInitialized {
				return false
			}
			if let v = _storage._watchTopicListClose, !v.isInitialized {
				return false
			}
			if let v = _storage._topicMigrated, !v.isInitialized {
				return false
			}
			return true
		}
	}

	mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
		_ = _uniqueStorage()
		try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
			while let fieldNumber = try decoder.nextFieldNumber() {
				// The use of inline closures is to circumvent an issue where the compiler
				// allocates stack space for every case branch when no optimizations are
				// enabled. https://github.com/apple/swift-protobuf/issues/1034
				switch fieldNumber {
					case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
					case 2: try decoder.decodeSingularMessageField(value: &_storage._connect)
					case 3: try decoder.decodeSingularMessageField(value: &_storage._connected)
					case 4: try decoder.decodeSingularMessageField(value: &_storage._subscribe)
					case 5: try decoder.decodeSingularMessageField(value: &_storage._producer)
					case 6: try decoder.decodeSingularMessageField(value: &_storage._send)
					case 7: try decoder.decodeSingularMessageField(value: &_storage._sendReceipt)
					case 8: try decoder.decodeSingularMessageField(value: &_storage._sendError)
					case 9: try decoder.decodeSingularMessageField(value: &_storage._message)
					case 10: try decoder.decodeSingularMessageField(value: &_storage._ack)
					case 11: try decoder.decodeSingularMessageField(value: &_storage._flow)
					case 12: try decoder.decodeSingularMessageField(value: &_storage._unsubscribe)
					case 13: try decoder.decodeSingularMessageField(value: &_storage._success)
					case 14: try decoder.decodeSingularMessageField(value: &_storage._error)
					case 15: try decoder.decodeSingularMessageField(value: &_storage._closeProducer)
					case 16: try decoder.decodeSingularMessageField(value: &_storage._closeConsumer)
					case 17: try decoder.decodeSingularMessageField(value: &_storage._producerSuccess)
					case 18: try decoder.decodeSingularMessageField(value: &_storage._ping)
					case 19: try decoder.decodeSingularMessageField(value: &_storage._pong)
					case 20: try decoder.decodeSingularMessageField(value: &_storage._redeliverUnacknowledgedMessages)
					case 21: try decoder.decodeSingularMessageField(value: &_storage._partitionMetadata)
					case 22: try decoder.decodeSingularMessageField(value: &_storage._partitionMetadataResponse)
					case 23: try decoder.decodeSingularMessageField(value: &_storage._lookupTopic)
					case 24: try decoder.decodeSingularMessageField(value: &_storage._lookupTopicResponse)
					case 25: try decoder.decodeSingularMessageField(value: &_storage._consumerStats)
					case 26: try decoder.decodeSingularMessageField(value: &_storage._consumerStatsResponse)
					case 27: try decoder.decodeSingularMessageField(value: &_storage._reachedEndOfTopic)
					case 28: try decoder.decodeSingularMessageField(value: &_storage._seek)
					case 29: try decoder.decodeSingularMessageField(value: &_storage._getLastMessageID)
					case 30: try decoder.decodeSingularMessageField(value: &_storage._getLastMessageIDResponse)
					case 31: try decoder.decodeSingularMessageField(value: &_storage._activeConsumerChange)
					case 32: try decoder.decodeSingularMessageField(value: &_storage._getTopicsOfNamespace)
					case 33: try decoder.decodeSingularMessageField(value: &_storage._getTopicsOfNamespaceResponse)
					case 34: try decoder.decodeSingularMessageField(value: &_storage._getSchema)
					case 35: try decoder.decodeSingularMessageField(value: &_storage._getSchemaResponse)
					case 36: try decoder.decodeSingularMessageField(value: &_storage._authChallenge)
					case 37: try decoder.decodeSingularMessageField(value: &_storage._authResponse)
					case 38: try decoder.decodeSingularMessageField(value: &_storage._ackResponse)
					case 39: try decoder.decodeSingularMessageField(value: &_storage._getOrCreateSchema)
					case 40: try decoder.decodeSingularMessageField(value: &_storage._getOrCreateSchemaResponse)
					case 50: try decoder.decodeSingularMessageField(value: &_storage._newTxn)
					case 51: try decoder.decodeSingularMessageField(value: &_storage._newTxnResponse)
					case 52: try decoder.decodeSingularMessageField(value: &_storage._addPartitionToTxn)
					case 53: try decoder.decodeSingularMessageField(value: &_storage._addPartitionToTxnResponse)
					case 54: try decoder.decodeSingularMessageField(value: &_storage._addSubscriptionToTxn)
					case 55: try decoder.decodeSingularMessageField(value: &_storage._addSubscriptionToTxnResponse)
					case 56: try decoder.decodeSingularMessageField(value: &_storage._endTxn)
					case 57: try decoder.decodeSingularMessageField(value: &_storage._endTxnResponse)
					case 58: try decoder.decodeSingularMessageField(value: &_storage._endTxnOnPartition)
					case 59: try decoder.decodeSingularMessageField(value: &_storage._endTxnOnPartitionResponse)
					case 60: try decoder.decodeSingularMessageField(value: &_storage._endTxnOnSubscription)
					case 61: try decoder.decodeSingularMessageField(value: &_storage._endTxnOnSubscriptionResponse)
					case 62: try decoder.decodeSingularMessageField(value: &_storage._tcClientConnectRequest)
					case 63: try decoder.decodeSingularMessageField(value: &_storage._tcClientConnectResponse)
					case 64: try decoder.decodeSingularMessageField(value: &_storage._watchTopicList)
					case 65: try decoder.decodeSingularMessageField(value: &_storage._watchTopicListSuccess)
					case 66: try decoder.decodeSingularMessageField(value: &_storage._watchTopicUpdate)
					case 67: try decoder.decodeSingularMessageField(value: &_storage._watchTopicListClose)
					case 68: try decoder.decodeSingularMessageField(value: &_storage._topicMigrated)
					default: break
				}
			}
		}
	}

	func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
		try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every if/case branch local when no optimizations
			// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
			// https://github.com/apple/swift-protobuf/issues/1182
			try { if let v = _storage._type {
				try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
			} }()
			try { if let v = _storage._connect {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
			} }()
			try { if let v = _storage._connected {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
			} }()
			try { if let v = _storage._subscribe {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
			} }()
			try { if let v = _storage._producer {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
			} }()
			try { if let v = _storage._send {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
			} }()
			try { if let v = _storage._sendReceipt {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
			} }()
			try { if let v = _storage._sendError {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
			} }()
			try { if let v = _storage._message {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
			} }()
			try { if let v = _storage._ack {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
			} }()
			try { if let v = _storage._flow {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
			} }()
			try { if let v = _storage._unsubscribe {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
			} }()
			try { if let v = _storage._success {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
			} }()
			try { if let v = _storage._error {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
			} }()
			try { if let v = _storage._closeProducer {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
			} }()
			try { if let v = _storage._closeConsumer {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
			} }()
			try { if let v = _storage._producerSuccess {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
			} }()
			try { if let v = _storage._ping {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
			} }()
			try { if let v = _storage._pong {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
			} }()
			try { if let v = _storage._redeliverUnacknowledgedMessages {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
			} }()
			try { if let v = _storage._partitionMetadata {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
			} }()
			try { if let v = _storage._partitionMetadataResponse {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
			} }()
			try { if let v = _storage._lookupTopic {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
			} }()
			try { if let v = _storage._lookupTopicResponse {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
			} }()
			try { if let v = _storage._consumerStats {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
			} }()
			try { if let v = _storage._consumerStatsResponse {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
			} }()
			try { if let v = _storage._reachedEndOfTopic {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
			} }()
			try { if let v = _storage._seek {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
			} }()
			try { if let v = _storage._getLastMessageID {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
			} }()
			try { if let v = _storage._getLastMessageIDResponse {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
			} }()
			try { if let v = _storage._activeConsumerChange {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
			} }()
			try { if let v = _storage._getTopicsOfNamespace {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
			} }()
			try { if let v = _storage._getTopicsOfNamespaceResponse {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
			} }()
			try { if let v = _storage._getSchema {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
			} }()
			try { if let v = _storage._getSchemaResponse {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
			} }()
			try { if let v = _storage._authChallenge {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
			} }()
			try { if let v = _storage._authResponse {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
			} }()
			try { if let v = _storage._ackResponse {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
			} }()
			try { if let v = _storage._getOrCreateSchema {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
			} }()
			try { if let v = _storage._getOrCreateSchemaResponse {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
			} }()
			try { if let v = _storage._newTxn {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
			} }()
			try { if let v = _storage._newTxnResponse {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
			} }()
			try { if let v = _storage._addPartitionToTxn {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
			} }()
			try { if let v = _storage._addPartitionToTxnResponse {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
			} }()
			try { if let v = _storage._addSubscriptionToTxn {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
			} }()
			try { if let v = _storage._addSubscriptionToTxnResponse {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
			} }()
			try { if let v = _storage._endTxn {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
			} }()
			try { if let v = _storage._endTxnResponse {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
			} }()
			try { if let v = _storage._endTxnOnPartition {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
			} }()
			try { if let v = _storage._endTxnOnPartitionResponse {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
			} }()
			try { if let v = _storage._endTxnOnSubscription {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
			} }()
			try { if let v = _storage._endTxnOnSubscriptionResponse {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
			} }()
			try { if let v = _storage._tcClientConnectRequest {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
			} }()
			try { if let v = _storage._tcClientConnectResponse {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 63)
			} }()
			try { if let v = _storage._watchTopicList {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
			} }()
			try { if let v = _storage._watchTopicListSuccess {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 65)
			} }()
			try { if let v = _storage._watchTopicUpdate {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
			} }()
			try { if let v = _storage._watchTopicListClose {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 67)
			} }()
			try { if let v = _storage._topicMigrated {
				try visitor.visitSingularMessageField(value: v, fieldNumber: 68)
			} }()
		}
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Pulsar_Proto_BaseCommand, rhs: Pulsar_Proto_BaseCommand) -> Bool {
		if lhs._storage !== rhs._storage {
			let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
				let _storage = _args.0
				let rhs_storage = _args.1
				if _storage._type != rhs_storage._type {
					return false
				}
				if _storage._connect != rhs_storage._connect {
					return false
				}
				if _storage._connected != rhs_storage._connected {
					return false
				}
				if _storage._subscribe != rhs_storage._subscribe {
					return false
				}
				if _storage._producer != rhs_storage._producer {
					return false
				}
				if _storage._send != rhs_storage._send {
					return false
				}
				if _storage._sendReceipt != rhs_storage._sendReceipt {
					return false
				}
				if _storage._sendError != rhs_storage._sendError {
					return false
				}
				if _storage._message != rhs_storage._message {
					return false
				}
				if _storage._ack != rhs_storage._ack {
					return false
				}
				if _storage._flow != rhs_storage._flow {
					return false
				}
				if _storage._unsubscribe != rhs_storage._unsubscribe {
					return false
				}
				if _storage._success != rhs_storage._success {
					return false
				}
				if _storage._error != rhs_storage._error {
					return false
				}
				if _storage._closeProducer != rhs_storage._closeProducer {
					return false
				}
				if _storage._closeConsumer != rhs_storage._closeConsumer {
					return false
				}
				if _storage._producerSuccess != rhs_storage._producerSuccess {
					return false
				}
				if _storage._ping != rhs_storage._ping {
					return false
				}
				if _storage._pong != rhs_storage._pong {
					return false
				}
				if _storage._redeliverUnacknowledgedMessages != rhs_storage._redeliverUnacknowledgedMessages {
					return false
				}
				if _storage._partitionMetadata != rhs_storage._partitionMetadata {
					return false
				}
				if _storage._partitionMetadataResponse != rhs_storage._partitionMetadataResponse {
					return false
				}
				if _storage._lookupTopic != rhs_storage._lookupTopic {
					return false
				}
				if _storage._lookupTopicResponse != rhs_storage._lookupTopicResponse {
					return false
				}
				if _storage._consumerStats != rhs_storage._consumerStats {
					return false
				}
				if _storage._consumerStatsResponse != rhs_storage._consumerStatsResponse {
					return false
				}
				if _storage._reachedEndOfTopic != rhs_storage._reachedEndOfTopic {
					return false
				}
				if _storage._seek != rhs_storage._seek {
					return false
				}
				if _storage._getLastMessageID != rhs_storage._getLastMessageID {
					return false
				}
				if _storage._getLastMessageIDResponse != rhs_storage._getLastMessageIDResponse {
					return false
				}
				if _storage._activeConsumerChange != rhs_storage._activeConsumerChange {
					return false
				}
				if _storage._getTopicsOfNamespace != rhs_storage._getTopicsOfNamespace {
					return false
				}
				if _storage._getTopicsOfNamespaceResponse != rhs_storage._getTopicsOfNamespaceResponse {
					return false
				}
				if _storage._getSchema != rhs_storage._getSchema {
					return false
				}
				if _storage._getSchemaResponse != rhs_storage._getSchemaResponse {
					return false
				}
				if _storage._authChallenge != rhs_storage._authChallenge {
					return false
				}
				if _storage._authResponse != rhs_storage._authResponse {
					return false
				}
				if _storage._ackResponse != rhs_storage._ackResponse {
					return false
				}
				if _storage._getOrCreateSchema != rhs_storage._getOrCreateSchema {
					return false
				}
				if _storage._getOrCreateSchemaResponse != rhs_storage._getOrCreateSchemaResponse {
					return false
				}
				if _storage._newTxn != rhs_storage._newTxn {
					return false
				}
				if _storage._newTxnResponse != rhs_storage._newTxnResponse {
					return false
				}
				if _storage._addPartitionToTxn != rhs_storage._addPartitionToTxn {
					return false
				}
				if _storage._addPartitionToTxnResponse != rhs_storage._addPartitionToTxnResponse {
					return false
				}
				if _storage._addSubscriptionToTxn != rhs_storage._addSubscriptionToTxn {
					return false
				}
				if _storage._addSubscriptionToTxnResponse != rhs_storage._addSubscriptionToTxnResponse {
					return false
				}
				if _storage._endTxn != rhs_storage._endTxn {
					return false
				}
				if _storage._endTxnResponse != rhs_storage._endTxnResponse {
					return false
				}
				if _storage._endTxnOnPartition != rhs_storage._endTxnOnPartition {
					return false
				}
				if _storage._endTxnOnPartitionResponse != rhs_storage._endTxnOnPartitionResponse {
					return false
				}
				if _storage._endTxnOnSubscription != rhs_storage._endTxnOnSubscription {
					return false
				}
				if _storage._endTxnOnSubscriptionResponse != rhs_storage._endTxnOnSubscriptionResponse {
					return false
				}
				if _storage._tcClientConnectRequest != rhs_storage._tcClientConnectRequest {
					return false
				}
				if _storage._tcClientConnectResponse != rhs_storage._tcClientConnectResponse {
					return false
				}
				if _storage._watchTopicList != rhs_storage._watchTopicList {
					return false
				}
				if _storage._watchTopicListSuccess != rhs_storage._watchTopicListSuccess {
					return false
				}
				if _storage._watchTopicUpdate != rhs_storage._watchTopicUpdate {
					return false
				}
				if _storage._watchTopicListClose != rhs_storage._watchTopicListClose {
					return false
				}
				if _storage._topicMigrated != rhs_storage._topicMigrated {
					return false
				}
				return true
			}
			if !storagesAreEqual {
				return false
			}
		}
		if lhs.unknownFields != rhs.unknownFields {
			return false
		}
		return true
	}
}

extension Pulsar_Proto_BaseCommand.TypeEnum: SwiftProtobuf._ProtoNameProviding {
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		2: .same(proto: "CONNECT"),
		3: .same(proto: "CONNECTED"),
		4: .same(proto: "SUBSCRIBE"),
		5: .same(proto: "PRODUCER"),
		6: .same(proto: "SEND"),
		7: .same(proto: "SEND_RECEIPT"),
		8: .same(proto: "SEND_ERROR"),
		9: .same(proto: "MESSAGE"),
		10: .same(proto: "ACK"),
		11: .same(proto: "FLOW"),
		12: .same(proto: "UNSUBSCRIBE"),
		13: .same(proto: "SUCCESS"),
		14: .same(proto: "ERROR"),
		15: .same(proto: "CLOSE_PRODUCER"),
		16: .same(proto: "CLOSE_CONSUMER"),
		17: .same(proto: "PRODUCER_SUCCESS"),
		18: .same(proto: "PING"),
		19: .same(proto: "PONG"),
		20: .same(proto: "REDELIVER_UNACKNOWLEDGED_MESSAGES"),
		21: .same(proto: "PARTITIONED_METADATA"),
		22: .same(proto: "PARTITIONED_METADATA_RESPONSE"),
		23: .same(proto: "LOOKUP"),
		24: .same(proto: "LOOKUP_RESPONSE"),
		25: .same(proto: "CONSUMER_STATS"),
		26: .same(proto: "CONSUMER_STATS_RESPONSE"),
		27: .same(proto: "REACHED_END_OF_TOPIC"),
		28: .same(proto: "SEEK"),
		29: .same(proto: "GET_LAST_MESSAGE_ID"),
		30: .same(proto: "GET_LAST_MESSAGE_ID_RESPONSE"),
		31: .same(proto: "ACTIVE_CONSUMER_CHANGE"),
		32: .same(proto: "GET_TOPICS_OF_NAMESPACE"),
		33: .same(proto: "GET_TOPICS_OF_NAMESPACE_RESPONSE"),
		34: .same(proto: "GET_SCHEMA"),
		35: .same(proto: "GET_SCHEMA_RESPONSE"),
		36: .same(proto: "AUTH_CHALLENGE"),
		37: .same(proto: "AUTH_RESPONSE"),
		38: .same(proto: "ACK_RESPONSE"),
		39: .same(proto: "GET_OR_CREATE_SCHEMA"),
		40: .same(proto: "GET_OR_CREATE_SCHEMA_RESPONSE"),
		50: .same(proto: "NEW_TXN"),
		51: .same(proto: "NEW_TXN_RESPONSE"),
		52: .same(proto: "ADD_PARTITION_TO_TXN"),
		53: .same(proto: "ADD_PARTITION_TO_TXN_RESPONSE"),
		54: .same(proto: "ADD_SUBSCRIPTION_TO_TXN"),
		55: .same(proto: "ADD_SUBSCRIPTION_TO_TXN_RESPONSE"),
		56: .same(proto: "END_TXN"),
		57: .same(proto: "END_TXN_RESPONSE"),
		58: .same(proto: "END_TXN_ON_PARTITION"),
		59: .same(proto: "END_TXN_ON_PARTITION_RESPONSE"),
		60: .same(proto: "END_TXN_ON_SUBSCRIPTION"),
		61: .same(proto: "END_TXN_ON_SUBSCRIPTION_RESPONSE"),
		62: .same(proto: "TC_CLIENT_CONNECT_REQUEST"),
		63: .same(proto: "TC_CLIENT_CONNECT_RESPONSE"),
		64: .same(proto: "WATCH_TOPIC_LIST"),
		65: .same(proto: "WATCH_TOPIC_LIST_SUCCESS"),
		66: .same(proto: "WATCH_TOPIC_UPDATE"),
		67: .same(proto: "WATCH_TOPIC_LIST_CLOSE"),
		68: .same(proto: "TOPIC_MIGRATED")
	]
}
